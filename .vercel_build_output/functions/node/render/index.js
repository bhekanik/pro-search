var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key2 of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key2) && (copyDefault || key2 !== "default"))
        __defProp(target, key2, { get: () => module2[key2], enumerable: !(desc = __getOwnPropDesc(module2, key2)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData2();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var import_node_worker_threads, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    import_node_worker_threads = require("worker_threads");
    init_install_fetch();
    globalThis.DOMException || (() => {
      const port = new import_node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base642 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s3) => {
        let endedWithEventsCount;
        s3.prependListener("end", () => {
          endedWithEventsCount = s3._eventsCount;
        });
        s3.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s3._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflate(), reject) : (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflateRaw(), reject);
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
function installFetch() {
  Object.defineProperties(globalThis, {
    fetch: {
      enumerable: true,
      configurable: true,
      value: fetch2
    },
    Response: {
      enumerable: true,
      configurable: true,
      value: Response2
    },
    Request: {
      enumerable: true,
      configurable: true,
      value: Request2
    },
    Headers: {
      enumerable: true,
      configurable: true,
      value: Headers2
    }
  });
}
var import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _parts, _type, _size, _a, _Blob, Blob2, Blob$1, _lastModified, _name, _a2, _File, File, t, i, h, r, m, f2, e, x, _d, _a3, FormData2, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers2, redirectStatus, isRedirect, INTERNALS$1, Response2, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request2, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    import_node_http = __toESM(require("http"), 1);
    import_node_https = __toESM(require("https"), 1);
    import_node_zlib = __toESM(require("zlib"), 1);
    import_node_stream = __toESM(require("stream"), 1);
    import_node_util = require("util");
    import_node_url = require("url");
    import_net = require("net");
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory2) {
        factory2(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop4() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop4;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a4) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry6 = this._queue.shift();
              this._queueTotalSize -= entry6.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry6.buffer, entry6.byteOffset, entry6.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              readIntoRequest._errorSteps(e2);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              throw e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e2) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          const size = init3 === null || init3 === void 0 ? void 0 : init3.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a4) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a4;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a4 = stream._writableStreamController._abortController) === null || _a4 === void 0 ? void 0 : _a4.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e2 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e2);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a4) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop4);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e2) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          const mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          const signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable3 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable3, "readable", "ReadableWritablePair");
          assertReadableStream(readable3, `${context} has member 'readable' that`);
          const writable3 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable: readable3, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop4);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e2) {
          stream._state = "errored";
          stream._storedError = e2;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e2);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e2);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e2);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e2) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e2) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e2);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e2) {
          TransformStreamError(controller._controlledTransformStream, e2);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable3 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable3._state === "errored") {
              throw readable3._storedError;
            }
            ReadableStreamDefaultControllerClose(readable3._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable3._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      constructor(blobParts = [], options = {}) {
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof _a) {
            part = element;
          } else {
            part = encoder2.encode(element);
          }
          __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));
          __privateGet(this, _parts).push(part);
        }
        const type = options.type === void 0 ? "" : String(options.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      get size() {
        return __privateGet(this, _size);
      }
      get type() {
        return __privateGet(this, _type);
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(__privateGet(this, _parts), false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(__privateGet(this, _parts), false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(__privateGet(this, _parts), true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = __privateGet(this, _parts);
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new _a([], { type: String(type).toLowerCase() });
        __privateSet(blob, _size, span);
        __privateSet(blob, _parts, blobParts);
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    _File = (_a2 = class extends Blob$1 {
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          __privateSet(this, _lastModified, lastModified);
        }
        __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2);
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData2 = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        __privateGet(this, _d).push(f2(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f2(...a);
        __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        __privateSet(this, _d, b);
      }
      *entries() {
        yield* __privateGet(this, _d);
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    }, _d = new WeakMap(), _a3);
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream.default)
          ;
        else if (body instanceof FormData2) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData2();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream.PassThrough({ highWaterMark });
        p2 = new import_node_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData2) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers2 = class extends URLSearchParams {
      constructor(init3) {
        let result = [];
        if (init3 instanceof Headers2) {
          const raw = init3.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init3 == null)
          ;
        else if (typeof init3 === "object" && !import_node_util.types.isBoxedPrimitive(init3)) {
          const method = init3[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init3));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init3].map((pair) => {
              if (typeof pair !== "object" || import_node_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key2) => {
          result[key2] = this.getAll(key2);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key2) => {
          const values = this.getAll(key2);
          if (key2 === "host") {
            result[key2] = values[0];
          } else {
            result[key2] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response2 = class extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response2(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request2 = class extends Body {
      constructor(input, init3 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init3.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init3.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init3.body ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init3.size || input.size || 0
        });
        const headers = new Headers2(init3.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init3) {
          signal = init3.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init3.referrer == null ? input.referrer : init3.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init3.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init3.follow;
        this.compress = init3.compress === void 0 ? input.compress === void 0 ? true : input.compress : init3.compress;
        this.counter = init3.counter || input.counter || 0;
        this.agent = init3.agent || input.agent;
        this.highWaterMark = init3.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init3.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init3.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
  }
});

// .svelte-kit/output/server/chunks/index-d153bcdc.js
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function each(items, fn) {
  let str = "";
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    str += fn(items[i2], i2);
  }
  return str;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css11) => css11.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true && boolean_attributes.has(name) ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
var current_component, boolean_attributes, escaped, missing_component, on_destroy;
var init_index_d153bcdc = __esm({
  ".svelte-kit/output/server/chunks/index-d153bcdc.js"() {
    Promise.resolve();
    boolean_attributes = /* @__PURE__ */ new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(obj);
    }
    module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireWildcard.js
var require_interopRequireWildcard = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireWildcard.js"(exports, module2) {
    var _typeof = require_typeof()["default"];
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key2 in obj) {
        if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key2, desc);
          } else {
            newObj[key2] = obj[key2];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    module2.exports = _interopRequireWildcard, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module2) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s3 = 1; s3 < arguments.length; s3++) {
        from = Object(arguments[s3]);
        for (var key2 in from) {
          if (hasOwnProperty.call(from, key2)) {
            to[key2] = from[key2];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/promise/thenable.js
var require_thenable = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/promise/thenable.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _default = function _default2(o) {
      return o !== void 0 && o !== null && typeof o.then === "function";
    };
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/lang/index.js
var require_lang = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/lang/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.startsWith = startsWith;
    exports.endsWith = endsWith;
    exports.get = get2;
    exports.findIndex = findIndex;
    exports.find = find;
    exports.isString = isString;
    exports.numberIsFinite = numberIsFinite;
    exports.numberIsNaN = numberIsNaN;
    exports.numberIsInteger = numberIsInteger;
    exports.uniqueId = uniqueId;
    exports.isObject = isObject;
    exports.merge = merge;
    exports.uniq = uniq;
    exports.unicAsStrings = unicAsStrings;
    exports.toString = toString;
    exports.toNumber = toNumber;
    exports.forOwn = forOwn;
    exports.groupBy = groupBy;
    exports.getFnName = getFnName;
    exports.shallowClone = shallowClone;
    exports.isBoolean = isBoolean;
    function startsWith(target, sub) {
      if (!(isString(target) && isString(sub))) {
        return false;
      }
      return target.slice(0, sub.length) === sub;
    }
    function endsWith(target, sub, caseInsensitive) {
      if (caseInsensitive === void 0) {
        caseInsensitive = false;
      }
      if (!(isString(target) && isString(sub))) {
        return false;
      }
      if (caseInsensitive) {
        target = target.toLowerCase();
        sub = sub.toLowerCase();
      }
      return target.slice(target.length - sub.length) === sub;
    }
    function get2(obj, prop, val) {
      var res = val;
      try {
        var pathPieces = prop.split(".");
        var partial = obj;
        pathPieces.forEach(function(pathPiece) {
          return partial = partial[pathPiece];
        });
        if (typeof partial !== "undefined")
          res = partial;
      } catch (e2) {
      }
      return res;
    }
    function findIndex(source, iteratee) {
      if (Array.isArray(source) && typeof iteratee === "function") {
        for (var i2 = 0; i2 < source.length; i2++) {
          if (iteratee(source[i2], i2, source) === true) {
            return i2;
          }
        }
      }
      return -1;
    }
    function find(source, iteratee) {
      var res;
      if (isObject(source)) {
        var keys = Object.keys(source);
        for (var i2 = 0; i2 < keys.length && !res; i2++) {
          var key2 = keys[i2];
          var iterateeResult = iteratee(source[key2], key2, source);
          if (iterateeResult)
            res = source[key2];
        }
      } else if (Array.isArray(source)) {
        for (var _i = 0; _i < source.length && !res; _i++) {
          var _iterateeResult = iteratee(source[_i], _i, source);
          if (_iterateeResult)
            res = source[_i];
        }
      }
      return res;
    }
    function isString(val) {
      return typeof val === "string" || val instanceof String;
    }
    function numberIsFinite(val) {
      if (val instanceof Number)
        val = val.valueOf();
      if (typeof val === "number")
        return Number.isFinite ? Number.isFinite(val) : isFinite(val);
      return false;
    }
    function numberIsNaN(val) {
      if (val instanceof Number)
        val = val.valueOf();
      return val !== val;
    }
    function numberIsInteger(val) {
      if (val instanceof Number)
        val = val.valueOf();
      if (typeof val === "number")
        return Number.isInteger ? Number.isInteger(val) : isFinite(val) && Math.floor(val) === val;
      return false;
    }
    var uniqueIdCounter = -1;
    function uniqueId() {
      return uniqueIdCounter++;
    }
    function isObject(obj) {
      return obj && typeof obj === "object" && obj.constructor === Object;
    }
    function merge(target, source) {
      var res = target;
      isObject(source) && Object.keys(source).forEach(function(key2) {
        var val = source[key2];
        if (isObject(val)) {
          if (res[key2] && isObject(res[key2])) {
            val = merge({}, res[key2], val);
          } else {
            val = merge({}, val);
          }
        }
        if (val !== void 0)
          res[key2] = val;
      });
      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        rest[_key - 2] = arguments[_key];
      }
      if (rest && rest.length) {
        var nextSource = rest.splice(0, 1)[0];
        res = merge.apply(void 0, [res, nextSource].concat(rest));
      }
      return res;
    }
    function uniq(arr) {
      var seen = {};
      return arr.filter(function(item) {
        return Object.prototype.hasOwnProperty.call(seen, item) ? false : seen[item] = true;
      });
    }
    function unicAsStrings(arr, stringify) {
      if (stringify === void 0) {
        stringify = JSON.stringify;
      }
      var seen = {};
      return arr.filter(function(item) {
        var itemString = stringify(item);
        return Object.prototype.hasOwnProperty.call(seen, itemString) ? false : seen[itemString] = true;
      });
    }
    function toString(val) {
      if (val == null)
        return "";
      if (typeof val === "string")
        return val;
      if (Array.isArray(val))
        return val.map(function(val2) {
          return isString(val2) ? val2 : "";
        }) + "";
      var result = val + "";
      return result === "0" && 1 / val === Number.NEGATIVE_INFINITY ? "-0" : result;
    }
    function toNumber(val) {
      if (typeof val === "number")
        return val;
      if (isObject(val) && typeof val.valueOf === "function") {
        var valOf = val.valueOf();
        val = isObject(valOf) ? valOf + "" : valOf;
      }
      if (typeof val !== "string") {
        return val === 0 ? val : +val;
      }
      val = val.replace(/^\s+|\s+$/g, "");
      return +val;
    }
    function forOwn(obj, iteratee) {
      var keys = Object.keys(obj);
      keys.forEach(function(key2) {
        return iteratee(obj[key2], key2, obj);
      });
      return obj;
    }
    function groupBy(source, prop) {
      var map = {};
      if (Array.isArray(source) && isString(prop)) {
        for (var i2 = 0; i2 < source.length; i2++) {
          var key2 = source[i2][prop];
          if (isString(key2)) {
            if (!map[key2])
              map[key2] = [];
            map[key2].push(source[i2]);
          }
        }
      }
      return map;
    }
    function getFnName(fn) {
      if (fn.name)
        return fn.name;
      return (fn.toString().match(/function (.+?)\(/) || ["", ""])[1];
    }
    function shallowClone(obj) {
      var keys = Object.keys(obj);
      var output = {};
      for (var i2 = 0; i2 < keys.length; i2++) {
        output[keys[i2]] = obj[keys[i2]];
      }
      return output;
    }
    function isBoolean(val) {
      return val === true || val === false;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/logger/LoggerFactory.js
var require_LoggerFactory = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/logger/LoggerFactory.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.Logger = exports.setLogLevel = exports.LogLevels = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var LogLevels = {
      "DEBUG": "DEBUG",
      "INFO": "INFO",
      "WARN": "WARN",
      "ERROR": "ERROR",
      "NONE": "NONE"
    };
    exports.LogLevels = LogLevels;
    var LogLevelIndexes = {
      DEBUG: 1,
      INFO: 2,
      WARN: 3,
      ERROR: 4,
      NONE: 5
    };
    var GlobalLogLevel = LogLevelIndexes.DEBUG;
    var setLogLevel = function setLogLevel2(level) {
      GlobalLogLevel = LogLevelIndexes[level];
    };
    exports.setLogLevel = setLogLevel;
    var defaultOptions2 = {
      showLevel: true,
      displayAllErrors: false
    };
    var Logger = /* @__PURE__ */ function() {
      function Logger2(category, options) {
        this.category = category;
        this.options = (0, _objectAssign.default)({}, defaultOptions2, options);
      }
      var _proto = Logger2.prototype;
      _proto.debug = function debug(msg) {
        if (this._shouldLog(LogLevelIndexes.DEBUG))
          this._log(LogLevels.DEBUG, msg);
      };
      _proto.info = function info(msg) {
        if (this._shouldLog(LogLevelIndexes.INFO))
          this._log(LogLevels.INFO, msg);
      };
      _proto.warn = function warn(msg) {
        if (this._shouldLog(LogLevelIndexes.WARN))
          this._log(LogLevels.WARN, msg);
      };
      _proto.error = function error2(msg) {
        if (this.options.displayAllErrors || this._shouldLog(LogLevelIndexes.ERROR))
          this._log(LogLevels.ERROR, msg);
      };
      _proto._log = function _log(level, text) {
        var formattedText = this._generateLogMessage(level, text);
        console.log(formattedText);
      };
      _proto._generateLogMessage = function _generateLogMessage(level, text) {
        var textPre = " => ";
        var result = "";
        if (this.options.showLevel) {
          result += "[" + level + "]" + (level === LogLevels.INFO || level === LogLevels.WARN ? " " : "") + " ";
        }
        if (this.category) {
          result += this.category + textPre;
        }
        return result += text;
      };
      _proto._shouldLog = function _shouldLog(level) {
        return level >= GlobalLogLevel;
      };
      return Logger2;
    }();
    exports.Logger = Logger;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/localstorage/isAvailable.js
var require_isAvailable = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/localstorage/isAvailable.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = isLocalStorageAvailable;
    function isLocalStorageAvailable() {
      var mod = "__SPLITSOFTWARE__";
      try {
        localStorage.setItem(mod, mod);
        localStorage.removeItem(mod);
        return true;
      } catch (e2) {
        return false;
      }
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/logger/index.js
var require_logger = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/logger/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = exports.API = void 0;
    var _LoggerFactory = require_LoggerFactory();
    var _isAvailable = _interopRequireDefault(require_isAvailable());
    var _lang = require_lang();
    var isLogLevelString = function isLogLevelString2(str) {
      return !!(0, _lang.find)(_LoggerFactory.LogLevels, function(lvl) {
        return str === lvl;
      });
    };
    var defaultOptions2 = {
      showLevel: true,
      displayAllErrors: false
    };
    var LS_KEY = "splitio_debug";
    var ENV_VAR_KEY = "SPLITIO_DEBUG";
    var isNode = false;
    if (typeof process !== "undefined" && typeof process.version !== "undefined" && !!process.version) {
      isNode = true;
    }
    var initialState = String(isNode ? process.env[ENV_VAR_KEY] : (0, _isAvailable.default)() ? localStorage.getItem(LS_KEY) : "");
    var createLog = function createLog2(namespace, options) {
      if (options === void 0) {
        options = {};
      }
      return new _LoggerFactory.Logger(namespace, (0, _lang.merge)(options, defaultOptions2));
    };
    var ownLog = createLog("splitio-utils:logger");
    var API = {
      enable: function enable() {
        (0, _LoggerFactory.setLogLevel)(_LoggerFactory.LogLevels.DEBUG);
      },
      setLogLevel: function setLogLevel(logLevel) {
        if (isLogLevelString(logLevel)) {
          (0, _LoggerFactory.setLogLevel)(logLevel);
        } else {
          ownLog.error("Invalid Log Level - No changes to the logs will be applied.");
        }
      },
      disable: function disable() {
        (0, _LoggerFactory.setLogLevel)(_LoggerFactory.LogLevels.NONE);
      },
      LogLevel: _LoggerFactory.LogLevels
    };
    exports.API = API;
    if (/^(enabled?|on)/i.test(initialState)) {
      API.enable(_LoggerFactory.LogLevels.DEBUG);
    } else if (isLogLevelString(initialState)) {
      API.setLogLevel(initialState);
    } else {
      API.disable();
    }
    var _default = createLog;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/apiKey.js
var require_apiKey = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/apiKey.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateApiKey = validateApiKey;
    exports.releaseApiKey = releaseApiKey;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("", {
      displayAllErrors: true
    });
    var usedKeysMap = {};
    function validateApiKey(maybeApiKey) {
      var apiKey = false;
      if (maybeApiKey == void 0) {
        log.error("Factory instantiation: you passed a null or undefined api_key, api_key must be a non-empty string.");
      } else if ((0, _lang.isString)(maybeApiKey)) {
        if (maybeApiKey.length > 0)
          apiKey = maybeApiKey;
        else
          log.error("Factory instantiation: you passed an empty api_key, api_key must be a non-empty string.");
      } else {
        log.error("Factory instantiation: you passed an invalid api_key, api_key must be a non-empty string.");
      }
      if (apiKey) {
        if (!usedKeysMap[apiKey]) {
          usedKeysMap[apiKey] = 1;
          if (Object.keys(usedKeysMap).length > 1) {
            log.warn("Factory instantiation: You already have an instance of the Split factory. Make sure you definitely want this additional instance. We recommend keeping only one instance of the factory at all times (Singleton pattern) and reusing it throughout your application.");
          }
        } else {
          log.warn("Factory instantiation: You already have " + usedKeysMap[apiKey] + " " + (usedKeysMap[apiKey] === 1 ? "factory" : "factories") + " with this API Key. We recommend keeping only one instance of the factory at all times (Singleton pattern) and reusing it throughout your application.");
          usedKeysMap[apiKey]++;
        }
      }
      return apiKey;
    }
    function releaseApiKey(apiKey) {
      if (usedKeysMap[apiKey])
        usedKeysMap[apiKey]--;
      if (usedKeysMap[apiKey] === 0)
        delete usedKeysMap[apiKey];
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/attribute.js
var require_attribute = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/attribute.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateAttribute = validateAttribute;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    function validateAttribute(attributeKey, attributeValue, method) {
      if (!(0, _lang.isString)(attributeKey) || attributeKey.length === 0) {
        log.warn(method + ": you passed an invalid attribute name, attribute name must be a non-empty string.");
        return false;
      }
      var isStringVal = (0, _lang.isString)(attributeValue);
      var isFiniteVal = (0, _lang.numberIsFinite)(attributeValue);
      var isBoolVal = (0, _lang.isBoolean)(attributeValue);
      var isArrayVal = Array.isArray(attributeValue);
      if (!(isStringVal || isFiniteVal || isBoolVal || isArrayVal)) {
        log.warn(method + ": you passed an invalid attribute value for " + attributeKey + ". Acceptable types are: string, number, boolean and array of strings.");
        return false;
      }
      return true;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/attributes.js
var require_attributes = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/attributes.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateAttributes = validateAttributes;
    exports.validateAttributesDeep = validateAttributesDeep;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var _attribute = require_attribute();
    var log = (0, _logger.default)("");
    function validateAttributes(maybeAttrs, method) {
      if ((0, _lang.isObject)(maybeAttrs) || maybeAttrs == void 0)
        return maybeAttrs;
      log.error(method + ": attributes must be a plain object.");
      return false;
    }
    function validateAttributesDeep(maybeAttributes, method) {
      if (!validateAttributes(maybeAttributes, method))
        return false;
      var result = true;
      Object.keys(maybeAttributes).forEach(function(attributeKey) {
        if (!(0, _attribute.validateAttribute)(attributeKey, maybeAttributes[attributeKey], method))
          result = false;
      });
      return result;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/event.js
var require_event = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/event.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateEvent = validateEvent;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    var EVENT_TYPE_REGEX = /^[a-zA-Z0-9][-_.:a-zA-Z0-9]{0,79}$/;
    function validateEvent(maybeEvent, method) {
      if (maybeEvent == void 0) {
        log.error(method + ": you passed a null or undefined event_type, event_type must be a non-empty string.");
      } else if (!(0, _lang.isString)(maybeEvent)) {
        log.error(method + ": you passed an invalid event_type, event_type must be a non-empty string.");
      } else {
        if (maybeEvent.length === 0) {
          log.error(method + ": you passed an empty event_type, event_type must be a non-empty string.");
        } else if (!EVENT_TYPE_REGEX.test(maybeEvent)) {
          log.error(method + ': you passed "' + maybeEvent + '", event_type must adhere to the regular expression /^[a-zA-Z0-9][-_.:a-zA-Z0-9]{0,79}$/g. This means an event_type must be alphanumeric, cannot be more than 80 characters long, and can only include a dash, underscore, period, or colon as separators of alphanumeric characters.');
        } else {
          return maybeEvent;
        }
      }
      return false;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/eventValue.js
var require_eventValue = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/eventValue.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateEventValue = validateEventValue;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    function validateEventValue(maybeValue, method) {
      if ((0, _lang.numberIsFinite)(maybeValue) || maybeValue == void 0)
        return maybeValue;
      log.error(method + ": value must be a finite number.");
      return false;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/eventProperties.js
var require_eventProperties = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/eventProperties.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateEventProperties = validateEventProperties;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    var ECMA_SIZES = {
      NULL: 0,
      STRING: 2,
      BOOLEAN: 4,
      NUMBER: 8
    };
    var MAX_PROPERTIES_AMOUNT = 300;
    var MAX_PROPERTIES_SIZE = 1024 * 32;
    var BASE_EVENT_SIZE = 1024;
    function validateEventProperties(maybeProperties, method) {
      if (maybeProperties == void 0)
        return {
          properties: null,
          size: BASE_EVENT_SIZE
        };
      if (!(0, _lang.isObject)(maybeProperties)) {
        log.error(method + ": properties must be a plain object.");
        return {
          properties: false,
          size: BASE_EVENT_SIZE
        };
      }
      var keys = Object.keys(maybeProperties);
      var clone2 = (0, _lang.shallowClone)(maybeProperties);
      var output = {
        properties: clone2,
        size: BASE_EVENT_SIZE
      };
      if (keys.length > MAX_PROPERTIES_AMOUNT) {
        log.warn(method + ": Event has more than 300 properties. Some of them will be trimmed when processed.");
      }
      for (var i2 = 0; i2 < keys.length; i2++) {
        output.size += keys[i2].length * ECMA_SIZES.STRING;
        var val = clone2[keys[i2]];
        var isStringVal = (0, _lang.isString)(val);
        var isFiniteVal = (0, _lang.numberIsFinite)(val);
        var isBoolVal = (0, _lang.isBoolean)(val);
        var isNullVal = val === null;
        if (!(isStringVal || isFiniteVal || isBoolVal || isNullVal)) {
          clone2[keys[i2]] = null;
          val = null;
          isNullVal = true;
          log.warn(method + ": Property " + keys[i2] + " is of invalid type. Setting value to null.");
        }
        if (isNullVal)
          output.size += ECMA_SIZES.NULL;
        else if (isFiniteVal)
          output.size += ECMA_SIZES.NUMBER;
        else if (isBoolVal)
          output.size += ECMA_SIZES.BOOLEAN;
        else if (isStringVal)
          output.size += val.length * ECMA_SIZES.STRING;
        if (output.size > MAX_PROPERTIES_SIZE) {
          log.error(method + ": The maximum size allowed for the properties is 32768 bytes, which was exceeded. Event not queued.");
          output.properties = false;
          break;
        }
      }
      return output;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/key.js
var require_key = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/key.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateKey = validateKey;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    var KEY_MAX_LENGTH = 250;
    function validateKeyValue(maybeKey, method, type) {
      if (maybeKey == void 0) {
        log.error(method + ": you passed a null or undefined " + type + ", " + type + " must be a non-empty string.");
        return false;
      }
      if ((0, _lang.numberIsFinite)(maybeKey)) {
        log.warn(method + ": " + type + ' "' + maybeKey + '" is not of type string, converting.');
        return (0, _lang.toString)(maybeKey);
      }
      if ((0, _lang.isString)(maybeKey)) {
        maybeKey = maybeKey.trim();
        if (maybeKey.length > 0 && maybeKey.length <= KEY_MAX_LENGTH)
          return maybeKey;
        if (maybeKey.length === 0) {
          log.error(method + ": you passed an empty string, " + type + " must be a non-empty string.");
        } else if (maybeKey.length > KEY_MAX_LENGTH) {
          log.error(method + ": " + type + " too long, " + type + " must be 250 characters or less.");
        }
      } else {
        log.error(method + ": you passed an invalid " + type + " type, " + type + " must be a non-empty string.");
      }
      return false;
    }
    function validateKey(maybeKey, method) {
      if ((0, _lang.isObject)(maybeKey)) {
        var matchingKey = validateKeyValue(maybeKey.matchingKey, method, "matchingKey");
        var bucketingKey = validateKeyValue(maybeKey.bucketingKey, method, "bucketingKey");
        if (matchingKey && bucketingKey)
          return {
            matchingKey,
            bucketingKey
          };
        log.error(method + ": Key must be an object with bucketingKey and matchingKey with valid string properties.");
        return false;
      } else {
        return validateKeyValue(maybeKey, method, "key");
      }
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/labels/index.js
var require_labels = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/labels/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.NOT_IN_SPLIT = exports.SPLIT_ARCHIVED = exports.EXCEPTION = exports.SDK_NOT_READY = exports.SPLIT_NOT_FOUND = exports.NO_CONDITION_MATCH = exports.SPLIT_KILLED = void 0;
    var SPLIT_KILLED = "killed";
    exports.SPLIT_KILLED = SPLIT_KILLED;
    var NO_CONDITION_MATCH = "default rule";
    exports.NO_CONDITION_MATCH = NO_CONDITION_MATCH;
    var SPLIT_NOT_FOUND = "definition not found";
    exports.SPLIT_NOT_FOUND = SPLIT_NOT_FOUND;
    var SDK_NOT_READY = "not ready";
    exports.SDK_NOT_READY = SDK_NOT_READY;
    var EXCEPTION = "exception";
    exports.EXCEPTION = EXCEPTION;
    var SPLIT_ARCHIVED = "archived";
    exports.SPLIT_ARCHIVED = SPLIT_ARCHIVED;
    var NOT_IN_SPLIT = "not in split";
    exports.NOT_IN_SPLIT = NOT_IN_SPLIT;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/split.js
var require_split = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/split.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateSplit = validateSplit;
    exports.validateSplitExistance = validateSplitExistance;
    var _lang = require_lang();
    var _labels = require_labels();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    var TRIMMABLE_SPACES_REGEX = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/;
    function validateSplit(maybeSplit, method, item) {
      if (item === void 0) {
        item = "split name";
      }
      if (maybeSplit == void 0) {
        log.error(method + ": you passed a null or undefined " + item + ", " + item + " must be a non-empty string.");
      } else if (!(0, _lang.isString)(maybeSplit)) {
        log.error(method + ": you passed an invalid " + item + ", " + item + " must be a non-empty string.");
      } else {
        if (TRIMMABLE_SPACES_REGEX.test(maybeSplit)) {
          log.warn(method + ": " + item + ' "' + maybeSplit + '" has extra whitespace, trimming.');
          maybeSplit = maybeSplit.trim();
        }
        if (maybeSplit.length > 0) {
          return maybeSplit;
        } else {
          log.error(method + ": you passed an empty " + item + ", " + item + " must be a non-empty string.");
        }
      }
      return false;
    }
    function validateSplitExistance(context, splitName, labelOrSplitObj, method) {
      if (context.get(context.constants.READY, true)) {
        if (labelOrSplitObj === _labels.SPLIT_NOT_FOUND || labelOrSplitObj == null) {
          log.warn(method + ': you passed "' + splitName + '" that does not exist in this environment, please double check what Splits exist in the web console.');
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/splits.js
var require_splits = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/splits.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateSplits = validateSplits;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var _split = require_split();
    var log = (0, _logger.default)("");
    function validateSplits(maybeSplits, method, listName, item) {
      if (listName === void 0) {
        listName = "split_names";
      }
      if (item === void 0) {
        item = "split name";
      }
      if (Array.isArray(maybeSplits) && maybeSplits.length > 0) {
        var validatedArray = [];
        maybeSplits.forEach(function(maybeSplit) {
          var splitName = (0, _split.validateSplit)(maybeSplit, method, item);
          if (splitName)
            validatedArray.push(splitName);
        });
        if (validatedArray.length)
          return (0, _lang.uniq)(validatedArray);
      }
      log.error(method + ": " + listName + " must be a non-empty array.");
      return false;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/constants/index.js
var require_constants = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/constants/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.OPTIMIZED = exports.DEBUG = exports.FILTERS_METADATA = exports.SPLIT_EVENT = exports.SPLIT_IMPRESSION = exports.SPLIT_TO_GOOGLE_ANALYTICS = exports.GOOGLE_ANALYTICS_TO_SPLIT = exports.NA = exports.UNKNOWN = exports.CONTROL_WITH_CONFIG = exports.CONTROL = exports.STORAGE_LOCALSTORAGE = exports.STORAGE_REDIS = exports.STORAGE_MEMORY = exports.CONSUMER_MODE = exports.PRODUCER_MODE = exports.STANDALONE_MODE = exports.LOCALHOST_MODE = void 0;
    var LOCALHOST_MODE = "localhost";
    exports.LOCALHOST_MODE = LOCALHOST_MODE;
    var STANDALONE_MODE = "standalone";
    exports.STANDALONE_MODE = STANDALONE_MODE;
    var PRODUCER_MODE = "producer";
    exports.PRODUCER_MODE = PRODUCER_MODE;
    var CONSUMER_MODE = "consumer";
    exports.CONSUMER_MODE = CONSUMER_MODE;
    var STORAGE_MEMORY = "MEMORY";
    exports.STORAGE_MEMORY = STORAGE_MEMORY;
    var STORAGE_REDIS = "REDIS";
    exports.STORAGE_REDIS = STORAGE_REDIS;
    var STORAGE_LOCALSTORAGE = "LOCALSTORAGE";
    exports.STORAGE_LOCALSTORAGE = STORAGE_LOCALSTORAGE;
    var CONTROL = "control";
    exports.CONTROL = CONTROL;
    var CONTROL_WITH_CONFIG = {
      treatment: CONTROL,
      config: null
    };
    exports.CONTROL_WITH_CONFIG = CONTROL_WITH_CONFIG;
    var UNKNOWN = "unknown";
    exports.UNKNOWN = UNKNOWN;
    var NA = "NA";
    exports.NA = NA;
    var GOOGLE_ANALYTICS_TO_SPLIT = "GOOGLE_ANALYTICS_TO_SPLIT";
    exports.GOOGLE_ANALYTICS_TO_SPLIT = GOOGLE_ANALYTICS_TO_SPLIT;
    var SPLIT_TO_GOOGLE_ANALYTICS = "SPLIT_TO_GOOGLE_ANALYTICS";
    exports.SPLIT_TO_GOOGLE_ANALYTICS = SPLIT_TO_GOOGLE_ANALYTICS;
    var SPLIT_IMPRESSION = "IMPRESSION";
    exports.SPLIT_IMPRESSION = SPLIT_IMPRESSION;
    var SPLIT_EVENT = "EVENT";
    exports.SPLIT_EVENT = SPLIT_EVENT;
    var FILTERS_METADATA = [{
      type: "byName",
      maxLength: 400,
      queryParam: "names="
    }, {
      type: "byPrefix",
      maxLength: 50,
      queryParam: "prefixes="
    }];
    exports.FILTERS_METADATA = FILTERS_METADATA;
    var DEBUG = "DEBUG";
    exports.DEBUG = DEBUG;
    var OPTIMIZED = "OPTIMIZED";
    exports.OPTIMIZED = OPTIMIZED;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/trafficType.js
var require_trafficType = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/trafficType.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateTrafficType = validateTrafficType;
    exports.validateTrafficTypeExistance = validateTrafficTypeExistance;
    var _lang = require_lang();
    var _thenable = _interopRequireDefault(require_thenable());
    var _constants = require_constants();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    var CAPITAL_LETTERS_REGEX = /[A-Z]/;
    function validateTrafficType(maybeTT, method) {
      if (maybeTT == void 0) {
        log.error(method + ": you passed a null or undefined traffic_type_name, traffic_type_name must be a non-empty string.");
      } else if (!(0, _lang.isString)(maybeTT)) {
        log.error(method + ": you passed an invalid traffic_type_name, traffic_type_name must be a non-empty string.");
      } else {
        if (maybeTT.length === 0) {
          log.error(method + ": you passed an empty traffic_type_name, traffic_type_name must be a non-empty string.");
        } else {
          if (CAPITAL_LETTERS_REGEX.test(maybeTT)) {
            log.warn(method + ": traffic_type_name should be all lowercase - converting string to lowercase.");
            maybeTT = maybeTT.toLowerCase();
          }
          return maybeTT;
        }
      }
      return false;
    }
    function logTTExistanceWarning(method, ttName) {
      log.warn(method + ": Traffic Type " + ttName + " does not have any corresponding Splits in this environment, make sure you're tracking your events to a valid traffic type defined in the Split console.");
    }
    function validateTrafficTypeExistance(maybeTT, context, method) {
      var isReady = context.get(context.constants.READY, true);
      var settings = context.get(context.constants.SETTINGS);
      var splitsStorage = context.get(context.constants.STORAGE).splits;
      if (!isReady || settings.mode === _constants.LOCALHOST_MODE)
        return true;
      var res = splitsStorage.trafficTypeExists(maybeTT);
      if ((0, _thenable.default)(res)) {
        res.then(function(isValid) {
          if (!isValid)
            logTTExistanceWarning(method, maybeTT);
          return isValid;
        });
      } else {
        if (!res)
          logTTExistanceWarning(method, maybeTT);
      }
      return res;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/isOperational.js
var require_isOperational = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/isOperational.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.validateIfDestroyed = validateIfDestroyed;
    exports.validateIfReady = validateIfReady;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("", {
      displayAllErrors: true
    });
    function validateIfDestroyed(context) {
      if (!context.get(context.constants.DESTROYED, true))
        return true;
      log.error("Client has already been destroyed - no calls possible.");
      return false;
    }
    function validateIfReady(context, method) {
      if (context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true))
        return true;
      log.warn(method + ": the SDK is not ready, results may be incorrect. Make sure to wait for SDK readiness before using this method.");
      return false;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/index.js
var require_inputValidation = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.validateIfReady = exports.validateIfDestroyed = exports.validateTrafficTypeExistance = exports.validateTrafficType = exports.validateSplits = exports.validateSplitExistance = exports.validateSplit = exports.validateKey = exports.validateEventProperties = exports.validateEventValue = exports.validateEvent = exports.validateAttributes = exports.releaseApiKey = exports.validateApiKey = void 0;
    var _apiKey = require_apiKey();
    exports.validateApiKey = _apiKey.validateApiKey;
    exports.releaseApiKey = _apiKey.releaseApiKey;
    var _attributes = require_attributes();
    exports.validateAttributes = _attributes.validateAttributes;
    var _event = require_event();
    exports.validateEvent = _event.validateEvent;
    var _eventValue = require_eventValue();
    exports.validateEventValue = _eventValue.validateEventValue;
    var _eventProperties = require_eventProperties();
    exports.validateEventProperties = _eventProperties.validateEventProperties;
    var _key = require_key();
    exports.validateKey = _key.validateKey;
    var _split = require_split();
    exports.validateSplit = _split.validateSplit;
    exports.validateSplitExistance = _split.validateSplitExistance;
    var _splits = require_splits();
    exports.validateSplits = _splits.validateSplits;
    var _trafficType = require_trafficType();
    exports.validateTrafficType = _trafficType.validateTrafficType;
    exports.validateTrafficTypeExistance = _trafficType.validateTrafficTypeExistance;
    var _isOperational = require_isOperational();
    exports.validateIfDestroyed = _isOperational.validateIfDestroyed;
    exports.validateIfReady = _isOperational.validateIfReady;
  }
});

// node_modules/@splitsoftware/splitio/lib/manager/index.js
var require_manager = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/manager/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _thenable = _interopRequireDefault(require_thenable());
    var _lang = require_lang();
    var _inputValidation = require_inputValidation();
    var collectTreatments = function collectTreatments2(splitObject) {
      var conditions = splitObject.conditions;
      var allTreatmentsCondition = (0, _lang.find)(conditions, function(cond) {
        return cond.conditionType === "ROLLOUT";
      });
      if (!allTreatmentsCondition)
        allTreatmentsCondition = conditions[0];
      return allTreatmentsCondition ? allTreatmentsCondition.partitions.map(function(v) {
        return v.treatment;
      }) : [];
    };
    var ObjectToView = function ObjectToView2(json) {
      var splitObject;
      try {
        splitObject = JSON.parse(json);
      } catch (e2) {
        return null;
      }
      if (splitObject == null)
        return null;
      return {
        name: splitObject.name,
        trafficType: splitObject.trafficTypeName || null,
        killed: splitObject.killed,
        changeNumber: splitObject.changeNumber || 0,
        treatments: collectTreatments(splitObject),
        configs: splitObject.configurations || {}
      };
    };
    var ObjectsToViews = function ObjectsToViews2(jsons) {
      var views = [];
      jsons.forEach(function(split2) {
        var view = ObjectToView(split2);
        if (view != null)
          views.push(view);
      });
      return views;
    };
    function SplitManagerFactory(_splits, context) {
      var SPLIT_FN_LABEL = "split";
      var statusManager = context.get(context.constants.STATUS_MANAGER);
      return (0, _objectAssign.default)(Object.create(statusManager), {
        split: function split2(maybeSplitName) {
          var splitName = (0, _inputValidation.validateSplit)(maybeSplitName, SPLIT_FN_LABEL);
          if (!(0, _inputValidation.validateIfDestroyed)(context) || !(0, _inputValidation.validateIfReady)(context, SPLIT_FN_LABEL) || !splitName) {
            return null;
          }
          var split3 = _splits.getSplit(splitName);
          if ((0, _thenable.default)(split3)) {
            return split3.then(function(result) {
              (0, _inputValidation.validateSplitExistance)(context, splitName, result, SPLIT_FN_LABEL);
              return ObjectToView(result);
            });
          }
          (0, _inputValidation.validateSplitExistance)(context, splitName, split3, SPLIT_FN_LABEL);
          return ObjectToView(split3);
        },
        splits: function splits() {
          if (!(0, _inputValidation.validateIfDestroyed)(context) || !(0, _inputValidation.validateIfReady)(context, "splits")) {
            return [];
          }
          var currentSplits = _splits.getAll();
          if ((0, _thenable.default)(currentSplits))
            return currentSplits.then(ObjectsToViews);
          return ObjectsToViews(currentSplits);
        },
        names: function names() {
          if (!(0, _inputValidation.validateIfDestroyed)(context) || !(0, _inputValidation.validateIfReady)(context, "names")) {
            return [];
          }
          return _splits.getKeys();
        }
      });
    }
    var _default = SplitManagerFactory;
    exports.default = _default;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module2) {
    function _setPrototypeOf(o, p) {
      module2.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _setPrototypeOf(o, p);
    }
    module2.exports = _setPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/inheritsLoose.js
var require_inheritsLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/inheritsLoose.js"(exports, module2) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      setPrototypeOf(subClass, superClass);
    }
    module2.exports = _inheritsLoose, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.defaults/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && (key2 == "length" || isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key2, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
        object[key2] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key2 in object) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
        assignValue(object, key2, newValue === void 0 ? source[key2] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key2 in Object(object)) {
          result.push(key2);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = defaults;
  }
});

// node_modules/lodash.flatten/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.flatten/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function flatten(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = flatten;
  }
});

// node_modules/lodash.isarguments/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isarguments/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isArguments;
  }
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash4 = __commonJS({
  "node_modules/ioredis/built/utils/lodash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaults = require_lodash();
    exports.defaults = defaults;
    var flatten = require_lodash2();
    exports.flatten = flatten;
    var isArguments = require_lodash3();
    exports.isArguments = isArguments;
    function noop4() {
    }
    exports.noop = noop4;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports, module2) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i2 >= len || i2 < -len)
        return void 0;
      if (i2 < 0)
        i2 += len;
      i2 = this._head + i2 & this._capacityMask;
      return this._list[i2];
    };
    Denque.prototype.get = function get2(i2) {
      return this.peekAt(i2);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size)
        return void 0;
      if (i2 < 0)
        i2 += size;
      i2 = this._head + i2 & this._capacityMask;
      var item = this._list[i2];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 - 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 + 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i2 = index;
      var removed;
      var del_count = count;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size || count < 1)
        return void 0;
      if (i2 < 0)
        i2 += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i2);
        return removed;
      }
      if (i2 === 0 && i2 + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i2 + count > size)
        count = size - i2;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i2 + k & this._capacityMask];
      }
      i2 = this._head + i2 & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i2 < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i2 = i2 - 1 + len & this._capacityMask]);
        }
        i2 = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i2 = i2 - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i2;
      } else {
        this._tail = i2;
        i2 = i2 + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i2++]);
        }
        i2 = this._tail;
        while (del_count > 0) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i2 < 0)
        i2 += size;
      if (i2 > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i2 < size / 2) {
          temp = new Array(i2);
          for (k = 0; k < i2; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 > 0) {
              this._head = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._head = this._head + i2 + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i2; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i2 + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i2 + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 != size) {
              this._tail = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i2, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i2 = 0; i2 < array.length; i2++)
        this.push(array[i2]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i2;
      if (fullCopy || this._head > this._tail) {
        for (i2 = this._head; i2 < len; i2++)
          newArray.push(list[i2]);
        for (i2 = 0; i2 < this._tail; i2++)
          newArray.push(list[i2]);
      } else {
        for (i2 = this._head; i2 < this._tail; i2++)
          newArray.push(list[i2]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/redis-commands/commands.json
var require_commands = __commonJS({
  "node_modules/redis-commands/commands.json"(exports, module2) {
    module2.exports = {
      acl: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      append: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      asking: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      auth: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog",
          "fast",
          "no_auth"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgrewriteaof: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bgsave: {
        arity: -1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      bitcount: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitfield_ro: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      bitop: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: -1,
        step: 1
      },
      bitpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      blmove: {
        arity: 6,
        flags: [
          "write",
          "denyoom",
          "noscript"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      blpop: {
        arity: -3,
        flags: [
          "write",
          "noscript"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpop: {
        arity: -3,
        flags: [
          "write",
          "noscript"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      brpoplpush: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "noscript"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      bzpopmax: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      bzpopmin: {
        arity: -3,
        flags: [
          "write",
          "noscript",
          "fast"
        ],
        keyStart: 1,
        keyStop: -2,
        step: 1
      },
      client: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      cluster: {
        arity: -2,
        flags: [
          "admin",
          "random",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      command: {
        arity: -1,
        flags: [
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      config: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      copy: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      dbsize: {
        arity: 1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      debug: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      decr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      decrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      del: {
        arity: -2,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      discard: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      dump: {
        arity: 2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      echo: {
        arity: 2,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      eval: {
        arity: -3,
        flags: [
          "noscript",
          "may_replicate",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      evalsha: {
        arity: -3,
        flags: [
          "noscript",
          "may_replicate",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exec: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      exists: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      expire: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      expireat: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      failover: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushall: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      flushdb: {
        arity: -1,
        flags: [
          "write"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      geoadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geodist: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geohash: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geopos: {
        arity: -2,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius: {
        arity: -6,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadius_ro: {
        arity: -6,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      georadiusbymember_ro: {
        arity: -5,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearch: {
        arity: -7,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      geosearchstore: {
        arity: -8,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      get: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getbit: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getdel: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getex: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      getset: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hello: {
        arity: -1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "skip_monitor",
          "skip_slowlog",
          "fast",
          "no_auth"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hexists: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hget: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hgetall: {
        arity: 2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hincrbyfloat: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hkeys: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmget: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hmset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "host:": {
        arity: -1,
        flags: [
          "readonly",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      hrandfield: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hset: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hsetnx: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hstrlen: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      hvals: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incr: {
        arity: 2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrby: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      incrbyfloat: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      info: {
        arity: -1,
        flags: [
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      keys: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lastsave: {
        arity: 1,
        flags: [
          "random",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      latency: {
        arity: -2,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lindex: {
        arity: 3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      linsert: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      llen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lmove: {
        arity: 5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      lolwut: {
        arity: -1,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      lpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpos: {
        arity: -3,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrange: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lrem: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      lset: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      ltrim: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      memory: {
        arity: -2,
        flags: [
          "readonly",
          "random",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      mget: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      migrate: {
        arity: -6,
        flags: [
          "write",
          "random",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      module: {
        arity: -2,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      monitor: {
        arity: 1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      move: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      mset: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      msetnx: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 2
      },
      multi: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      object: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      persist: {
        arity: 2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpire: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pexpireat: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfadd: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      pfcount: {
        arity: -2,
        flags: [
          "readonly",
          "may_replicate"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfdebug: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "admin"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      pfmerge: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      pfselftest: {
        arity: 1,
        flags: [
          "admin"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      ping: {
        arity: -1,
        flags: [
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      post: {
        arity: -1,
        flags: [
          "readonly",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psetex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      psubscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      psync: {
        arity: -3,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pttl: {
        arity: 2,
        flags: [
          "readonly",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      publish: {
        arity: 3,
        flags: [
          "pubsub",
          "loading",
          "stale",
          "fast",
          "may_replicate"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      pubsub: {
        arity: -2,
        flags: [
          "pubsub",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      punsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      quit: {
        arity: 1,
        flags: [
          "loading",
          "stale",
          "readonly"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      randomkey: {
        arity: 1,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readonly: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      readwrite: {
        arity: 1,
        flags: [
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rename: {
        arity: 3,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      renamenx: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      replconf: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      replicaof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      reset: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      restore: {
        arity: -4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      "restore-asking": {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "asking"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      role: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      rpop: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpoplpush: {
        arity: 3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      rpush: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      rpushx: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sadd: {
        arity: -3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      save: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scan: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      scard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      script: {
        arity: -2,
        flags: [
          "noscript",
          "may_replicate"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sdiff: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sdiffstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      select: {
        arity: 2,
        flags: [
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      set: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setbit: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setex: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setnx: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      setrange: {
        arity: 4,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      shutdown: {
        arity: -1,
        flags: [
          "admin",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sinter: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sinterstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sismember: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      slaveof: {
        arity: 3,
        flags: [
          "admin",
          "noscript",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      slowlog: {
        arity: -2,
        flags: [
          "admin",
          "random",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      smembers: {
        arity: 2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smismember: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      smove: {
        arity: 4,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      sort: {
        arity: -2,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      spop: {
        arity: -2,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srandmember: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      srem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      stralgo: {
        arity: -2,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      strlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      subscribe: {
        arity: -2,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      substr: {
        arity: 4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      sunion: {
        arity: -2,
        flags: [
          "readonly",
          "sort_for_script"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      sunionstore: {
        arity: -3,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      swapdb: {
        arity: 3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      sync: {
        arity: 1,
        flags: [
          "admin",
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      time: {
        arity: 1,
        flags: [
          "random",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      touch: {
        arity: -2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      ttl: {
        arity: 2,
        flags: [
          "readonly",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      type: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      unlink: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      unsubscribe: {
        arity: -1,
        flags: [
          "pubsub",
          "noscript",
          "loading",
          "stale"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      unwatch: {
        arity: 1,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      wait: {
        arity: 3,
        flags: [
          "noscript"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      watch: {
        arity: -2,
        flags: [
          "noscript",
          "loading",
          "stale",
          "fast"
        ],
        keyStart: 1,
        keyStop: -1,
        step: 1
      },
      xack: {
        arity: -4,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xadd: {
        arity: -5,
        flags: [
          "write",
          "denyoom",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xautoclaim: {
        arity: -6,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xclaim: {
        arity: -6,
        flags: [
          "write",
          "random",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xdel: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xgroup: {
        arity: -2,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      xinfo: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 2,
        keyStop: 2,
        step: 1
      },
      xlen: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xpending: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xread: {
        arity: -4,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xreadgroup: {
        arity: -7,
        flags: [
          "write",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      xrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xsetid: {
        arity: 3,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      xtrim: {
        arity: -2,
        flags: [
          "write",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zadd: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcard: {
        arity: 2,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zdiff: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zdiffstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zincrby: {
        arity: 4,
        flags: [
          "write",
          "denyoom",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zinter: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zinterstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zlexcount: {
        arity: 4,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zmscore: {
        arity: -3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmax: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zpopmin: {
        arity: -2,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrandmember: {
        arity: -2,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrangestore: {
        arity: -5,
        flags: [
          "write",
          "denyoom"
        ],
        keyStart: 1,
        keyStop: 2,
        step: 1
      },
      zrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrem: {
        arity: -3,
        flags: [
          "write",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebylex: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyrank: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zremrangebyscore: {
        arity: 4,
        flags: [
          "write"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrange: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebylex: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrangebyscore: {
        arity: -4,
        flags: [
          "readonly"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zrevrank: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscan: {
        arity: -3,
        flags: [
          "readonly",
          "random"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zscore: {
        arity: 3,
        flags: [
          "readonly",
          "fast"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      },
      zunion: {
        arity: -3,
        flags: [
          "readonly",
          "movablekeys"
        ],
        keyStart: 0,
        keyStop: 0,
        step: 0
      },
      zunionstore: {
        arity: -4,
        flags: [
          "write",
          "denyoom",
          "movablekeys"
        ],
        keyStart: 1,
        keyStop: 1,
        step: 1
      }
    };
  }
});

// node_modules/redis-commands/index.js
var require_redis_commands = __commonJS({
  "node_modules/redis-commands/index.js"(exports) {
    "use strict";
    var commands = require_commands();
    exports.list = Object.keys(commands);
    var flags = {};
    exports.list.forEach(function(commandName) {
      flags[commandName] = commands[commandName].flags.reduce(function(flags2, flag) {
        flags2[flag] = true;
        return flags2;
      }, {});
    });
    exports.exists = function(commandName) {
      return Boolean(commands[commandName]);
    };
    exports.hasFlag = function(commandName, flag) {
      if (!flags[commandName]) {
        throw new Error("Unknown command " + commandName);
      }
      return Boolean(flags[commandName][flag]);
    };
    exports.getKeyIndexes = function(commandName, args, options) {
      var command = commands[commandName];
      if (!command) {
        throw new Error("Unknown command " + commandName);
      }
      if (!Array.isArray(args)) {
        throw new Error("Expect args to be an array");
      }
      var keys = [];
      var i2, keyStart, keyStop, parseExternalKey;
      switch (commandName) {
        case "zunionstore":
        case "zinterstore":
          keys.push(0);
        case "eval":
        case "evalsha":
          keyStop = Number(args[1]) + 2;
          for (i2 = 2; i2 < keyStop; i2++) {
            keys.push(i2);
          }
          break;
        case "sort":
          parseExternalKey = options && options.parseExternalKey;
          keys.push(0);
          for (i2 = 1; i2 < args.length - 1; i2++) {
            if (typeof args[i2] !== "string") {
              continue;
            }
            var directive = args[i2].toUpperCase();
            if (directive === "GET") {
              i2 += 1;
              if (args[i2] !== "#") {
                if (parseExternalKey) {
                  keys.push([i2, getExternalKeyNameLength(args[i2])]);
                } else {
                  keys.push(i2);
                }
              }
            } else if (directive === "BY") {
              i2 += 1;
              if (parseExternalKey) {
                keys.push([i2, getExternalKeyNameLength(args[i2])]);
              } else {
                keys.push(i2);
              }
            } else if (directive === "STORE") {
              i2 += 1;
              keys.push(i2);
            }
          }
          break;
        case "migrate":
          if (args[2] === "") {
            for (i2 = 5; i2 < args.length - 1; i2++) {
              if (args[i2].toUpperCase() === "KEYS") {
                for (var j = i2 + 1; j < args.length; j++) {
                  keys.push(j);
                }
                break;
              }
            }
          } else {
            keys.push(2);
          }
          break;
        case "xreadgroup":
        case "xread":
          for (i2 = commandName === "xread" ? 0 : 3; i2 < args.length - 1; i2++) {
            if (String(args[i2]).toUpperCase() === "STREAMS") {
              for (j = i2 + 1; j <= i2 + (args.length - 1 - i2) / 2; j++) {
                keys.push(j);
              }
              break;
            }
          }
          break;
        default:
          if (command.step > 0) {
            keyStart = command.keyStart - 1;
            keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
            for (i2 = keyStart; i2 < keyStop; i2 += command.step) {
              keys.push(i2);
            }
          }
          break;
      }
      return keys;
    };
    function getExternalKeyNameLength(key2) {
      if (typeof key2 !== "string") {
        key2 = String(key2);
      }
      var hashPos = key2.indexOf("->");
      return hashPos === -1 ? key2.length : hashPos;
    }
  }
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS({
  "node_modules/cluster-key-slot/lib/index.js"(exports, module2) {
    var lookup = [
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ];
    var toUTF8Array = function toUTF8Array2(str) {
      var char;
      var i2 = 0;
      var p = 0;
      var utf8 = [];
      var len = str.length;
      for (; i2 < len; i2++) {
        char = str.charCodeAt(i2);
        if (char < 128) {
          utf8[p++] = char;
        } else if (char < 2048) {
          utf8[p++] = char >> 6 | 192;
          utf8[p++] = char & 63 | 128;
        } else if ((char & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
          char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
          utf8[p++] = char >> 18 | 240;
          utf8[p++] = char >> 12 & 63 | 128;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        } else {
          utf8[p++] = char >> 12 | 224;
          utf8[p++] = char >> 6 & 63 | 128;
          utf8[p++] = char & 63 | 128;
        }
      }
      return utf8;
    };
    var generate = module2.exports = function generate2(str) {
      var char;
      var i2 = 0;
      var start = -1;
      var result = 0;
      var resultHash = 0;
      var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
      var len = utf8.length;
      while (i2 < len) {
        char = utf8[i2++];
        if (start === -1) {
          if (char === 123) {
            start = i2;
          }
        } else if (char !== 125) {
          resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
        } else if (i2 - 1 !== start) {
          return resultHash & 16383;
        }
        result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
      }
      return result & 16383;
    };
    module2.exports.generateMulti = function generateMulti(keys) {
      var i2 = 1;
      var len = keys.length;
      var base2 = generate(keys[0]);
      while (i2 < len) {
        if (generate(keys[i2++]) !== base2)
          return -1;
      }
      return base2;
    };
  }
});

// node_modules/standard-as-callback/built/utils.js
var require_utils = __commonJS({
  "node_modules/standard-as-callback/built/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryCatch = exports.errorObj = void 0;
    exports.errorObj = { e: {} };
    var tryCatchTarget;
    function tryCatcher(err, val) {
      try {
        const target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e2) {
        exports.errorObj.e = e2;
        return exports.errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    exports.tryCatch = tryCatch;
  }
});

// node_modules/standard-as-callback/built/index.js
var require_built = __commonJS({
  "node_modules/standard-as-callback/built/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    function throwLater(e2) {
      setTimeout(function() {
        throw e2;
      }, 0);
    }
    function asCallback(promise, nodeback, options) {
      if (typeof nodeback === "function") {
        promise.then((val) => {
          let ret;
          if (options !== void 0 && Object(options).spread && Array.isArray(val)) {
            ret = utils_1.tryCatch(nodeback).apply(void 0, [null].concat(val));
          } else {
            ret = val === void 0 ? utils_1.tryCatch(nodeback)(null) : utils_1.tryCatch(nodeback)(null, val);
          }
          if (ret === utils_1.errorObj) {
            throwLater(ret.e);
          }
        }, (cause) => {
          if (!cause) {
            const newReason = new Error(cause + "");
            Object.assign(newReason, { cause });
            cause = newReason;
          }
          const ret = utils_1.tryCatch(nodeback)(cause);
          if (ret === utils_1.errorObj) {
            throwLater(ret.e);
          }
        });
      }
      return promise;
    }
    exports.default = asCallback;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s3 = 1e3;
    var m2 = s3 * 60;
    var h2 = m2 * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms, msAbs, s3, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key2) => {
        createDebug[key2] = env[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init3;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init3(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/ioredis/built/utils/debug.js
var require_debug = __commonJS({
  "node_modules/ioredis/built/utils/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = require_src();
    var MAX_ARGUMENT_LENGTH = 200;
    exports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
    var NAMESPACE_PREFIX = "ioredis";
    function getStringValue(v) {
      if (v === null) {
        return;
      }
      switch (typeof v) {
        case "boolean":
          return;
        case "number":
          return;
        case "object":
          if (Buffer.isBuffer(v)) {
            return v.toString("hex");
          }
          if (Array.isArray(v)) {
            return v.join(",");
          }
          try {
            return JSON.stringify(v);
          } catch (e2) {
            return;
          }
        case "string":
          return v;
      }
    }
    exports.getStringValue = getStringValue;
    function genRedactedString(str, maxLen) {
      const { length } = str;
      return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
    }
    exports.genRedactedString = genRedactedString;
    function genDebugFunction(namespace) {
      const fn = debug_1.default(`${NAMESPACE_PREFIX}:${namespace}`);
      function wrappedDebug(...args) {
        if (!fn.enabled) {
          return;
        }
        for (let i2 = 1; i2 < args.length; i2++) {
          const str = getStringValue(args[i2]);
          if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
            args[i2] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
          }
        }
        return fn.apply(null, args);
      }
      Object.defineProperties(wrappedDebug, {
        namespace: {
          get() {
            return fn.namespace;
          }
        },
        enabled: {
          get() {
            return fn.enabled;
          }
        },
        destroy: {
          get() {
            return fn.destroy;
          }
        },
        log: {
          get() {
            return fn.log;
          },
          set(l) {
            fn.log = l;
          }
        }
      });
      return wrappedDebug;
    }
    exports.default = genDebugFunction;
  }
});

// node_modules/ioredis/built/constants/TLSProfiles.js
var require_TLSProfiles = __commonJS({
  "node_modules/ioredis/built/constants/TLSProfiles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      RedisCloudFixed: {
        ca: "-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n"
      },
      RedisCloudFlexible: {
        ca: "-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz\nTGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\naXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC\nVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz\nMS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw\nggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1\nG5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY\nDm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl\npp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT\nULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag\n54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ\nxeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC\nJpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K\n2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3\nStsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI\nSIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B\ncS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL\nyzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T\nAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg\nz5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu\nrYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3\n3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+\nhSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ\nD0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj\nTY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l\nFXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj\nmcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf\nybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji\nn8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F\nUhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h\n-----END CERTIFICATE-----\n"
      }
    };
  }
});

// node_modules/ioredis/built/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/ioredis/built/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var url_1 = require("url");
    var lodash_1 = require_lodash4();
    exports.defaults = lodash_1.defaults;
    exports.noop = lodash_1.noop;
    exports.flatten = lodash_1.flatten;
    var debug_1 = require_debug();
    exports.Debug = debug_1.default;
    var TLSProfiles_1 = require_TLSProfiles();
    function bufferEqual(a, b) {
      if (typeof a.equals === "function") {
        return a.equals(b);
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; ++i2) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    exports.bufferEqual = bufferEqual;
    function convertBufferToString(value, encoding) {
      if (value instanceof Buffer) {
        return value.toString(encoding);
      }
      if (Array.isArray(value)) {
        const length = value.length;
        const res = Array(length);
        for (let i2 = 0; i2 < length; ++i2) {
          res[i2] = value[i2] instanceof Buffer && encoding === "utf8" ? value[i2].toString() : convertBufferToString(value[i2], encoding);
        }
        return res;
      }
      return value;
    }
    exports.convertBufferToString = convertBufferToString;
    function wrapMultiResult(arr) {
      if (!arr) {
        return null;
      }
      const result = [];
      const length = arr.length;
      for (let i2 = 0; i2 < length; ++i2) {
        const item = arr[i2];
        if (item instanceof Error) {
          result.push([item]);
        } else {
          result.push([null, item]);
        }
      }
      return result;
    }
    exports.wrapMultiResult = wrapMultiResult;
    function isInt(value) {
      const x2 = parseFloat(value);
      return !isNaN(value) && (x2 | 0) === x2;
    }
    exports.isInt = isInt;
    function packObject(array) {
      const result = {};
      const length = array.length;
      for (let i2 = 1; i2 < length; i2 += 2) {
        result[array[i2 - 1]] = array[i2];
      }
      return result;
    }
    exports.packObject = packObject;
    function timeout(callback, timeout2) {
      let timer;
      const run2 = function() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
          callback.apply(this, arguments);
        }
      };
      timer = setTimeout(run2, timeout2, new Error("timeout"));
      return run2;
    }
    exports.timeout = timeout;
    function convertObjectToArray(obj) {
      const result = [];
      const keys = Object.keys(obj);
      for (let i2 = 0, l = keys.length; i2 < l; i2++) {
        result.push(keys[i2], obj[keys[i2]]);
      }
      return result;
    }
    exports.convertObjectToArray = convertObjectToArray;
    function convertMapToArray(map) {
      const result = [];
      let pos = 0;
      map.forEach(function(value, key2) {
        result[pos] = key2;
        result[pos + 1] = value;
        pos += 2;
      });
      return result;
    }
    exports.convertMapToArray = convertMapToArray;
    function toArg(arg) {
      if (arg === null || typeof arg === "undefined") {
        return "";
      }
      return String(arg);
    }
    exports.toArg = toArg;
    function optimizeErrorStack(error2, friendlyStack, filterPath) {
      const stacks = friendlyStack.split("\n");
      let lines = "";
      let i2;
      for (i2 = 1; i2 < stacks.length; ++i2) {
        if (stacks[i2].indexOf(filterPath) === -1) {
          break;
        }
      }
      for (let j = i2; j < stacks.length; ++j) {
        lines += "\n" + stacks[j];
      }
      const pos = error2.stack.indexOf("\n");
      error2.stack = error2.stack.slice(0, pos) + lines;
      return error2;
    }
    exports.optimizeErrorStack = optimizeErrorStack;
    function parseURL(url) {
      if (isInt(url)) {
        return { port: url };
      }
      let parsed = url_1.parse(url, true, true);
      if (!parsed.slashes && url[0] !== "/") {
        url = "//" + url;
        parsed = url_1.parse(url, true, true);
      }
      const options = parsed.query || {};
      const allowUsernameInURI = options.allowUsernameInURI && options.allowUsernameInURI !== "false";
      delete options.allowUsernameInURI;
      const result = {};
      if (parsed.auth) {
        const index = parsed.auth.indexOf(":");
        if (allowUsernameInURI) {
          result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
        }
        result.password = index === -1 ? "" : parsed.auth.slice(index + 1);
      }
      if (parsed.pathname) {
        if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
          if (parsed.pathname.length > 1) {
            result.db = parsed.pathname.slice(1);
          }
        } else {
          result.path = parsed.pathname;
        }
      }
      if (parsed.host) {
        result.host = parsed.hostname;
      }
      if (parsed.port) {
        result.port = parsed.port;
      }
      lodash_1.defaults(result, options);
      return result;
    }
    exports.parseURL = parseURL;
    function resolveTLSProfile(options) {
      let tls = options === null || options === void 0 ? void 0 : options.tls;
      if (typeof tls === "string")
        tls = { profile: tls };
      const profile = TLSProfiles_1.default[tls === null || tls === void 0 ? void 0 : tls.profile];
      if (profile) {
        tls = Object.assign({}, profile, tls);
        delete tls.profile;
        options = Object.assign({}, options, { tls });
      }
      return options;
    }
    exports.resolveTLSProfile = resolveTLSProfile;
    function sample(array, from = 0) {
      const length = array.length;
      if (from >= length) {
        return;
      }
      return array[from + Math.floor(Math.random() * (length - from))];
    }
    exports.sample = sample;
    function shuffle(array) {
      let counter = array.length;
      while (counter > 0) {
        const index = Math.floor(Math.random() * counter);
        counter--;
        [array[counter], array[index]] = [array[index], array[counter]];
      }
      return array;
    }
    exports.shuffle = shuffle;
    exports.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
    function zipMap(keys, values) {
      const map = /* @__PURE__ */ new Map();
      keys.forEach((key2, index) => {
        map.set(key2, values[index]);
      });
      return map;
    }
    exports.zipMap = zipMap;
  }
});

// node_modules/ioredis/built/promiseContainer.js
var require_promiseContainer = __commonJS({
  "node_modules/ioredis/built/promiseContainer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
    exports.isPromise = isPromise;
    var promise = Promise;
    function get2() {
      return promise;
    }
    exports.get = get2;
    function set3(lib) {
      if (typeof lib !== "function") {
        throw new Error(`Provided Promise must be a function, got ${lib}`);
      }
      promise = lib;
    }
    exports.set = set3;
  }
});

// node_modules/ioredis/built/command.js
var require_command = __commonJS({
  "node_modules/ioredis/built/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commands = require_redis_commands();
    var calculateSlot = require_lib();
    var standard_as_callback_1 = require_built();
    var utils_1 = require_utils2();
    var lodash_1 = require_lodash4();
    var promiseContainer_1 = require_promiseContainer();
    var Command = class {
      constructor(name, args = [], options = {}, callback) {
        this.name = name;
        this.transformed = false;
        this.isCustomCommand = false;
        this.inTransaction = false;
        this.isResolved = false;
        this.replyEncoding = options.replyEncoding;
        this.errorStack = options.errorStack;
        this.args = lodash_1.flatten(args);
        this.callback = callback;
        this.initPromise();
        if (options.keyPrefix) {
          this._iterateKeys((key2) => options.keyPrefix + key2);
        }
        if (options.readOnly) {
          this.isReadOnly = true;
        }
      }
      static getFlagMap() {
        if (!this.flagMap) {
          this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {
            map[flagName] = {};
            Command.FLAGS[flagName].forEach((commandName) => {
              map[flagName][commandName] = true;
            });
            return map;
          }, {});
        }
        return this.flagMap;
      }
      static checkFlag(flagName, commandName) {
        return !!this.getFlagMap()[flagName][commandName];
      }
      static setArgumentTransformer(name, func) {
        this._transformer.argument[name] = func;
      }
      static setReplyTransformer(name, func) {
        this._transformer.reply[name] = func;
      }
      initPromise() {
        const Promise2 = promiseContainer_1.get();
        const promise = new Promise2((resolve2, reject) => {
          if (!this.transformed) {
            this.transformed = true;
            const transformer = Command._transformer.argument[this.name];
            if (transformer) {
              this.args = transformer(this.args);
            }
            this.stringifyArguments();
          }
          this.resolve = this._convertValue(resolve2);
          if (this.errorStack) {
            this.reject = (err) => {
              reject(utils_1.optimizeErrorStack(err, this.errorStack.stack, __dirname));
            };
          } else {
            this.reject = reject;
          }
        });
        this.promise = standard_as_callback_1.default(promise, this.callback);
      }
      getSlot() {
        if (typeof this.slot === "undefined") {
          const key2 = this.getKeys()[0];
          this.slot = key2 == null ? null : calculateSlot(key2);
        }
        return this.slot;
      }
      getKeys() {
        return this._iterateKeys();
      }
      _iterateKeys(transform = (key2) => key2) {
        if (typeof this.keys === "undefined") {
          this.keys = [];
          if (commands.exists(this.name)) {
            const keyIndexes = commands.getKeyIndexes(this.name, this.args);
            for (const index of keyIndexes) {
              this.args[index] = transform(this.args[index]);
              this.keys.push(this.args[index]);
            }
          }
        }
        return this.keys;
      }
      toWritable() {
        let bufferMode = false;
        for (const arg of this.args) {
          if (arg instanceof Buffer) {
            bufferMode = true;
            break;
          }
        }
        let result;
        const commandStr = "*" + (this.args.length + 1) + "\r\n$" + Buffer.byteLength(this.name) + "\r\n" + this.name + "\r\n";
        if (bufferMode) {
          const buffers = new MixedBuffers();
          buffers.push(commandStr);
          for (const arg of this.args) {
            if (arg instanceof Buffer) {
              if (arg.length === 0) {
                buffers.push("$0\r\n\r\n");
              } else {
                buffers.push("$" + arg.length + "\r\n");
                buffers.push(arg);
                buffers.push("\r\n");
              }
            } else {
              buffers.push("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
            }
          }
          result = buffers.toBuffer();
        } else {
          result = commandStr;
          for (const arg of this.args) {
            result += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
          }
        }
        return result;
      }
      stringifyArguments() {
        for (let i2 = 0; i2 < this.args.length; ++i2) {
          const arg = this.args[i2];
          if (!(arg instanceof Buffer) && typeof arg !== "string") {
            this.args[i2] = utils_1.toArg(arg);
          }
        }
      }
      _convertValue(resolve2) {
        return (value) => {
          try {
            const existingTimer = this._commandTimeoutTimer;
            if (existingTimer) {
              clearTimeout(existingTimer);
              delete this._commandTimeoutTimer;
            }
            resolve2(this.transformReply(value));
            this.isResolved = true;
          } catch (err) {
            this.reject(err);
          }
          return this.promise;
        };
      }
      transformReply(result) {
        if (this.replyEncoding) {
          result = utils_1.convertBufferToString(result, this.replyEncoding);
        }
        const transformer = Command._transformer.reply[this.name];
        if (transformer) {
          result = transformer(result);
        }
        return result;
      }
      setTimeout(ms) {
        if (!this._commandTimeoutTimer) {
          this._commandTimeoutTimer = setTimeout(() => {
            if (!this.isResolved) {
              this.reject(new Error("Command timed out"));
            }
          }, ms);
        }
      }
    };
    exports.default = Command;
    Command.FLAGS = {
      VALID_IN_SUBSCRIBER_MODE: [
        "subscribe",
        "psubscribe",
        "unsubscribe",
        "punsubscribe",
        "ping",
        "quit"
      ],
      VALID_IN_MONITOR_MODE: ["monitor", "auth"],
      ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe"],
      EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe"],
      WILL_DISCONNECT: ["quit"]
    };
    Command._transformer = {
      argument: {},
      reply: {}
    };
    var msetArgumentTransformer = function(args) {
      if (args.length === 1) {
        if (typeof Map !== "undefined" && args[0] instanceof Map) {
          return utils_1.convertMapToArray(args[0]);
        }
        if (typeof args[0] === "object" && args[0] !== null) {
          return utils_1.convertObjectToArray(args[0]);
        }
      }
      return args;
    };
    var hsetArgumentTransformer = function(args) {
      if (args.length === 2) {
        if (typeof Map !== "undefined" && args[1] instanceof Map) {
          return [args[0]].concat(utils_1.convertMapToArray(args[1]));
        }
        if (typeof args[1] === "object" && args[1] !== null) {
          return [args[0]].concat(utils_1.convertObjectToArray(args[1]));
        }
      }
      return args;
    };
    Command.setArgumentTransformer("mset", msetArgumentTransformer);
    Command.setArgumentTransformer("msetnx", msetArgumentTransformer);
    Command.setArgumentTransformer("hset", hsetArgumentTransformer);
    Command.setArgumentTransformer("hmset", hsetArgumentTransformer);
    Command.setReplyTransformer("hgetall", function(result) {
      if (Array.isArray(result)) {
        const obj = {};
        for (let i2 = 0; i2 < result.length; i2 += 2) {
          const key2 = result[i2];
          const value = result[i2 + 1];
          if (key2 in obj) {
            Object.defineProperty(obj, key2, {
              value,
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            obj[key2] = value;
          }
        }
        return obj;
      }
      return result;
    });
    var MixedBuffers = class {
      constructor() {
        this.length = 0;
        this.items = [];
      }
      push(x2) {
        this.length += Buffer.byteLength(x2);
        this.items.push(x2);
      }
      toBuffer() {
        const result = Buffer.allocUnsafe(this.length);
        let offset = 0;
        for (const item of this.items) {
          const length = Buffer.byteLength(item);
          Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);
          offset += length;
        }
        return result;
      }
    };
  }
});

// node_modules/ioredis/built/script.js
var require_script = __commonJS({
  "node_modules/ioredis/built/script.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var promiseContainer_1 = require_promiseContainer();
    var command_1 = require_command();
    var standard_as_callback_1 = require_built();
    var Script = class {
      constructor(lua, numberOfKeys = null, keyPrefix = "", readOnly = false) {
        this.lua = lua;
        this.numberOfKeys = numberOfKeys;
        this.keyPrefix = keyPrefix;
        this.readOnly = readOnly;
        this.sha = crypto_1.createHash("sha1").update(lua).digest("hex");
      }
      execute(container, args, options, callback) {
        if (typeof this.numberOfKeys === "number") {
          args.unshift(this.numberOfKeys);
        }
        if (this.keyPrefix) {
          options.keyPrefix = this.keyPrefix;
        }
        if (this.readOnly) {
          options.readOnly = true;
        }
        const evalsha = new command_1.default("evalsha", [this.sha].concat(args), options);
        evalsha.isCustomCommand = true;
        const result = container.sendCommand(evalsha);
        if (promiseContainer_1.isPromise(result)) {
          return standard_as_callback_1.default(result.catch((err) => {
            if (err.toString().indexOf("NOSCRIPT") === -1) {
              throw err;
            }
            return container.sendCommand(new command_1.default("eval", [this.lua].concat(args), options));
          }), callback);
        }
        standard_as_callback_1.default(evalsha.promise, callback);
        return result;
      }
    };
    exports.default = Script;
  }
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS({
  "node_modules/ioredis/built/autoPipelining.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseContainer = require_promiseContainer();
    var lodash_1 = require_lodash4();
    var calculateSlot = require_lib();
    var standard_as_callback_1 = require_built();
    exports.kExec = Symbol("exec");
    exports.kCallbacks = Symbol("callbacks");
    exports.notAllowedAutoPipelineCommands = [
      "auth",
      "info",
      "script",
      "quit",
      "cluster",
      "pipeline",
      "multi",
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "unpsubscribe"
    ];
    function executeAutoPipeline(client, slotKey) {
      if (client._runningAutoPipelines.has(slotKey)) {
        return;
      }
      if (!client._autoPipelines.has(slotKey)) {
        return;
      }
      client._runningAutoPipelines.add(slotKey);
      const pipeline2 = client._autoPipelines.get(slotKey);
      client._autoPipelines.delete(slotKey);
      const callbacks = pipeline2[exports.kCallbacks];
      pipeline2[exports.kCallbacks] = null;
      pipeline2.exec(function(err, results) {
        client._runningAutoPipelines.delete(slotKey);
        if (err) {
          for (let i2 = 0; i2 < callbacks.length; i2++) {
            process.nextTick(callbacks[i2], err);
          }
        } else {
          for (let i2 = 0; i2 < callbacks.length; i2++) {
            process.nextTick(callbacks[i2], ...results[i2]);
          }
        }
        if (client._autoPipelines.has(slotKey)) {
          executeAutoPipeline(client, slotKey);
        }
      });
    }
    function shouldUseAutoPipelining(client, functionName, commandName) {
      return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);
    }
    exports.shouldUseAutoPipelining = shouldUseAutoPipelining;
    function getFirstValueInFlattenedArray(args) {
      for (let i2 = 0; i2 < args.length; i2++) {
        const arg = args[i2];
        if (typeof arg === "string") {
          return arg;
        } else if (Array.isArray(arg) || lodash_1.isArguments(arg)) {
          if (arg.length === 0) {
            continue;
          }
          return arg[0];
        }
        const flattened = lodash_1.flatten([arg]);
        if (flattened.length > 0) {
          return flattened[0];
        }
      }
      return void 0;
    }
    exports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;
    function executeWithAutoPipelining(client, functionName, commandName, args, callback) {
      const CustomPromise = PromiseContainer.get();
      if (client.isCluster && !client.slots.length) {
        if (client.status === "wait")
          client.connect().catch(lodash_1.noop);
        return standard_as_callback_1.default(new CustomPromise(function(resolve2, reject) {
          client.delayUntilReady((err) => {
            if (err) {
              reject(err);
              return;
            }
            executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve2, reject);
          });
        }), callback);
      }
      const prefix = client.options.keyPrefix || "";
      const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(",") : "main";
      if (!client._autoPipelines.has(slotKey)) {
        const pipeline3 = client.pipeline();
        pipeline3[exports.kExec] = false;
        pipeline3[exports.kCallbacks] = [];
        client._autoPipelines.set(slotKey, pipeline3);
      }
      const pipeline2 = client._autoPipelines.get(slotKey);
      if (!pipeline2[exports.kExec]) {
        pipeline2[exports.kExec] = true;
        setImmediate(executeAutoPipeline, client, slotKey);
      }
      const autoPipelinePromise = new CustomPromise(function(resolve2, reject) {
        pipeline2[exports.kCallbacks].push(function(err, value) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(value);
        });
        pipeline2[functionName](...args);
      });
      return standard_as_callback_1.default(autoPipelinePromise, callback);
    }
    exports.executeWithAutoPipelining = executeWithAutoPipelining;
  }
});

// node_modules/ioredis/built/commander.js
var require_commander = __commonJS({
  "node_modules/ioredis/built/commander.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lodash_1 = require_lodash4();
    var command_1 = require_command();
    var script_1 = require_script();
    var PromiseContainer = require_promiseContainer();
    var standard_as_callback_1 = require_built();
    var autoPipelining_1 = require_autoPipelining();
    var DROP_BUFFER_SUPPORT_ERROR = '*Buffer methods are not available because "dropBufferSupport" option is enabled.Refer to https://github.com/luin/ioredis/wiki/Improve-Performance for more details.';
    function Commander() {
      this.options = lodash_1.defaults({}, this.options || {}, {
        showFriendlyErrorStack: false
      });
      this.scriptsSet = {};
      this.addedBuiltinSet = /* @__PURE__ */ new Set();
    }
    exports.default = Commander;
    var commands = require_redis_commands().list.filter(function(command) {
      return command !== "monitor";
    });
    commands.push("sentinel");
    Commander.prototype.getBuiltinCommands = function() {
      return commands.slice(0);
    };
    Commander.prototype.createBuiltinCommand = function(commandName) {
      return {
        string: generateFunction(null, commandName, "utf8"),
        buffer: generateFunction(null, commandName, null)
      };
    };
    Commander.prototype.addBuiltinCommand = function(commandName) {
      this.addedBuiltinSet.add(commandName);
      this[commandName] = generateFunction(commandName, commandName, "utf8");
      this[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
    };
    commands.forEach(function(commandName) {
      Commander.prototype[commandName] = generateFunction(commandName, commandName, "utf8");
      Commander.prototype[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
    });
    Commander.prototype.call = generateFunction("call", "utf8");
    Commander.prototype.callBuffer = generateFunction("callBuffer", null);
    Commander.prototype.send_command = Commander.prototype.call;
    Commander.prototype.defineCommand = function(name, definition) {
      const script = new script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);
      this.scriptsSet[name] = script;
      this[name] = generateScriptingFunction(name, name, script, "utf8");
      this[name + "Buffer"] = generateScriptingFunction(name + "Buffer", name, script, null);
    };
    Commander.prototype.sendCommand = function() {
    };
    function generateFunction(functionName, _commandName, _encoding) {
      if (typeof _encoding === "undefined") {
        _encoding = _commandName;
        _commandName = null;
      }
      return function(...args) {
        const commandName = _commandName || args.shift();
        let callback = args[args.length - 1];
        if (typeof callback === "function") {
          args.pop();
        } else {
          callback = void 0;
        }
        const options = {
          errorStack: this.options.showFriendlyErrorStack ? new Error() : void 0,
          keyPrefix: this.options.keyPrefix,
          replyEncoding: _encoding
        };
        if (this.options.dropBufferSupport && !_encoding) {
          return standard_as_callback_1.default(PromiseContainer.get().reject(new Error(DROP_BUFFER_SUPPORT_ERROR)), callback);
        }
        if (!autoPipelining_1.shouldUseAutoPipelining(this, functionName, commandName)) {
          return this.sendCommand(new command_1.default(commandName, args, options, callback));
        }
        return autoPipelining_1.executeWithAutoPipelining(this, functionName, commandName, args, callback);
      };
    }
    function generateScriptingFunction(functionName, commandName, script, encoding) {
      return function() {
        let length = arguments.length;
        const lastArgIndex = length - 1;
        let callback = arguments[lastArgIndex];
        if (typeof callback !== "function") {
          callback = void 0;
        } else {
          length = lastArgIndex;
        }
        const args = new Array(length);
        for (let i2 = 0; i2 < length; i2++) {
          args[i2] = arguments[i2];
        }
        let options;
        if (this.options.dropBufferSupport) {
          if (!encoding) {
            return standard_as_callback_1.default(PromiseContainer.get().reject(new Error(DROP_BUFFER_SUPPORT_ERROR)), callback);
          }
          options = { replyEncoding: null };
        } else {
          options = { replyEncoding: encoding };
        }
        if (this.options.showFriendlyErrorStack) {
          options.errorStack = new Error();
        }
        if (!autoPipelining_1.shouldUseAutoPipelining(this, functionName, commandName)) {
          return script.execute(this, args, options, callback);
        }
        return autoPipelining_1.executeWithAutoPipelining(this, functionName, commandName, args, callback);
      };
    }
  }
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS({
  "node_modules/redis-errors/lib/old.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var util = require("util");
    function RedisError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(RedisError, Error);
    Object.defineProperty(RedisError.prototype, "name", {
      value: "RedisError",
      configurable: true,
      writable: true
    });
    function ParserError(message, buffer, offset) {
      assert(buffer);
      assert.strictEqual(typeof offset, "number");
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer;
    }
    util.inherits(ParserError, RedisError);
    Object.defineProperty(ParserError.prototype, "name", {
      value: "ParserError",
      configurable: true,
      writable: true
    });
    function ReplyError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(this, this.constructor);
      Error.stackTraceLimit = tmp;
    }
    util.inherits(ReplyError, RedisError);
    Object.defineProperty(ReplyError.prototype, "name", {
      value: "ReplyError",
      configurable: true,
      writable: true
    });
    function AbortError2(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(AbortError2, RedisError);
    Object.defineProperty(AbortError2.prototype, "name", {
      value: "AbortError",
      configurable: true,
      writable: true
    });
    function InterruptError(message) {
      Object.defineProperty(this, "message", {
        value: message || "",
        configurable: true,
        writable: true
      });
      Error.captureStackTrace(this, this.constructor);
    }
    util.inherits(InterruptError, AbortError2);
    Object.defineProperty(InterruptError.prototype, "name", {
      value: "InterruptError",
      configurable: true,
      writable: true
    });
    module2.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError: AbortError2,
      InterruptError
    };
  }
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS({
  "node_modules/redis-errors/lib/modern.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var RedisError = class extends Error {
      get name() {
        return this.constructor.name;
      }
    };
    var ParserError = class extends RedisError {
      constructor(message, buffer, offset) {
        assert(buffer);
        assert.strictEqual(typeof offset, "number");
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
        this.offset = offset;
        this.buffer = buffer;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var ReplyError = class extends RedisError {
      constructor(message) {
        const tmp = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        super(message);
        Error.stackTraceLimit = tmp;
      }
      get name() {
        return this.constructor.name;
      }
    };
    var AbortError2 = class extends RedisError {
      get name() {
        return this.constructor.name;
      }
    };
    var InterruptError = class extends AbortError2 {
      get name() {
        return this.constructor.name;
      }
    };
    module2.exports = {
      RedisError,
      ParserError,
      ReplyError,
      AbortError: AbortError2,
      InterruptError
    };
  }
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS({
  "node_modules/redis-errors/index.js"(exports, module2) {
    "use strict";
    var Errors = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
    module2.exports = Errors;
  }
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS({
  "node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var redis_errors_1 = require_redis_errors();
    var MaxRetriesPerRequestError = class extends redis_errors_1.AbortError {
      constructor(maxRetriesPerRequest) {
        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
        super(message);
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
    };
    exports.default = MaxRetriesPerRequestError;
  }
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS({
  "node_modules/ioredis/built/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
    exports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
  }
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/redis-parser/lib/parser.js"(exports, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var StringDecoder = require("string_decoder").StringDecoder;
    var decoder = new StringDecoder();
    var errors = require_redis_errors();
    var ReplyError = errors.ReplyError;
    var ParserError = errors.ParserError;
    var bufferPool = Buffer2.allocUnsafe(32 * 1024);
    var bufferOffset = 0;
    var interval = null;
    var counter = 0;
    var notDecreased = 0;
    function parseSimpleNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      var sign = 1;
      if (parser.buffer[offset] === 45) {
        sign = -1;
        offset++;
      }
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return sign * number;
        }
        number = number * 10 + (c1 - 48);
      }
    }
    function parseStringNumbers(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      var res = "";
      if (parser.buffer[offset] === 45) {
        res += "-";
        offset++;
      }
      while (offset < length) {
        var c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          if (number !== 0) {
            res += number;
          }
          return res;
        } else if (number > 429496728) {
          res += number * 10 + (c1 - 48);
          number = 0;
        } else if (c1 === 48 && number === 0) {
          res += 0;
        } else {
          number = number * 10 + (c1 - 48);
        }
      }
    }
    function parseSimpleString(parser) {
      const start = parser.offset;
      const buffer = parser.buffer;
      const length = buffer.length - 1;
      var offset = start;
      while (offset < length) {
        if (buffer[offset++] === 13) {
          parser.offset = offset + 1;
          if (parser.optionReturnBuffers === true) {
            return parser.buffer.slice(start, offset - 1);
          }
          return parser.buffer.toString("utf8", start, offset - 1);
        }
      }
    }
    function parseLength(parser) {
      const length = parser.buffer.length - 1;
      var offset = parser.offset;
      var number = 0;
      while (offset < length) {
        const c1 = parser.buffer[offset++];
        if (c1 === 13) {
          parser.offset = offset + 1;
          return number;
        }
        number = number * 10 + (c1 - 48);
      }
    }
    function parseInteger(parser) {
      if (parser.optionStringNumbers === true) {
        return parseStringNumbers(parser);
      }
      return parseSimpleNumbers(parser);
    }
    function parseBulkString(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const offset = parser.offset + length;
      if (offset + 2 > parser.buffer.length) {
        parser.bigStrSize = offset + 2;
        parser.totalChunkSize = parser.buffer.length;
        parser.bufferCache.push(parser.buffer);
        return;
      }
      const start = parser.offset;
      parser.offset = offset + 2;
      if (parser.optionReturnBuffers === true) {
        return parser.buffer.slice(start, offset);
      }
      return parser.buffer.toString("utf8", start, offset);
    }
    function parseError(parser) {
      var string = parseSimpleString(parser);
      if (string !== void 0) {
        if (parser.optionReturnBuffers === true) {
          string = string.toString();
        }
        return new ReplyError(string);
      }
    }
    function handleError(parser, type) {
      const err = new ParserError("Protocol error, got " + JSON.stringify(String.fromCharCode(type)) + " as reply type byte", JSON.stringify(parser.buffer), parser.offset);
      parser.buffer = null;
      parser.returnFatalError(err);
    }
    function parseArray(parser) {
      const length = parseLength(parser);
      if (length === void 0) {
        return;
      }
      if (length < 0) {
        return null;
      }
      const responses = new Array(length);
      return parseArrayElements(parser, responses, 0);
    }
    function pushArrayCache(parser, array, pos) {
      parser.arrayCache.push(array);
      parser.arrayPos.push(pos);
    }
    function parseArrayChunks(parser) {
      const tmp = parser.arrayCache.pop();
      var pos = parser.arrayPos.pop();
      if (parser.arrayCache.length) {
        const res = parseArrayChunks(parser);
        if (res === void 0) {
          pushArrayCache(parser, tmp, pos);
          return;
        }
        tmp[pos++] = res;
      }
      return parseArrayElements(parser, tmp, pos);
    }
    function parseArrayElements(parser, responses, i2) {
      const bufferLength = parser.buffer.length;
      while (i2 < responses.length) {
        const offset = parser.offset;
        if (parser.offset >= bufferLength) {
          pushArrayCache(parser, responses, i2);
          return;
        }
        const response = parseType(parser, parser.buffer[parser.offset++]);
        if (response === void 0) {
          if (!(parser.arrayCache.length || parser.bufferCache.length)) {
            parser.offset = offset;
          }
          pushArrayCache(parser, responses, i2);
          return;
        }
        responses[i2] = response;
        i2++;
      }
      return responses;
    }
    function parseType(parser, type) {
      switch (type) {
        case 36:
          return parseBulkString(parser);
        case 43:
          return parseSimpleString(parser);
        case 42:
          return parseArray(parser);
        case 58:
          return parseInteger(parser);
        case 45:
          return parseError(parser);
        default:
          return handleError(parser, type);
      }
    }
    function decreaseBufferPool() {
      if (bufferPool.length > 50 * 1024) {
        if (counter === 1 || notDecreased > counter * 2) {
          const minSliceLen = Math.floor(bufferPool.length / 10);
          const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
          bufferOffset = 0;
          bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
        } else {
          notDecreased++;
          counter--;
        }
      } else {
        clearInterval(interval);
        counter = 0;
        notDecreased = 0;
        interval = null;
      }
    }
    function resizeBuffer(length) {
      if (bufferPool.length < length + bufferOffset) {
        const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
        if (bufferOffset > 1024 * 1024 * 111) {
          bufferOffset = 1024 * 1024 * 50;
        }
        bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
        bufferOffset = 0;
        counter++;
        if (interval === null) {
          interval = setInterval(decreaseBufferPool, 50);
        }
      }
    }
    function concatBulkString(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      var res = decoder.write(list[0].slice(oldOffset));
      for (var i2 = 1; i2 < chunks - 1; i2++) {
        res += decoder.write(list[i2]);
      }
      res += decoder.end(list[i2].slice(0, offset - 2));
      return res;
    }
    function concatBulkBuffer(parser) {
      const list = parser.bufferCache;
      const oldOffset = parser.offset;
      const length = parser.bigStrSize - oldOffset - 2;
      var chunks = list.length;
      var offset = parser.bigStrSize - parser.totalChunkSize;
      parser.offset = offset;
      if (offset <= 2) {
        if (chunks === 2) {
          return list[0].slice(oldOffset, list[0].length + offset - 2);
        }
        chunks--;
        offset = list[list.length - 2].length + offset;
      }
      resizeBuffer(length);
      const start = bufferOffset;
      list[0].copy(bufferPool, start, oldOffset, list[0].length);
      bufferOffset += list[0].length - oldOffset;
      for (var i2 = 1; i2 < chunks - 1; i2++) {
        list[i2].copy(bufferPool, bufferOffset);
        bufferOffset += list[i2].length;
      }
      list[i2].copy(bufferPool, bufferOffset, 0, offset - 2);
      bufferOffset += offset - 2;
      return bufferPool.slice(start, bufferOffset);
    }
    var JavascriptRedisParser = class {
      constructor(options) {
        if (!options) {
          throw new TypeError("Options are mandatory.");
        }
        if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
          throw new TypeError("The returnReply and returnError options have to be functions.");
        }
        this.setReturnBuffers(!!options.returnBuffers);
        this.setStringNumbers(!!options.stringNumbers);
        this.returnError = options.returnError;
        this.returnFatalError = options.returnFatalError || options.returnError;
        this.returnReply = options.returnReply;
        this.reset();
      }
      reset() {
        this.offset = 0;
        this.buffer = null;
        this.bigStrSize = 0;
        this.totalChunkSize = 0;
        this.bufferCache = [];
        this.arrayCache = [];
        this.arrayPos = [];
      }
      setReturnBuffers(returnBuffers) {
        if (typeof returnBuffers !== "boolean") {
          throw new TypeError("The returnBuffers argument has to be a boolean");
        }
        this.optionReturnBuffers = returnBuffers;
      }
      setStringNumbers(stringNumbers) {
        if (typeof stringNumbers !== "boolean") {
          throw new TypeError("The stringNumbers argument has to be a boolean");
        }
        this.optionStringNumbers = stringNumbers;
      }
      execute(buffer) {
        if (this.buffer === null) {
          this.buffer = buffer;
          this.offset = 0;
        } else if (this.bigStrSize === 0) {
          const oldLength = this.buffer.length;
          const remainingLength = oldLength - this.offset;
          const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer.length);
          this.buffer.copy(newBuffer, 0, this.offset, oldLength);
          buffer.copy(newBuffer, remainingLength, 0, buffer.length);
          this.buffer = newBuffer;
          this.offset = 0;
          if (this.arrayCache.length) {
            const arr = parseArrayChunks(this);
            if (arr === void 0) {
              return;
            }
            this.returnReply(arr);
          }
        } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {
          this.bufferCache.push(buffer);
          var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
          this.bigStrSize = 0;
          this.bufferCache = [];
          this.buffer = buffer;
          if (this.arrayCache.length) {
            this.arrayCache[0][this.arrayPos[0]++] = tmp;
            tmp = parseArrayChunks(this);
            if (tmp === void 0) {
              return;
            }
          }
          this.returnReply(tmp);
        } else {
          this.bufferCache.push(buffer);
          this.totalChunkSize += buffer.length;
          return;
        }
        while (this.offset < this.buffer.length) {
          const offset = this.offset;
          const type = this.buffer[this.offset++];
          const response = parseType(this, type);
          if (response === void 0) {
            if (!(this.arrayCache.length || this.bufferCache.length)) {
              this.offset = offset;
            }
            return;
          }
          if (type === 45) {
            this.returnError(response);
          } else {
            this.returnReply(response);
          }
        }
        this.buffer = null;
      }
    };
    module2.exports = JavascriptRedisParser;
  }
});

// node_modules/redis-parser/index.js
var require_redis_parser = __commonJS({
  "node_modules/redis-parser/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_parser();
  }
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS({
  "node_modules/ioredis/built/SubscriptionSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SubscriptionSet = class {
      constructor() {
        this.set = {
          subscribe: {},
          psubscribe: {}
        };
      }
      add(set3, channel) {
        this.set[mapSet(set3)][channel] = true;
      }
      del(set3, channel) {
        delete this.set[mapSet(set3)][channel];
      }
      channels(set3) {
        return Object.keys(this.set[mapSet(set3)]);
      }
      isEmpty() {
        return this.channels("subscribe").length === 0 && this.channels("psubscribe").length === 0;
      }
    };
    exports.default = SubscriptionSet;
    function mapSet(set3) {
      if (set3 === "unsubscribe") {
        return "subscribe";
      }
      if (set3 === "punsubscribe") {
        return "psubscribe";
      }
      return set3;
    }
  }
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS({
  "node_modules/ioredis/built/DataHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var command_1 = require_command();
    var utils_1 = require_utils2();
    var RedisParser = require_redis_parser();
    var SubscriptionSet_1 = require_SubscriptionSet();
    var debug = utils_1.Debug("dataHandler");
    var DataHandler = class {
      constructor(redis, parserOptions) {
        this.redis = redis;
        const parser = new RedisParser({
          stringNumbers: parserOptions.stringNumbers,
          returnBuffers: !parserOptions.dropBufferSupport,
          returnError: (err) => {
            this.returnError(err);
          },
          returnFatalError: (err) => {
            this.returnFatalError(err);
          },
          returnReply: (reply) => {
            this.returnReply(reply);
          }
        });
        redis.stream.on("data", (data) => {
          parser.execute(data);
        });
      }
      returnFatalError(err) {
        err.message += ". Please report this.";
        this.redis.recoverFromFatalError(err, err, { offlineQueue: false });
      }
      returnError(err) {
        const item = this.shiftCommand(err);
        if (!item) {
          return;
        }
        err.command = {
          name: item.command.name,
          args: item.command.args
        };
        this.redis.handleReconnection(err, item);
      }
      returnReply(reply) {
        if (this.handleMonitorReply(reply)) {
          return;
        }
        if (this.handleSubscriberReply(reply)) {
          return;
        }
        const item = this.shiftCommand(reply);
        if (!item) {
          return;
        }
        if (command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
          this.redis.condition.subscriber = new SubscriptionSet_1.default();
          this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
          if (!fillSubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
        } else if (command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
          if (!fillUnsubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
        } else {
          item.command.resolve(reply);
        }
      }
      handleSubscriberReply(reply) {
        if (!this.redis.condition.subscriber) {
          return false;
        }
        const replyType = Array.isArray(reply) ? reply[0].toString() : null;
        debug('receive reply "%s" in subscriber mode', replyType);
        switch (replyType) {
          case "message":
            if (this.redis.listeners("message").length > 0) {
              this.redis.emit("message", reply[1].toString(), reply[2] ? reply[2].toString() : "");
            }
            this.redis.emit("messageBuffer", reply[1], reply[2]);
            break;
          case "pmessage": {
            const pattern = reply[1].toString();
            if (this.redis.listeners("pmessage").length > 0) {
              this.redis.emit("pmessage", pattern, reply[2].toString(), reply[3].toString());
            }
            this.redis.emit("pmessageBuffer", pattern, reply[2], reply[3]);
            break;
          }
          case "subscribe":
          case "psubscribe": {
            const channel = reply[1].toString();
            this.redis.condition.subscriber.add(replyType, channel);
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            if (!fillSubCommand(item.command, reply[2])) {
              this.redis.commandQueue.unshift(item);
            }
            break;
          }
          case "unsubscribe":
          case "punsubscribe": {
            const channel = reply[1] ? reply[1].toString() : null;
            if (channel) {
              this.redis.condition.subscriber.del(replyType, channel);
            }
            const count = reply[2];
            if (count === 0) {
              this.redis.condition.subscriber = false;
            }
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            if (!fillUnsubCommand(item.command, count)) {
              this.redis.commandQueue.unshift(item);
            }
            break;
          }
          default: {
            const item = this.shiftCommand(reply);
            if (!item) {
              return;
            }
            item.command.resolve(reply);
          }
        }
        return true;
      }
      handleMonitorReply(reply) {
        if (this.redis.status !== "monitoring") {
          return false;
        }
        const replyStr = reply.toString();
        if (replyStr === "OK") {
          return false;
        }
        const len = replyStr.indexOf(" ");
        const timestamp = replyStr.slice(0, len);
        const argindex = replyStr.indexOf('"');
        const args = replyStr.slice(argindex + 1, -1).split('" "').map((elem) => elem.replace(/\\"/g, '"'));
        const dbAndSource = replyStr.slice(len + 2, argindex - 2).split(" ");
        this.redis.emit("monitor", timestamp, args, dbAndSource[1], dbAndSource[0]);
        return true;
      }
      shiftCommand(reply) {
        const item = this.redis.commandQueue.shift();
        if (!item) {
          const message = "Command queue state error. If you can reproduce this, please report it.";
          const error2 = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));
          this.redis.emit("error", error2);
          return null;
        }
        return item;
      }
    };
    exports.default = DataHandler;
    function fillSubCommand(command, count) {
      if (typeof command.remainReplies === "undefined") {
        command.remainReplies = command.args.length;
      }
      if (--command.remainReplies === 0) {
        command.resolve(count);
        return true;
      }
      return false;
    }
    function fillUnsubCommand(command, count) {
      if (typeof command.remainReplies === "undefined") {
        command.remainReplies = command.args.length;
      }
      if (command.remainReplies === 0) {
        if (count === 0) {
          command.resolve(count);
          return true;
        }
        return false;
      }
      if (--command.remainReplies === 0) {
        command.resolve(count);
        return true;
      }
      return false;
    }
  }
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS({
  "node_modules/ioredis/built/redis/event_handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var redis_errors_1 = require_redis_errors();
    var command_1 = require_command();
    var errors_1 = require_errors();
    var utils_1 = require_utils2();
    var DataHandler_1 = require_DataHandler();
    var debug = utils_1.Debug("connection");
    function connectHandler(self2) {
      return function() {
        self2.setStatus("connect");
        self2.resetCommandQueue();
        let flushed = false;
        const { connectionEpoch } = self2;
        if (self2.condition.auth) {
          self2.auth(self2.condition.auth, function(err) {
            if (connectionEpoch !== self2.connectionEpoch) {
              return;
            }
            if (err) {
              if (err.message.indexOf("no password is set") !== -1) {
                console.warn("[WARN] Redis server does not require a password, but a password was supplied.");
              } else if (err.message.indexOf("without any password configured for the default user") !== -1) {
                console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied");
              } else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
                console.warn(`[ERROR] The server returned "wrong number of arguments for 'auth' command". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);
              } else {
                flushed = true;
                self2.recoverFromFatalError(err, err);
              }
            }
          });
        }
        if (self2.condition.select) {
          self2.select(self2.condition.select).catch((err) => {
            self2.silentEmit("error", err);
          });
        }
        if (!self2.options.enableReadyCheck) {
          exports.readyHandler(self2)();
        }
        new DataHandler_1.default(self2, {
          stringNumbers: self2.options.stringNumbers,
          dropBufferSupport: self2.options.dropBufferSupport
        });
        if (self2.options.enableReadyCheck) {
          self2._readyCheck(function(err, info) {
            if (connectionEpoch !== self2.connectionEpoch) {
              return;
            }
            if (err) {
              if (!flushed) {
                self2.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
              }
            } else {
              self2.serverInfo = info;
              if (self2.connector.check(info)) {
                exports.readyHandler(self2)();
              } else {
                self2.disconnect(true);
              }
            }
          });
        }
      };
    }
    exports.connectHandler = connectHandler;
    function abortError(command) {
      const err = new redis_errors_1.AbortError("Command aborted due to connection close");
      err.command = {
        name: command.name,
        args: command.args
      };
      return err;
    }
    function abortIncompletePipelines(commandQueue) {
      let expectedIndex = 0;
      for (let i2 = 0; i2 < commandQueue.length; ) {
        const command = commandQueue.peekAt(i2).command;
        const pipelineIndex = command.pipelineIndex;
        if (pipelineIndex === void 0 || pipelineIndex === 0) {
          expectedIndex = 0;
        }
        if (pipelineIndex !== void 0 && pipelineIndex !== expectedIndex++) {
          commandQueue.remove(i2, 1);
          command.reject(abortError(command));
          continue;
        }
        i2++;
      }
    }
    function abortTransactionFragments(commandQueue) {
      for (let i2 = 0; i2 < commandQueue.length; ) {
        const command = commandQueue.peekAt(i2).command;
        if (command.name === "multi") {
          break;
        }
        if (command.name === "exec") {
          commandQueue.remove(i2, 1);
          command.reject(abortError(command));
          break;
        }
        if (command.inTransaction) {
          commandQueue.remove(i2, 1);
          command.reject(abortError(command));
        } else {
          i2++;
        }
      }
    }
    function closeHandler(self2) {
      return function() {
        self2.setStatus("close");
        if (!self2.prevCondition) {
          self2.prevCondition = self2.condition;
        }
        if (self2.commandQueue.length) {
          abortIncompletePipelines(self2.commandQueue);
          self2.prevCommandQueue = self2.commandQueue;
        }
        if (self2.offlineQueue.length) {
          abortTransactionFragments(self2.offlineQueue);
        }
        self2.clearAddedScriptHashesCleanInterval();
        if (self2.manuallyClosing) {
          self2.manuallyClosing = false;
          debug("skip reconnecting since the connection is manually closed.");
          return close();
        }
        if (typeof self2.options.retryStrategy !== "function") {
          debug("skip reconnecting because `retryStrategy` is not a function");
          return close();
        }
        const retryDelay = self2.options.retryStrategy(++self2.retryAttempts);
        if (typeof retryDelay !== "number") {
          debug("skip reconnecting because `retryStrategy` doesn't return a number");
          return close();
        }
        debug("reconnect in %sms", retryDelay);
        self2.setStatus("reconnecting", retryDelay);
        self2.reconnectTimeout = setTimeout(function() {
          self2.reconnectTimeout = null;
          self2.connect().catch(utils_1.noop);
        }, retryDelay);
        const { maxRetriesPerRequest } = self2.options;
        if (typeof maxRetriesPerRequest === "number") {
          if (maxRetriesPerRequest < 0) {
            debug("maxRetriesPerRequest is negative, ignoring...");
          } else {
            const remainder = self2.retryAttempts % (maxRetriesPerRequest + 1);
            if (remainder === 0) {
              debug("reach maxRetriesPerRequest limitation, flushing command queue...");
              self2.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
            }
          }
        }
      };
      function close() {
        self2.setStatus("end");
        self2.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
      }
    }
    exports.closeHandler = closeHandler;
    function errorHandler(self2) {
      return function(error2) {
        debug("error: %s", error2);
        self2.silentEmit("error", error2);
      };
    }
    exports.errorHandler = errorHandler;
    function readyHandler(self2) {
      return function() {
        self2.setStatus("ready");
        self2.retryAttempts = 0;
        if (self2.options.monitor) {
          self2.call("monitor");
          const { sendCommand } = self2;
          self2.sendCommand = function(command) {
            if (command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command.name)) {
              return sendCommand.call(self2, command);
            }
            command.reject(new Error("Connection is in monitoring mode, can't process commands."));
            return command.promise;
          };
          self2.once("close", function() {
            delete self2.sendCommand;
          });
          self2.setStatus("monitoring");
          return;
        }
        const finalSelect = self2.prevCondition ? self2.prevCondition.select : self2.condition.select;
        if (self2.options.connectionName) {
          debug("set the connection name [%s]", self2.options.connectionName);
          self2.client("setname", self2.options.connectionName).catch(utils_1.noop);
        }
        if (self2.options.readOnly) {
          debug("set the connection to readonly mode");
          self2.readonly().catch(utils_1.noop);
        }
        if (self2.prevCondition) {
          const condition = self2.prevCondition;
          self2.prevCondition = null;
          if (condition.subscriber && self2.options.autoResubscribe) {
            if (self2.condition.select !== finalSelect) {
              debug("connect to db [%d]", finalSelect);
              self2.select(finalSelect);
            }
            const subscribeChannels = condition.subscriber.channels("subscribe");
            if (subscribeChannels.length) {
              debug("subscribe %d channels", subscribeChannels.length);
              self2.subscribe(subscribeChannels);
            }
            const psubscribeChannels = condition.subscriber.channels("psubscribe");
            if (psubscribeChannels.length) {
              debug("psubscribe %d channels", psubscribeChannels.length);
              self2.psubscribe(psubscribeChannels);
            }
          }
        }
        if (self2.prevCommandQueue) {
          if (self2.options.autoResendUnfulfilledCommands) {
            debug("resend %d unfulfilled commands", self2.prevCommandQueue.length);
            while (self2.prevCommandQueue.length > 0) {
              const item = self2.prevCommandQueue.shift();
              if (item.select !== self2.condition.select && item.command.name !== "select") {
                self2.select(item.select);
              }
              self2.sendCommand(item.command, item.stream);
            }
          } else {
            self2.prevCommandQueue = null;
          }
        }
        if (self2.offlineQueue.length) {
          debug("send %d commands in offline queue", self2.offlineQueue.length);
          const offlineQueue = self2.offlineQueue;
          self2.resetOfflineQueue();
          while (offlineQueue.length > 0) {
            const item = offlineQueue.shift();
            if (item.select !== self2.condition.select && item.command.name !== "select") {
              self2.select(item.select);
            }
            self2.sendCommand(item.command, item.stream);
          }
        }
        if (self2.condition.select !== finalSelect) {
          debug("connect to db [%d]", finalSelect);
          self2.select(finalSelect);
        }
      };
    }
    exports.readyHandler = readyHandler;
  }
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS({
  "node_modules/ioredis/built/connectors/AbstractConnector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var debug = utils_1.Debug("AbstractConnector");
    var AbstractConnector = class {
      constructor(disconnectTimeout) {
        this.connecting = false;
        this.disconnectTimeout = disconnectTimeout;
      }
      check(info) {
        return true;
      }
      disconnect() {
        this.connecting = false;
        if (this.stream) {
          const stream = this.stream;
          const timeout = setTimeout(() => {
            debug("stream %s:%s still open, destroying it", stream.remoteAddress, stream.remotePort);
            stream.destroy();
          }, this.disconnectTimeout);
          stream.on("close", () => clearTimeout(timeout));
          stream.end();
        }
      }
    };
    exports.default = AbstractConnector;
  }
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS({
  "node_modules/ioredis/built/connectors/StandaloneConnector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = require("net");
    var tls_1 = require("tls");
    var utils_1 = require_utils2();
    var AbstractConnector_1 = require_AbstractConnector();
    function isIIpcConnectionOptions(value) {
      return value.path;
    }
    exports.isIIpcConnectionOptions = isIIpcConnectionOptions;
    var StandaloneConnector = class extends AbstractConnector_1.default {
      constructor(options) {
        super(options.disconnectTimeout);
        this.options = options;
      }
      connect(_) {
        const { options } = this;
        this.connecting = true;
        let connectionOptions;
        if (isIIpcConnectionOptions(options)) {
          connectionOptions = {
            path: options.path
          };
        } else {
          connectionOptions = {};
          if (options.port != null) {
            connectionOptions.port = options.port;
          }
          if (options.host != null) {
            connectionOptions.host = options.host;
          }
          if (options.family != null) {
            connectionOptions.family = options.family;
          }
        }
        if (options.tls) {
          Object.assign(connectionOptions, options.tls);
        }
        return new Promise((resolve2, reject) => {
          process.nextTick(() => {
            if (!this.connecting) {
              reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
              return;
            }
            try {
              if (options.tls) {
                this.stream = tls_1.connect(connectionOptions);
              } else {
                this.stream = net_1.createConnection(connectionOptions);
              }
            } catch (err) {
              reject(err);
              return;
            }
            this.stream.once("error", (err) => {
              this.firstError = err;
            });
            resolve2(this.stream);
          });
        });
      }
    };
    exports.default = StandaloneConnector;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSentinelEql(a, b) {
      return (a.host || "127.0.0.1") === (b.host || "127.0.0.1") && (a.port || 26379) === (b.port || 26379);
    }
    var SentinelIterator = class {
      constructor(sentinels) {
        this.cursor = 0;
        this.sentinels = sentinels.slice(0);
      }
      next() {
        const done = this.cursor >= this.sentinels.length;
        return { done, value: done ? void 0 : this.sentinels[this.cursor++] };
      }
      reset(moveCurrentEndpointToFirst) {
        if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
          this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
        }
        this.cursor = 0;
      }
      add(sentinel) {
        for (let i2 = 0; i2 < this.sentinels.length; i2++) {
          if (isSentinelEql(sentinel, this.sentinels[i2])) {
            return false;
          }
        }
        this.sentinels.push(sentinel);
        return true;
      }
      toString() {
        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
      }
    };
    exports.default = SentinelIterator;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var debug = utils_1.Debug("FailoverDetector");
    var CHANNEL_NAME = "+switch-master";
    var FailoverDetector = class {
      constructor(connector, sentinels) {
        this.isDisconnected = false;
        this.connector = connector;
        this.sentinels = sentinels;
      }
      cleanup() {
        this.isDisconnected = true;
        for (const sentinel of this.sentinels) {
          sentinel.client.disconnect();
        }
      }
      subscribe() {
        return __awaiter(this, void 0, void 0, function* () {
          debug("Starting FailoverDetector");
          const promises = [];
          for (const sentinel of this.sentinels) {
            const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
              debug("Failed to subscribe to failover messages on sentinel %s:%s (%s)", sentinel.address.host || "127.0.0.1", sentinel.address.port || 26739, err.message);
            });
            promises.push(promise);
            sentinel.client.on("message", (channel) => {
              if (!this.isDisconnected && channel === CHANNEL_NAME) {
                this.disconnect();
              }
            });
          }
          yield Promise.all(promises);
        });
      }
      disconnect() {
        this.isDisconnected = true;
        debug("Failover detected, disconnecting");
        this.connector.disconnect();
      }
    };
    exports.FailoverDetector = FailoverDetector;
  }
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS({
  "node_modules/ioredis/built/connectors/SentinelConnector/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = require("net");
    var utils_1 = require_utils2();
    var tls_1 = require("tls");
    var StandaloneConnector_1 = require_StandaloneConnector();
    var SentinelIterator_1 = require_SentinelIterator();
    exports.SentinelIterator = SentinelIterator_1.default;
    var AbstractConnector_1 = require_AbstractConnector();
    var redis_1 = require_redis();
    var FailoverDetector_1 = require_FailoverDetector();
    var debug = utils_1.Debug("SentinelConnector");
    var SentinelConnector = class extends AbstractConnector_1.default {
      constructor(options) {
        super(options.disconnectTimeout);
        this.options = options;
        this.failoverDetector = null;
        this.emitter = null;
        if (!this.options.sentinels.length) {
          throw new Error("Requires at least one sentinel to connect to.");
        }
        if (!this.options.name) {
          throw new Error("Requires the name of master.");
        }
        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
      }
      check(info) {
        const roleMatches = !info.role || this.options.role === info.role;
        if (!roleMatches) {
          debug("role invalid, expected %s, but got %s", this.options.role, info.role);
          this.sentinelIterator.next();
          this.sentinelIterator.next();
          this.sentinelIterator.reset(true);
        }
        return roleMatches;
      }
      disconnect() {
        super.disconnect();
        if (this.failoverDetector) {
          this.failoverDetector.cleanup();
        }
      }
      connect(eventEmitter) {
        this.connecting = true;
        this.retryAttempts = 0;
        let lastError;
        const connectToNext = () => __awaiter(this, void 0, void 0, function* () {
          const endpoint = this.sentinelIterator.next();
          if (endpoint.done) {
            this.sentinelIterator.reset(false);
            const retryDelay = typeof this.options.sentinelRetryStrategy === "function" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;
            let errorMsg = typeof retryDelay !== "number" ? "All sentinels are unreachable and retry is disabled." : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
            if (lastError) {
              errorMsg += ` Last error: ${lastError.message}`;
            }
            debug(errorMsg);
            const error2 = new Error(errorMsg);
            if (typeof retryDelay === "number") {
              eventEmitter("error", error2);
              yield new Promise((resolve2) => setTimeout(resolve2, retryDelay));
              return connectToNext();
            } else {
              throw error2;
            }
          }
          let resolved = null;
          let err = null;
          try {
            resolved = yield this.resolve(endpoint.value);
          } catch (error2) {
            err = error2;
          }
          if (!this.connecting) {
            throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
          }
          const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
          if (resolved) {
            debug("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
            if (this.options.enableTLSForSentinelMode && this.options.tls) {
              Object.assign(resolved, this.options.tls);
              this.stream = tls_1.connect(resolved);
            } else {
              this.stream = net_1.createConnection(resolved);
            }
            this.stream.once("connect", () => this.initFailoverDetector());
            this.stream.once("error", (err2) => {
              this.firstError = err2;
            });
            return this.stream;
          } else {
            const errorMsg = err ? "failed to connect to sentinel " + endpointAddress + " because " + err.message : "connected to sentinel " + endpointAddress + " successfully, but got an invalid reply: " + resolved;
            debug(errorMsg);
            eventEmitter("sentinelError", new Error(errorMsg));
            if (err) {
              lastError = err;
            }
            return connectToNext();
          }
        });
        return connectToNext();
      }
      updateSentinels(client) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.options.updateSentinels) {
            return;
          }
          const result = yield client.sentinel("sentinels", this.options.name);
          if (!Array.isArray(result)) {
            return;
          }
          result.map(utils_1.packObject).forEach((sentinel) => {
            const flags = sentinel.flags ? sentinel.flags.split(",") : [];
            if (flags.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
              const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
              if (this.sentinelIterator.add(endpoint)) {
                debug("adding sentinel %s:%s", endpoint.host, endpoint.port);
              }
            }
          });
          debug("Updated internal sentinels: %s", this.sentinelIterator);
        });
      }
      resolveMaster(client) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield client.sentinel("get-master-addr-by-name", this.options.name);
          yield this.updateSentinels(client);
          return this.sentinelNatResolve(Array.isArray(result) ? { host: result[0], port: Number(result[1]) } : null);
        });
      }
      resolveSlave(client) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield client.sentinel("slaves", this.options.name);
          if (!Array.isArray(result)) {
            return null;
          }
          const availableSlaves = result.map(utils_1.packObject).filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
          return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));
        });
      }
      sentinelNatResolve(item) {
        if (!item || !this.options.natMap)
          return item;
        return this.options.natMap[`${item.host}:${item.port}`] || item;
      }
      connectToSentinel(endpoint, options) {
        return new redis_1.default(Object.assign({ port: endpoint.port || 26379, host: endpoint.host, username: this.options.sentinelUsername || null, password: this.options.sentinelPassword || null, family: endpoint.family || (StandaloneConnector_1.isIIpcConnectionOptions(this.options) ? void 0 : this.options.family), tls: this.options.sentinelTLS, retryStrategy: null, enableReadyCheck: false, connectTimeout: this.options.connectTimeout, commandTimeout: this.options.sentinelCommandTimeout, dropBufferSupport: true }, options));
      }
      resolve(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
          const client = this.connectToSentinel(endpoint);
          client.on("error", noop4);
          try {
            if (this.options.role === "slave") {
              return yield this.resolveSlave(client);
            } else {
              return yield this.resolveMaster(client);
            }
          } finally {
            client.disconnect();
          }
        });
      }
      initFailoverDetector() {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.options.failoverDetector) {
            return;
          }
          this.sentinelIterator.reset(true);
          const sentinels = [];
          while (sentinels.length < this.options.sentinelMaxConnections) {
            const { done, value } = this.sentinelIterator.next();
            if (done) {
              break;
            }
            const client = this.connectToSentinel(value, {
              lazyConnect: true,
              retryStrategy: this.options.sentinelReconnectStrategy
            });
            client.on("reconnecting", () => {
              var _a5;
              (_a5 = this.emitter) === null || _a5 === void 0 ? void 0 : _a5.emit("sentinelReconnecting");
            });
            sentinels.push({ address: value, client });
          }
          this.sentinelIterator.reset(false);
          if (this.failoverDetector) {
            this.failoverDetector.cleanup();
          }
          this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
          yield this.failoverDetector.subscribe();
          (_a4 = this.emitter) === null || _a4 === void 0 ? void 0 : _a4.emit("failoverSubscribed");
        });
      }
    };
    exports.default = SentinelConnector;
    function selectPreferredSentinel(availableSlaves, preferredSlaves) {
      if (availableSlaves.length === 0) {
        return null;
      }
      let selectedSlave;
      if (typeof preferredSlaves === "function") {
        selectedSlave = preferredSlaves(availableSlaves);
      } else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
        const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];
        preferredSlavesArray.sort((a, b) => {
          if (!a.prio) {
            a.prio = 1;
          }
          if (!b.prio) {
            b.prio = 1;
          }
          if (a.prio < b.prio) {
            return -1;
          }
          if (a.prio > b.prio) {
            return 1;
          }
          return 0;
        });
        for (let p = 0; p < preferredSlavesArray.length; p++) {
          for (let a = 0; a < availableSlaves.length; a++) {
            const slave = availableSlaves[a];
            if (slave.ip === preferredSlavesArray[p].ip) {
              if (slave.port === preferredSlavesArray[p].port) {
                selectedSlave = slave;
                break;
              }
            }
          }
          if (selectedSlave) {
            break;
          }
        }
      }
      if (!selectedSlave) {
        selectedSlave = utils_1.sample(availableSlaves);
      }
      return addressResponseToAddress(selectedSlave);
    }
    function addressResponseToAddress(input) {
      return { host: input.ip, port: Number(input.port) };
    }
    function noop4() {
    }
  }
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS({
  "node_modules/ioredis/built/connectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StandaloneConnector_1 = require_StandaloneConnector();
    exports.StandaloneConnector = StandaloneConnector_1.default;
    var SentinelConnector_1 = require_SentinelConnector();
    exports.SentinelConnector = SentinelConnector_1.default;
  }
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS({
  "node_modules/ioredis/built/ScanStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var ScanStream = class extends stream_1.Readable {
      constructor(opt) {
        super(opt);
        this.opt = opt;
        this._redisCursor = "0";
        this._redisDrained = false;
      }
      _read() {
        if (this._redisDrained) {
          this.push(null);
          return;
        }
        const args = [this._redisCursor];
        if (this.opt.key) {
          args.unshift(this.opt.key);
        }
        if (this.opt.match) {
          args.push("MATCH", this.opt.match);
        }
        if (this.opt.type) {
          args.push("TYPE", this.opt.type);
        }
        if (this.opt.count) {
          args.push("COUNT", String(this.opt.count));
        }
        this.opt.redis[this.opt.command](args, (err, res) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
          if (this._redisCursor === "0") {
            this._redisDrained = true;
          }
          this.push(res[1]);
        });
      }
      close() {
        this._redisDrained = true;
      }
    };
    exports.default = ScanStream;
  }
});

// node_modules/p-map/index.js
var require_p_map = __commonJS({
  "node_modules/p-map/index.js"(exports, module2) {
    "use strict";
    var pMap = (iterable, mapper, options) => new Promise((resolve2, reject) => {
      options = Object.assign({
        concurrency: Infinity
      }, options);
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      const { concurrency } = options;
      if (!(typeof concurrency === "number" && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const ret = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const i2 = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            resolve2(ret);
          }
          return;
        }
        resolvingCount++;
        Promise.resolve(nextItem.value).then((element) => mapper(element, i2)).then((value) => {
          ret[i2] = value;
          resolvingCount--;
          next();
        }, (error2) => {
          isRejected = true;
          reject(error2);
        });
      };
      for (let i2 = 0; i2 < concurrency; i2++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
    module2.exports = pMap;
    module2.exports.default = pMap;
  }
});

// node_modules/ioredis/built/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/ioredis/built/pipeline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var command_1 = require_command();
    var util_1 = require("util");
    var standard_as_callback_1 = require_built();
    var redis_commands_1 = require_redis_commands();
    var calculateSlot = require_lib();
    var pMap = require_p_map();
    var PromiseContainer = require_promiseContainer();
    var commander_1 = require_commander();
    var utils_1 = require_utils2();
    function generateMultiWithNodes(redis, keys) {
      const slot = calculateSlot(keys[0]);
      const target = redis._groupsBySlot[slot];
      for (let i2 = 1; i2 < keys.length; i2++) {
        if (redis._groupsBySlot[calculateSlot(keys[i2])] !== target) {
          return -1;
        }
      }
      return slot;
    }
    function Pipeline(redis) {
      commander_1.default.call(this);
      this.redis = redis;
      this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
      this.isPipeline = true;
      this.options = redis.options;
      this._queue = [];
      this._result = [];
      this._transactions = 0;
      this._shaToScript = {};
      Object.keys(redis.scriptsSet).forEach((name) => {
        const script = redis.scriptsSet[name];
        this._shaToScript[script.sha] = script;
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      redis.addedBuiltinSet.forEach((name) => {
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      const Promise2 = PromiseContainer.get();
      this.promise = new Promise2((resolve2, reject) => {
        this.resolve = resolve2;
        this.reject = reject;
      });
      const _this = this;
      Object.defineProperty(this, "length", {
        get: function() {
          return _this._queue.length;
        }
      });
    }
    exports.default = Pipeline;
    Object.assign(Pipeline.prototype, commander_1.default.prototype);
    Pipeline.prototype.fillResult = function(value, position) {
      if (this._queue[position].name === "exec" && Array.isArray(value[1])) {
        const execLength = value[1].length;
        for (let i2 = 0; i2 < execLength; i2++) {
          if (value[1][i2] instanceof Error) {
            continue;
          }
          const cmd = this._queue[position - (execLength - i2)];
          try {
            value[1][i2] = cmd.transformReply(value[1][i2]);
          } catch (err) {
            value[1][i2] = err;
          }
        }
      }
      this._result[position] = value;
      if (--this.replyPending) {
        return;
      }
      if (this.isCluster) {
        let retriable = true;
        let commonError;
        for (let i2 = 0; i2 < this._result.length; ++i2) {
          const error2 = this._result[i2][0];
          const command = this._queue[i2];
          if (error2) {
            if (command.name === "exec" && error2.message === "EXECABORT Transaction discarded because of previous errors.") {
              continue;
            }
            if (!commonError) {
              commonError = {
                name: error2.name,
                message: error2.message
              };
            } else if (commonError.name !== error2.name || commonError.message !== error2.message) {
              retriable = false;
              break;
            }
          } else if (!command.inTransaction) {
            const isReadOnly = redis_commands_1.exists(command.name) && redis_commands_1.hasFlag(command.name, "readonly");
            if (!isReadOnly) {
              retriable = false;
              break;
            }
          }
        }
        if (commonError && retriable) {
          const _this = this;
          const errv = commonError.message.split(" ");
          const queue = this._queue;
          let inTransaction = false;
          this._queue = [];
          for (let i2 = 0; i2 < queue.length; ++i2) {
            if (errv[0] === "ASK" && !inTransaction && queue[i2].name !== "asking" && (!queue[i2 - 1] || queue[i2 - 1].name !== "asking")) {
              const asking = new command_1.default("asking");
              asking.ignore = true;
              this.sendCommand(asking);
            }
            queue[i2].initPromise();
            this.sendCommand(queue[i2]);
            inTransaction = queue[i2].inTransaction;
          }
          let matched = true;
          if (typeof this.leftRedirections === "undefined") {
            this.leftRedirections = {};
          }
          const exec2 = function() {
            _this.exec();
          };
          this.redis.handleError(commonError, this.leftRedirections, {
            moved: function(slot, key2) {
              _this.preferKey = key2;
              _this.redis.slots[errv[1]] = [key2];
              _this.redis._groupsBySlot[errv[1]] = _this.redis._groupsIds[_this.redis.slots[errv[1]].join(";")];
              _this.redis.refreshSlotsCache();
              _this.exec();
            },
            ask: function(slot, key2) {
              _this.preferKey = key2;
              _this.exec();
            },
            tryagain: exec2,
            clusterDown: exec2,
            connectionClosed: exec2,
            maxRedirections: () => {
              matched = false;
            },
            defaults: () => {
              matched = false;
            }
          });
          if (matched) {
            return;
          }
        }
      }
      let ignoredCount = 0;
      for (let i2 = 0; i2 < this._queue.length - ignoredCount; ++i2) {
        if (this._queue[i2 + ignoredCount].ignore) {
          ignoredCount += 1;
        }
        this._result[i2] = this._result[i2 + ignoredCount];
      }
      this.resolve(this._result.slice(0, this._result.length - ignoredCount));
    };
    Pipeline.prototype.sendCommand = function(command) {
      if (this._transactions > 0) {
        command.inTransaction = true;
      }
      const position = this._queue.length;
      command.pipelineIndex = position;
      command.promise.then((result) => {
        this.fillResult([null, result], position);
      }).catch((error2) => {
        this.fillResult([error2], position);
      });
      this._queue.push(command);
      return this;
    };
    Pipeline.prototype.addBatch = function(commands) {
      let command, commandName, args;
      for (let i2 = 0; i2 < commands.length; ++i2) {
        command = commands[i2];
        commandName = command[0];
        args = command.slice(1);
        this[commandName].apply(this, args);
      }
      return this;
    };
    var multi = Pipeline.prototype.multi;
    Pipeline.prototype.multi = function() {
      this._transactions += 1;
      return multi.apply(this, arguments);
    };
    var execBuffer = Pipeline.prototype.execBuffer;
    var exec = Pipeline.prototype.exec;
    Pipeline.prototype.execBuffer = util_1.deprecate(function() {
      if (this._transactions > 0) {
        this._transactions -= 1;
      }
      return execBuffer.apply(this, arguments);
    }, "Pipeline#execBuffer: Use Pipeline#exec instead");
    Pipeline.prototype.exec = function(callback) {
      if (this.isCluster && !this.redis.slots.length) {
        if (this.redis.status === "wait")
          this.redis.connect().catch(utils_1.noop);
        this.redis.delayUntilReady((err) => {
          if (err) {
            callback(err);
            return;
          }
          this.exec(callback);
        });
        return this.promise;
      }
      if (this._transactions > 0) {
        this._transactions -= 1;
        return (this.options.dropBufferSupport ? exec : execBuffer).apply(this, arguments);
      }
      if (!this.nodeifiedPromise) {
        this.nodeifiedPromise = true;
        standard_as_callback_1.default(this.promise, callback);
      }
      if (!this._queue.length) {
        this.resolve([]);
      }
      let pipelineSlot;
      if (this.isCluster) {
        const sampleKeys = [];
        for (let i2 = 0; i2 < this._queue.length; i2++) {
          const keys = this._queue[i2].getKeys();
          if (keys.length) {
            sampleKeys.push(keys[0]);
          }
          if (keys.length && calculateSlot.generateMulti(keys) < 0) {
            this.reject(new Error("All the keys in a pipeline command should belong to the same slot"));
            return this.promise;
          }
        }
        if (sampleKeys.length) {
          pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
          if (pipelineSlot < 0) {
            this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group"));
            return this.promise;
          }
        } else {
          pipelineSlot = Math.random() * 16384 | 0;
        }
      }
      const scripts = [];
      for (let i2 = 0; i2 < this._queue.length; ++i2) {
        const item = this._queue[i2];
        if (item.name !== "evalsha") {
          continue;
        }
        const script = this._shaToScript[item.args[0]];
        if (!script || this.redis._addedScriptHashes[script.sha] || scripts.includes(script)) {
          continue;
        }
        scripts.push(script);
      }
      const _this = this;
      if (!scripts.length) {
        return execPipeline();
      }
      if (this.isCluster) {
        pMap(scripts, (script) => _this.redis.script("load", script.lua), {
          concurrency: 10
        }).then(function() {
          for (let i2 = 0; i2 < scripts.length; i2++) {
            _this.redis._addedScriptHashes[scripts[i2].sha] = true;
          }
        }).then(execPipeline, this.reject);
        return this.promise;
      }
      this.redis.script("exists", scripts.map(({ sha }) => sha)).then(function(results) {
        const pending = [];
        for (let i2 = 0; i2 < results.length; ++i2) {
          if (!results[i2]) {
            pending.push(scripts[i2]);
          }
        }
        const Promise2 = PromiseContainer.get();
        return Promise2.all(pending.map(function(script) {
          return _this.redis.script("load", script.lua);
        }));
      }).then(function() {
        for (let i2 = 0; i2 < scripts.length; i2++) {
          _this.redis._addedScriptHashes[scripts[i2].sha] = true;
        }
      }).then(execPipeline, this.reject);
      return this.promise;
      function execPipeline() {
        let data = "";
        let buffers;
        let writePending = _this.replyPending = _this._queue.length;
        let node;
        if (_this.isCluster) {
          node = {
            slot: pipelineSlot,
            redis: _this.redis.connectionPool.nodes.all[_this.preferKey]
          };
        }
        let bufferMode = false;
        const stream = {
          write: function(writable3) {
            if (writable3 instanceof Buffer) {
              bufferMode = true;
            }
            if (bufferMode) {
              if (!buffers) {
                buffers = [];
              }
              if (typeof data === "string") {
                buffers.push(Buffer.from(data, "utf8"));
                data = void 0;
              }
              buffers.push(typeof writable3 === "string" ? Buffer.from(writable3, "utf8") : writable3);
            } else {
              data += writable3;
            }
            if (!--writePending) {
              let sendData;
              if (buffers) {
                sendData = Buffer.concat(buffers);
              } else {
                sendData = data;
              }
              if (_this.isCluster) {
                node.redis.stream.write(sendData);
              } else {
                _this.redis.stream.write(sendData);
              }
              writePending = _this._queue.length;
              data = "";
              buffers = void 0;
              bufferMode = false;
            }
          }
        };
        for (let i2 = 0; i2 < _this._queue.length; ++i2) {
          _this.redis.sendCommand(_this._queue[i2], stream, node);
        }
        return _this.promise;
      }
    };
  }
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS({
  "node_modules/ioredis/built/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var standard_as_callback_1 = require_built();
    var pipeline_1 = require_pipeline();
    function addTransactionSupport(redis) {
      redis.pipeline = function(commands) {
        const pipeline2 = new pipeline_1.default(this);
        if (Array.isArray(commands)) {
          pipeline2.addBatch(commands);
        }
        return pipeline2;
      };
      const { multi } = redis;
      redis.multi = function(commands, options) {
        if (typeof options === "undefined" && !Array.isArray(commands)) {
          options = commands;
          commands = null;
        }
        if (options && options.pipeline === false) {
          return multi.call(this);
        }
        const pipeline2 = new pipeline_1.default(this);
        pipeline2.multi();
        if (Array.isArray(commands)) {
          pipeline2.addBatch(commands);
        }
        const exec2 = pipeline2.exec;
        pipeline2.exec = function(callback) {
          if (this.isCluster && !this.redis.slots.length) {
            if (this.redis.status === "wait")
              this.redis.connect().catch(utils_1.noop);
            return standard_as_callback_1.default(new Promise((resolve2, reject) => {
              this.redis.delayUntilReady((err) => {
                if (err) {
                  reject(err);
                  return;
                }
                this.exec(pipeline2).then(resolve2, reject);
              });
            }), callback);
          }
          if (this._transactions > 0) {
            exec2.call(pipeline2);
          }
          if (this.nodeifiedPromise) {
            return exec2.call(pipeline2);
          }
          const promise = exec2.call(pipeline2);
          return standard_as_callback_1.default(promise.then(function(result) {
            const execResult = result[result.length - 1];
            if (typeof execResult === "undefined") {
              throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");
            }
            if (execResult[0]) {
              execResult[0].previousErrors = [];
              for (let i2 = 0; i2 < result.length - 1; ++i2) {
                if (result[i2][0]) {
                  execResult[0].previousErrors.push(result[i2][0]);
                }
              }
              throw execResult[0];
            }
            return utils_1.wrapMultiResult(execResult[1]);
          }), callback);
        };
        const { execBuffer } = pipeline2;
        pipeline2.execBuffer = function(callback) {
          if (this._transactions > 0) {
            execBuffer.call(pipeline2);
          }
          return pipeline2.exec(callback);
        };
        return pipeline2;
      };
      const { exec } = redis;
      redis.exec = function(callback) {
        return standard_as_callback_1.default(exec.call(this).then(function(results) {
          if (Array.isArray(results)) {
            results = utils_1.wrapMultiResult(results);
          }
          return results;
        }), callback);
      };
    }
    exports.addTransactionSupport = addTransactionSupport;
  }
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS({
  "node_modules/ioredis/built/redis/RedisOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_REDIS_OPTIONS = {
      port: 6379,
      host: "localhost",
      family: 4,
      connectTimeout: 1e4,
      disconnectTimeout: 2e3,
      retryStrategy: function(times) {
        return Math.min(times * 50, 2e3);
      },
      keepAlive: 0,
      noDelay: true,
      connectionName: null,
      sentinels: null,
      name: null,
      role: "master",
      sentinelRetryStrategy: function(times) {
        return Math.min(times * 10, 1e3);
      },
      sentinelReconnectStrategy: function() {
        return 6e4;
      },
      natMap: null,
      enableTLSForSentinelMode: false,
      updateSentinels: true,
      failoverDetector: false,
      username: null,
      password: null,
      db: 0,
      dropBufferSupport: false,
      enableOfflineQueue: true,
      enableReadyCheck: true,
      autoResubscribe: true,
      autoResendUnfulfilledCommands: true,
      lazyConnect: false,
      keyPrefix: "",
      reconnectOnError: null,
      readOnly: false,
      stringNumbers: false,
      maxRetriesPerRequest: 20,
      maxLoadingRetryTime: 1e4,
      enableAutoPipelining: false,
      autoPipeliningIgnoredCommands: [],
      maxScriptsCachingTime: 6e4,
      sentinelMaxConnections: 10
    };
  }
});

// node_modules/ioredis/built/redis/index.js
var require_redis = __commonJS({
  "node_modules/ioredis/built/redis/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lodash_1 = require_lodash4();
    var util_1 = require("util");
    var events_1 = require("events");
    var Deque = require_denque();
    var command_1 = require_command();
    var commander_1 = require_commander();
    var utils_1 = require_utils2();
    var standard_as_callback_1 = require_built();
    var eventHandler = require_event_handler();
    var connectors_1 = require_connectors();
    var ScanStream_1 = require_ScanStream();
    var commands = require_redis_commands();
    var PromiseContainer = require_promiseContainer();
    var transaction_1 = require_transaction();
    var RedisOptions_1 = require_RedisOptions();
    var debug = utils_1.Debug("redis");
    exports.default = Redis;
    function Redis() {
      if (!(this instanceof Redis)) {
        console.error(new Error("Calling `Redis()` like a function is deprecated. Using `new Redis()` instead.").stack.replace("Error", "Warning"));
        return new Redis(arguments[0], arguments[1], arguments[2]);
      }
      this.parseOptions(arguments[0], arguments[1], arguments[2]);
      events_1.EventEmitter.call(this);
      commander_1.default.call(this);
      this.resetCommandQueue();
      this.resetOfflineQueue();
      this.connectionEpoch = 0;
      if (this.options.Connector) {
        this.connector = new this.options.Connector(this.options);
      } else if (this.options.sentinels) {
        const sentinelConnector = new connectors_1.SentinelConnector(this.options);
        sentinelConnector.emitter = this;
        this.connector = sentinelConnector;
      } else {
        this.connector = new connectors_1.StandaloneConnector(this.options);
      }
      this.retryAttempts = 0;
      this._addedScriptHashes = {};
      this._autoPipelines = /* @__PURE__ */ new Map();
      this._runningAutoPipelines = /* @__PURE__ */ new Set();
      Object.defineProperty(this, "autoPipelineQueueSize", {
        get() {
          let queued = 0;
          for (const pipeline2 of this._autoPipelines.values()) {
            queued += pipeline2.length;
          }
          return queued;
        }
      });
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch(lodash_1.noop);
      }
    }
    util_1.inherits(Redis, events_1.EventEmitter);
    Object.assign(Redis.prototype, commander_1.default.prototype);
    Redis.createClient = function(...args) {
      return new Redis(...args);
    };
    Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
    Redis.prototype.resetCommandQueue = function() {
      this.commandQueue = new Deque();
    };
    Redis.prototype.resetOfflineQueue = function() {
      this.offlineQueue = new Deque();
    };
    Redis.prototype.parseOptions = function() {
      this.options = {};
      let isTls = false;
      for (let i2 = 0; i2 < arguments.length; ++i2) {
        const arg = arguments[i2];
        if (arg === null || typeof arg === "undefined") {
          continue;
        }
        if (typeof arg === "object") {
          lodash_1.defaults(this.options, arg);
        } else if (typeof arg === "string") {
          lodash_1.defaults(this.options, utils_1.parseURL(arg));
          if (arg.startsWith("rediss://")) {
            isTls = true;
          }
        } else if (typeof arg === "number") {
          this.options.port = arg;
        } else {
          throw new Error("Invalid argument " + arg);
        }
      }
      if (isTls) {
        lodash_1.defaults(this.options, { tls: true });
      }
      lodash_1.defaults(this.options, Redis.defaultOptions);
      if (typeof this.options.port === "string") {
        this.options.port = parseInt(this.options.port, 10);
      }
      if (typeof this.options.db === "string") {
        this.options.db = parseInt(this.options.db, 10);
      }
      if (this.options.parser === "hiredis") {
        console.warn("Hiredis parser is abandoned since ioredis v3.0, and JavaScript parser will be used");
      }
      this.options = utils_1.resolveTLSProfile(this.options);
    };
    Redis.prototype.setStatus = function(status, arg) {
      if (debug.enabled) {
        debug("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status);
      }
      this.status = status;
      process.nextTick(this.emit.bind(this, status, arg));
    };
    Redis.prototype.clearAddedScriptHashesCleanInterval = function() {
      if (this._addedScriptHashesCleanInterval) {
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = null;
      }
    };
    Redis.prototype.connect = function(callback) {
      const _Promise = PromiseContainer.get();
      const promise = new _Promise((resolve2, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        this.clearAddedScriptHashesCleanInterval();
        this._addedScriptHashes = {};
        this._addedScriptHashesCleanInterval = setInterval(() => {
          this._addedScriptHashes = {};
        }, this.options.maxScriptsCachingTime);
        this.connectionEpoch += 1;
        this.setStatus("connecting");
        const { options } = this;
        this.condition = {
          select: options.db,
          auth: options.username ? [options.username, options.password] : options.password,
          subscriber: false
        };
        const _this = this;
        standard_as_callback_1.default(this.connector.connect(function(type, err) {
          _this.silentEmit(type, err);
        }), function(err, stream) {
          if (err) {
            _this.flushQueue(err);
            _this.silentEmit("error", err);
            reject(err);
            _this.setStatus("end");
            return;
          }
          let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
          if (options.sentinels && !options.enableTLSForSentinelMode) {
            CONNECT_EVENT = "connect";
          }
          _this.stream = stream;
          if (typeof options.keepAlive === "number") {
            stream.setKeepAlive(true, options.keepAlive);
          }
          if (stream.connecting) {
            stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
            if (options.connectTimeout) {
              let connectTimeoutCleared = false;
              stream.setTimeout(options.connectTimeout, function() {
                if (connectTimeoutCleared) {
                  return;
                }
                stream.setTimeout(0);
                stream.destroy();
                const err2 = new Error("connect ETIMEDOUT");
                err2.errorno = "ETIMEDOUT";
                err2.code = "ETIMEDOUT";
                err2.syscall = "connect";
                eventHandler.errorHandler(_this)(err2);
              });
              stream.once(CONNECT_EVENT, function() {
                connectTimeoutCleared = true;
                stream.setTimeout(0);
              });
            }
          } else if (stream.destroyed) {
            const firstError = _this.connector.firstError;
            if (firstError) {
              process.nextTick(() => {
                eventHandler.errorHandler(_this)(firstError);
              });
            }
            process.nextTick(eventHandler.closeHandler(_this));
          } else {
            process.nextTick(eventHandler.connectHandler(_this));
          }
          if (!stream.destroyed) {
            stream.once("error", eventHandler.errorHandler(_this));
            stream.once("close", eventHandler.closeHandler(_this));
          }
          if (options.noDelay) {
            stream.setNoDelay(true);
          }
          const connectionReadyHandler = function() {
            _this.removeListener("close", connectionCloseHandler);
            resolve2();
          };
          var connectionCloseHandler = function() {
            _this.removeListener("ready", connectionReadyHandler);
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
          };
          _this.once("ready", connectionReadyHandler);
          _this.once("close", connectionCloseHandler);
        });
      });
      return standard_as_callback_1.default(promise, callback);
    };
    Redis.prototype.disconnect = function(reconnect) {
      this.clearAddedScriptHashesCleanInterval();
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      if (this.status === "wait") {
        eventHandler.closeHandler(this)();
      } else {
        this.connector.disconnect();
      }
    };
    Redis.prototype.end = function() {
      this.disconnect();
    };
    Redis.prototype.duplicate = function(override) {
      return new Redis(Object.assign({}, this.options, override || {}));
    };
    Redis.prototype.recoverFromFatalError = function(commandError, err, options) {
      this.flushQueue(err, options);
      this.silentEmit("error", err);
      this.disconnect(true);
    };
    Redis.prototype.handleReconnection = function handleReconnection(err, item) {
      let needReconnect = false;
      if (this.options.reconnectOnError) {
        needReconnect = this.options.reconnectOnError(err);
      }
      switch (needReconnect) {
        case 1:
        case true:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          item.command.reject(err);
          break;
        case 2:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          if (this.condition.select !== item.select && item.command.name !== "select") {
            this.select(item.select);
          }
          this.sendCommand(item.command);
          break;
        default:
          item.command.reject(err);
      }
    };
    Redis.prototype.flushQueue = function(error2, options) {
      options = lodash_1.defaults({}, options, {
        offlineQueue: true,
        commandQueue: true
      });
      let item;
      if (options.offlineQueue) {
        while (this.offlineQueue.length > 0) {
          item = this.offlineQueue.shift();
          item.command.reject(error2);
        }
      }
      if (options.commandQueue) {
        if (this.commandQueue.length > 0) {
          if (this.stream) {
            this.stream.removeAllListeners("data");
          }
          while (this.commandQueue.length > 0) {
            item = this.commandQueue.shift();
            item.command.reject(error2);
          }
        }
      }
    };
    Redis.prototype._readyCheck = function(callback) {
      const _this = this;
      this.info(function(err, res) {
        if (err) {
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback(null, res);
        }
        const info = {};
        const lines = res.split("\r\n");
        for (let i2 = 0; i2 < lines.length; ++i2) {
          const [fieldName, ...fieldValueParts] = lines[i2].split(":");
          const fieldValue = fieldValueParts.join(":");
          if (fieldValue) {
            info[fieldName] = fieldValue;
          }
        }
        if (!info.loading || info.loading === "0") {
          callback(null, info);
        } else {
          const loadingEtaMs = (info.loading_eta_seconds || 1) * 1e3;
          const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;
          debug("Redis server still loading, trying again in " + retryTime + "ms");
          setTimeout(function() {
            _this._readyCheck(callback);
          }, retryTime);
        }
      });
    };
    Redis.prototype.silentEmit = function(eventName) {
      let error2;
      if (eventName === "error") {
        error2 = arguments[1];
        if (this.status === "end") {
          return;
        }
        if (this.manuallyClosing) {
          if (error2 instanceof Error && (error2.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || error2.syscall === "connect" || error2.syscall === "read")) {
            return;
          }
        }
      }
      if (this.listeners(eventName).length > 0) {
        return this.emit.apply(this, arguments);
      }
      if (error2 && error2 instanceof Error) {
        console.error("[ioredis] Unhandled error event:", error2.stack);
      }
      return false;
    };
    Redis.prototype.monitor = function(callback) {
      const monitorInstance = this.duplicate({
        monitor: true,
        lazyConnect: false
      });
      const Promise2 = PromiseContainer.get();
      return standard_as_callback_1.default(new Promise2(function(resolve2) {
        monitorInstance.once("monitoring", function() {
          resolve2(monitorInstance);
        });
      }), callback);
    };
    transaction_1.addTransactionSupport(Redis.prototype);
    Redis.prototype.sendCommand = function(command, stream) {
      if (this.status === "wait") {
        this.connect().catch(lodash_1.noop);
      }
      if (this.status === "end") {
        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
      }
      if (this.condition.subscriber && !command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command.name)) {
        command.reject(new Error("Connection in subscriber mode, only subscriber commands may be used"));
        return command.promise;
      }
      if (typeof this.options.commandTimeout === "number") {
        command.setTimeout(this.options.commandTimeout);
      }
      if (command.name === "quit") {
        this.clearAddedScriptHashesCleanInterval();
      }
      let writable3 = this.status === "ready" || !stream && this.status === "connect" && commands.exists(command.name) && commands.hasFlag(command.name, "loading");
      if (!this.stream) {
        writable3 = false;
      } else if (!this.stream.writable) {
        writable3 = false;
      } else if (this.stream._writableState && this.stream._writableState.ended) {
        writable3 = false;
      }
      if (!writable3 && !this.options.enableOfflineQueue) {
        command.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false"));
        return command.promise;
      }
      if (!writable3 && command.name === "quit" && this.offlineQueue.length === 0) {
        this.disconnect();
        command.resolve(Buffer.from("OK"));
        return command.promise;
      }
      if (writable3) {
        if (debug.enabled) {
          debug("write command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
        }
        (stream || this.stream).write(command.toWritable());
        this.commandQueue.push({
          command,
          stream,
          select: this.condition.select
        });
        if (command_1.default.checkFlag("WILL_DISCONNECT", command.name)) {
          this.manuallyClosing = true;
        }
      } else if (this.options.enableOfflineQueue) {
        if (debug.enabled) {
          debug("queue command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
        }
        this.offlineQueue.push({
          command,
          stream,
          select: this.condition.select
        });
      }
      if (command.name === "select" && utils_1.isInt(command.args[0])) {
        const db = parseInt(command.args[0], 10);
        if (this.condition.select !== db) {
          this.condition.select = db;
          this.emit("select", db);
          debug("switch to db [%d]", this.condition.select);
        }
      }
      return command.promise;
    };
    Redis.prototype._getDescription = function() {
      let description;
      if (this.options.path) {
        description = this.options.path;
      } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
        description = this.stream.remoteAddress + ":" + this.stream.remotePort;
      } else {
        description = this.options.host + ":" + this.options.port;
      }
      if (this.options.connectionName) {
        description += ` (${this.options.connectionName})`;
      }
      return description;
    };
    [
      "scan",
      "sscan",
      "hscan",
      "zscan",
      "scanBuffer",
      "sscanBuffer",
      "hscanBuffer",
      "zscanBuffer"
    ].forEach(function(command) {
      Redis.prototype[command + "Stream"] = function(key2, options) {
        if (command === "scan" || command === "scanBuffer") {
          options = key2;
          key2 = null;
        }
        return new ScanStream_1.default(lodash_1.defaults({
          objectMode: true,
          key: key2,
          redis: this,
          command
        }, options));
      };
    });
  }
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS({
  "node_modules/ioredis/built/errors/ClusterAllFailedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var redis_errors_1 = require_redis_errors();
    var ClusterAllFailedError = class extends redis_errors_1.RedisError {
      constructor(message, lastNodeError) {
        super(message);
        this.lastNodeError = lastNodeError;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
    };
    exports.default = ClusterAllFailedError;
  }
});

// node_modules/ioredis/built/cluster/util.js
var require_util = __commonJS({
  "node_modules/ioredis/built/cluster/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var net_1 = require("net");
    function getNodeKey(node) {
      node.port = node.port || 6379;
      node.host = node.host || "127.0.0.1";
      return node.host + ":" + node.port;
    }
    exports.getNodeKey = getNodeKey;
    function nodeKeyToRedisOptions(nodeKey) {
      const portIndex = nodeKey.lastIndexOf(":");
      if (portIndex === -1) {
        throw new Error(`Invalid node key ${nodeKey}`);
      }
      return {
        host: nodeKey.slice(0, portIndex),
        port: Number(nodeKey.slice(portIndex + 1))
      };
    }
    exports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
    function normalizeNodeOptions(nodes) {
      return nodes.map((node) => {
        const options = {};
        if (typeof node === "object") {
          Object.assign(options, node);
        } else if (typeof node === "string") {
          Object.assign(options, utils_1.parseURL(node));
        } else if (typeof node === "number") {
          options.port = node;
        } else {
          throw new Error("Invalid argument " + node);
        }
        if (typeof options.port === "string") {
          options.port = parseInt(options.port, 10);
        }
        delete options.db;
        if (!options.port) {
          options.port = 6379;
        }
        if (!options.host) {
          options.host = "127.0.0.1";
        }
        return utils_1.resolveTLSProfile(options);
      });
    }
    exports.normalizeNodeOptions = normalizeNodeOptions;
    function getUniqueHostnamesFromOptions(nodes) {
      const uniqueHostsMap = {};
      nodes.forEach((node) => {
        uniqueHostsMap[node.host] = true;
      });
      return Object.keys(uniqueHostsMap).filter((host) => !net_1.isIP(host));
    }
    exports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
    function groupSrvRecords(records) {
      const recordsByPriority = {};
      for (const record of records) {
        if (!recordsByPriority.hasOwnProperty(record.priority)) {
          recordsByPriority[record.priority] = {
            totalWeight: record.weight,
            records: [record]
          };
        } else {
          recordsByPriority[record.priority].totalWeight += record.weight;
          recordsByPriority[record.priority].records.push(record);
        }
      }
      return recordsByPriority;
    }
    exports.groupSrvRecords = groupSrvRecords;
    function weightSrvRecords(recordsGroup) {
      if (recordsGroup.records.length === 1) {
        recordsGroup.totalWeight = 0;
        return recordsGroup.records.shift();
      }
      const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));
      let total = 0;
      for (const [i2, record] of recordsGroup.records.entries()) {
        total += 1 + record.weight;
        if (total > random) {
          recordsGroup.totalWeight -= record.weight;
          recordsGroup.records.splice(i2, 1);
          return record;
        }
      }
    }
    exports.weightSrvRecords = weightSrvRecords;
    function getConnectionName(component, nodeConnectionName) {
      const prefix = `ioredis-cluster(${component})`;
      return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
    }
    exports.getConnectionName = getConnectionName;
  }
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS({
  "node_modules/ioredis/built/cluster/ConnectionPool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var utils_1 = require_utils2();
    var util_1 = require_util();
    var redis_1 = require_redis();
    var debug = utils_1.Debug("cluster:connectionPool");
    var ConnectionPool = class extends events_1.EventEmitter {
      constructor(redisOptions) {
        super();
        this.redisOptions = redisOptions;
        this.nodes = {
          all: {},
          master: {},
          slave: {}
        };
        this.specifiedOptions = {};
      }
      getNodes(role = "all") {
        const nodes = this.nodes[role];
        return Object.keys(nodes).map((key2) => nodes[key2]);
      }
      getInstanceByKey(key2) {
        return this.nodes.all[key2];
      }
      getSampleInstance(role) {
        const keys = Object.keys(this.nodes[role]);
        const sampleKey = utils_1.sample(keys);
        return this.nodes[role][sampleKey];
      }
      findOrCreate(node, readOnly = false) {
        const key2 = util_1.getNodeKey(node);
        readOnly = Boolean(readOnly);
        if (this.specifiedOptions[key2]) {
          Object.assign(node, this.specifiedOptions[key2]);
        } else {
          this.specifiedOptions[key2] = node;
        }
        let redis;
        if (this.nodes.all[key2]) {
          redis = this.nodes.all[key2];
          if (redis.options.readOnly !== readOnly) {
            redis.options.readOnly = readOnly;
            debug("Change role of %s to %s", key2, readOnly ? "slave" : "master");
            redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
            if (readOnly) {
              delete this.nodes.master[key2];
              this.nodes.slave[key2] = redis;
            } else {
              delete this.nodes.slave[key2];
              this.nodes.master[key2] = redis;
            }
          }
        } else {
          debug("Connecting to %s as %s", key2, readOnly ? "slave" : "master");
          redis = new redis_1.default(utils_1.defaults({
            retryStrategy: null,
            enableOfflineQueue: true,
            readOnly
          }, node, this.redisOptions, { lazyConnect: true }));
          this.nodes.all[key2] = redis;
          this.nodes[readOnly ? "slave" : "master"][key2] = redis;
          redis.once("end", () => {
            this.removeNode(key2);
            this.emit("-node", redis, key2);
            if (!Object.keys(this.nodes.all).length) {
              this.emit("drain");
            }
          });
          this.emit("+node", redis, key2);
          redis.on("error", function(error2) {
            this.emit("nodeError", error2, key2);
          });
        }
        return redis;
      }
      removeNode(key2) {
        const { nodes } = this;
        if (nodes.all[key2]) {
          debug("Remove %s from the pool", key2);
          delete nodes.all[key2];
        }
        delete nodes.master[key2];
        delete nodes.slave[key2];
      }
      reset(nodes) {
        debug("Reset with %O", nodes);
        const newNodes = {};
        nodes.forEach((node) => {
          const key2 = util_1.getNodeKey(node);
          if (!(node.readOnly && newNodes[key2])) {
            newNodes[key2] = node;
          }
        });
        Object.keys(this.nodes.all).forEach((key2) => {
          if (!newNodes[key2]) {
            debug("Disconnect %s because the node does not hold any slot", key2);
            this.nodes.all[key2].disconnect();
            this.removeNode(key2);
          }
        });
        Object.keys(newNodes).forEach((key2) => {
          const node = newNodes[key2];
          this.findOrCreate(node, node.readOnly);
        });
      }
    };
    exports.default = ConnectionPool;
  }
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS({
  "node_modules/ioredis/built/cluster/ClusterSubscriber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var utils_1 = require_utils2();
    var redis_1 = require_redis();
    var debug = utils_1.Debug("cluster:subscriber");
    var ClusterSubscriber = class {
      constructor(connectionPool, emitter) {
        this.connectionPool = connectionPool;
        this.emitter = emitter;
        this.started = false;
        this.subscriber = null;
        this.connectionPool.on("-node", (_, key2) => {
          if (!this.started || !this.subscriber) {
            return;
          }
          if (util_1.getNodeKey(this.subscriber.options) === key2) {
            debug("subscriber has left, selecting a new one...");
            this.selectSubscriber();
          }
        });
        this.connectionPool.on("+node", () => {
          if (!this.started || this.subscriber) {
            return;
          }
          debug("a new node is discovered and there is no subscriber, selecting a new one...");
          this.selectSubscriber();
        });
      }
      getInstance() {
        return this.subscriber;
      }
      selectSubscriber() {
        const lastActiveSubscriber = this.lastActiveSubscriber;
        if (lastActiveSubscriber) {
          lastActiveSubscriber.disconnect();
        }
        if (this.subscriber) {
          this.subscriber.disconnect();
        }
        const sampleNode = utils_1.sample(this.connectionPool.getNodes());
        if (!sampleNode) {
          debug("selecting subscriber failed since there is no node discovered in the cluster yet");
          this.subscriber = null;
          return;
        }
        const { options } = sampleNode;
        debug("selected a subscriber %s:%s", options.host, options.port);
        this.subscriber = new redis_1.default({
          port: options.port,
          host: options.host,
          username: options.username,
          password: options.password,
          enableReadyCheck: true,
          connectionName: util_1.getConnectionName("subscriber", options.connectionName),
          lazyConnect: true,
          tls: options.tls
        });
        this.subscriber.on("error", utils_1.noop);
        const previousChannels = { subscribe: [], psubscribe: [] };
        if (lastActiveSubscriber) {
          const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
          if (condition && condition.subscriber) {
            previousChannels.subscribe = condition.subscriber.channels("subscribe");
            previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
          }
        }
        if (previousChannels.subscribe.length || previousChannels.psubscribe.length) {
          let pending = 0;
          for (const type of ["subscribe", "psubscribe"]) {
            const channels = previousChannels[type];
            if (channels.length) {
              pending += 1;
              debug("%s %d channels", type, channels.length);
              this.subscriber[type](channels).then(() => {
                if (!--pending) {
                  this.lastActiveSubscriber = this.subscriber;
                }
              }).catch(() => {
                debug("failed to %s %d channels", type, channels.length);
              });
            }
          }
        } else {
          this.lastActiveSubscriber = this.subscriber;
        }
        for (const event of ["message", "messageBuffer"]) {
          this.subscriber.on(event, (arg1, arg2) => {
            this.emitter.emit(event, arg1, arg2);
          });
        }
        for (const event of ["pmessage", "pmessageBuffer"]) {
          this.subscriber.on(event, (arg1, arg2, arg3) => {
            this.emitter.emit(event, arg1, arg2, arg3);
          });
        }
      }
      start() {
        this.started = true;
        this.selectSubscriber();
        debug("started");
      }
      stop() {
        this.started = false;
        if (this.subscriber) {
          this.subscriber.disconnect();
          this.subscriber = null;
        }
        debug("stopped");
      }
    };
    exports.default = ClusterSubscriber;
  }
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS({
  "node_modules/ioredis/built/cluster/DelayQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var Deque = require_denque();
    var debug = utils_1.Debug("delayqueue");
    var DelayQueue = class {
      constructor() {
        this.queues = {};
        this.timeouts = {};
      }
      push(bucket, item, options) {
        const callback = options.callback || process.nextTick;
        if (!this.queues[bucket]) {
          this.queues[bucket] = new Deque();
        }
        const queue = this.queues[bucket];
        queue.push(item);
        if (!this.timeouts[bucket]) {
          this.timeouts[bucket] = setTimeout(() => {
            callback(() => {
              this.timeouts[bucket] = null;
              this.execute(bucket);
            });
          }, options.timeout);
        }
      }
      execute(bucket) {
        const queue = this.queues[bucket];
        if (!queue) {
          return;
        }
        const { length } = queue;
        if (!length) {
          return;
        }
        debug("send %d commands in %s queue", length, bucket);
        this.queues[bucket] = null;
        while (queue.length > 0) {
          queue.shift()();
        }
      }
    };
    exports.default = DelayQueue;
  }
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS({
  "node_modules/ioredis/built/cluster/ClusterOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dns_1 = require("dns");
    exports.DEFAULT_CLUSTER_OPTIONS = {
      clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2e3),
      enableOfflineQueue: true,
      enableReadyCheck: true,
      scaleReads: "master",
      maxRedirections: 16,
      retryDelayOnMoved: 0,
      retryDelayOnFailover: 100,
      retryDelayOnClusterDown: 100,
      retryDelayOnTryAgain: 100,
      slotsRefreshTimeout: 1e3,
      slotsRefreshInterval: 5e3,
      useSRVRecords: false,
      resolveSrv: dns_1.resolveSrv,
      dnsLookup: dns_1.lookup,
      enableAutoPipelining: false,
      autoPipeliningIgnoredCommands: [],
      maxScriptsCachingTime: 6e4
    };
  }
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS({
  "node_modules/ioredis/built/cluster/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var ClusterAllFailedError_1 = require_ClusterAllFailedError();
    var utils_1 = require_utils2();
    var ConnectionPool_1 = require_ConnectionPool();
    var util_1 = require_util();
    var ClusterSubscriber_1 = require_ClusterSubscriber();
    var DelayQueue_1 = require_DelayQueue();
    var ScanStream_1 = require_ScanStream();
    var redis_errors_1 = require_redis_errors();
    var standard_as_callback_1 = require_built();
    var PromiseContainer = require_promiseContainer();
    var ClusterOptions_1 = require_ClusterOptions();
    var utils_2 = require_utils2();
    var commands = require_redis_commands();
    var command_1 = require_command();
    var redis_1 = require_redis();
    var commander_1 = require_commander();
    var Deque = require_denque();
    var debug = utils_1.Debug("cluster");
    var Cluster = class extends events_1.EventEmitter {
      constructor(startupNodes, options = {}) {
        super();
        this.slots = [];
        this.retryAttempts = 0;
        this.delayQueue = new DelayQueue_1.default();
        this.offlineQueue = new Deque();
        this.isRefreshing = false;
        this.isCluster = true;
        this._autoPipelines = /* @__PURE__ */ new Map();
        this._groupsIds = {};
        this._groupsBySlot = Array(16384);
        this._runningAutoPipelines = /* @__PURE__ */ new Set();
        this._readyDelayedCallbacks = [];
        this._addedScriptHashes = {};
        this.connectionEpoch = 0;
        commander_1.default.call(this);
        this.startupNodes = startupNodes;
        this.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
        if (typeof this.options.scaleReads !== "function" && ["all", "master", "slave"].indexOf(this.options.scaleReads) === -1) {
          throw new Error('Invalid option scaleReads "' + this.options.scaleReads + '". Expected "all", "master", "slave" or a custom function');
        }
        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
        this.connectionPool.on("-node", (redis, key2) => {
          this.emit("-node", redis);
        });
        this.connectionPool.on("+node", (redis) => {
          this.emit("+node", redis);
        });
        this.connectionPool.on("drain", () => {
          this.setStatus("close");
        });
        this.connectionPool.on("nodeError", (error2, key2) => {
          this.emit("node error", error2, key2);
        });
        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
        if (this.options.lazyConnect) {
          this.setStatus("wait");
        } else {
          this.connect().catch((err) => {
            debug("connecting failed: %s", err);
          });
        }
      }
      resetOfflineQueue() {
        this.offlineQueue = new Deque();
      }
      clearNodesRefreshInterval() {
        if (this.slotsTimer) {
          clearTimeout(this.slotsTimer);
          this.slotsTimer = null;
        }
      }
      clearAddedScriptHashesCleanInterval() {
        if (this._addedScriptHashesCleanInterval) {
          clearInterval(this._addedScriptHashesCleanInterval);
          this._addedScriptHashesCleanInterval = null;
        }
      }
      resetNodesRefreshInterval() {
        if (this.slotsTimer) {
          return;
        }
        const nextRound = () => {
          this.slotsTimer = setTimeout(() => {
            debug('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
            this.refreshSlotsCache(() => {
              nextRound();
            });
          }, this.options.slotsRefreshInterval);
        };
        nextRound();
      }
      connect() {
        const Promise2 = PromiseContainer.get();
        return new Promise2((resolve2, reject) => {
          if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
            reject(new Error("Redis is already connecting/connected"));
            return;
          }
          this.clearAddedScriptHashesCleanInterval();
          this._addedScriptHashesCleanInterval = setInterval(() => {
            this._addedScriptHashes = {};
          }, this.options.maxScriptsCachingTime);
          const epoch = ++this.connectionEpoch;
          this.setStatus("connecting");
          this.resolveStartupNodeHostnames().then((nodes) => {
            if (this.connectionEpoch !== epoch) {
              debug("discard connecting after resolving startup nodes because epoch not match: %d != %d", epoch, this.connectionEpoch);
              reject(new redis_errors_1.RedisError("Connection is discarded because a new connection is made"));
              return;
            }
            if (this.status !== "connecting") {
              debug("discard connecting after resolving startup nodes because the status changed to %s", this.status);
              reject(new redis_errors_1.RedisError("Connection is aborted"));
              return;
            }
            this.connectionPool.reset(nodes);
            function readyHandler() {
              this.setStatus("ready");
              this.retryAttempts = 0;
              this.executeOfflineCommands();
              this.resetNodesRefreshInterval();
              resolve2();
            }
            let closeListener = void 0;
            const refreshListener = () => {
              this.invokeReadyDelayedCallbacks(void 0);
              this.removeListener("close", closeListener);
              this.manuallyClosing = false;
              this.setStatus("connect");
              if (this.options.enableReadyCheck) {
                this.readyCheck((err, fail) => {
                  if (err || fail) {
                    debug("Ready check failed (%s). Reconnecting...", err || fail);
                    if (this.status === "connect") {
                      this.disconnect(true);
                    }
                  } else {
                    readyHandler.call(this);
                  }
                });
              } else {
                readyHandler.call(this);
              }
            };
            closeListener = function() {
              const error2 = new Error("None of startup nodes is available");
              this.removeListener("refresh", refreshListener);
              this.invokeReadyDelayedCallbacks(error2);
              reject(error2);
            };
            this.once("refresh", refreshListener);
            this.once("close", closeListener);
            this.once("close", this.handleCloseEvent.bind(this));
            this.refreshSlotsCache(function(err) {
              if (err && err.message === "Failed to refresh slots cache.") {
                redis_1.default.prototype.silentEmit.call(this, "error", err);
                this.connectionPool.reset([]);
              }
            }.bind(this));
            this.subscriber.start();
          }).catch((err) => {
            this.setStatus("close");
            this.handleCloseEvent(err);
            this.invokeReadyDelayedCallbacks(err);
            reject(err);
          });
        });
      }
      handleCloseEvent(reason) {
        if (reason) {
          debug("closed because %s", reason);
        }
        this.clearAddedScriptHashesCleanInterval();
        let retryDelay;
        if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
          retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
        }
        if (typeof retryDelay === "number") {
          this.setStatus("reconnecting");
          this.reconnectTimeout = setTimeout(function() {
            this.reconnectTimeout = null;
            debug("Cluster is disconnected. Retrying after %dms", retryDelay);
            this.connect().catch(function(err) {
              debug("Got error %s when reconnecting. Ignoring...", err);
            });
          }.bind(this), retryDelay);
        } else {
          this.setStatus("end");
          this.flushQueue(new Error("None of startup nodes is available"));
        }
      }
      disconnect(reconnect = false) {
        const status = this.status;
        this.setStatus("disconnecting");
        this.clearAddedScriptHashesCleanInterval();
        if (!reconnect) {
          this.manuallyClosing = true;
        }
        if (this.reconnectTimeout && !reconnect) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
          debug("Canceled reconnecting attempts");
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        if (status === "wait") {
          this.setStatus("close");
          this.handleCloseEvent();
        } else {
          this.connectionPool.reset([]);
        }
      }
      quit(callback) {
        const status = this.status;
        this.setStatus("disconnecting");
        this.clearAddedScriptHashesCleanInterval();
        this.manuallyClosing = true;
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        const Promise2 = PromiseContainer.get();
        if (status === "wait") {
          const ret = standard_as_callback_1.default(Promise2.resolve("OK"), callback);
          setImmediate(function() {
            this.setStatus("close");
            this.handleCloseEvent();
          }.bind(this));
          return ret;
        }
        return standard_as_callback_1.default(Promise2.all(this.nodes().map((node) => node.quit().catch((err) => {
          if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {
            return "OK";
          }
          throw err;
        }))).then(() => "OK"), callback);
      }
      duplicate(overrideStartupNodes = [], overrideOptions = {}) {
        const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
        const options = Object.assign({}, this.options, overrideOptions);
        return new Cluster(startupNodes, options);
      }
      nodes(role = "all") {
        if (role !== "all" && role !== "master" && role !== "slave") {
          throw new Error('Invalid role "' + role + '". Expected "all", "master" or "slave"');
        }
        return this.connectionPool.getNodes(role);
      }
      delayUntilReady(callback) {
        this._readyDelayedCallbacks.push(callback);
      }
      get autoPipelineQueueSize() {
        let queued = 0;
        for (const pipeline2 of this._autoPipelines.values()) {
          queued += pipeline2.length;
        }
        return queued;
      }
      setStatus(status) {
        debug("status: %s -> %s", this.status || "[empty]", status);
        this.status = status;
        process.nextTick(() => {
          this.emit(status);
        });
      }
      refreshSlotsCache(callback) {
        if (this.isRefreshing) {
          if (typeof callback === "function") {
            process.nextTick(callback);
          }
          return;
        }
        this.isRefreshing = true;
        const _this = this;
        const wrapper = function(error2) {
          _this.isRefreshing = false;
          if (typeof callback === "function") {
            callback(error2);
          }
        };
        const nodes = utils_2.shuffle(this.connectionPool.getNodes());
        let lastNodeError = null;
        function tryNode(index) {
          if (index === nodes.length) {
            const error2 = new ClusterAllFailedError_1.default("Failed to refresh slots cache.", lastNodeError);
            return wrapper(error2);
          }
          const node = nodes[index];
          const key2 = `${node.options.host}:${node.options.port}`;
          debug("getting slot cache from %s", key2);
          _this.getInfoFromNode(node, function(err) {
            switch (_this.status) {
              case "close":
              case "end":
                return wrapper(new Error("Cluster is disconnected."));
              case "disconnecting":
                return wrapper(new Error("Cluster is disconnecting."));
            }
            if (err) {
              _this.emit("node error", err, key2);
              lastNodeError = err;
              tryNode(index + 1);
            } else {
              _this.emit("refresh");
              wrapper();
            }
          });
        }
        tryNode(0);
      }
      flushQueue(error2) {
        let item;
        while (this.offlineQueue.length > 0) {
          item = this.offlineQueue.shift();
          item.command.reject(error2);
        }
      }
      executeOfflineCommands() {
        if (this.offlineQueue.length) {
          debug("send %d commands in offline queue", this.offlineQueue.length);
          const offlineQueue = this.offlineQueue;
          this.resetOfflineQueue();
          while (offlineQueue.length > 0) {
            const item = offlineQueue.shift();
            this.sendCommand(item.command, item.stream, item.node);
          }
        }
      }
      natMapper(nodeKey) {
        if (this.options.natMap && typeof this.options.natMap === "object") {
          const key2 = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
          const mapped = this.options.natMap[key2];
          if (mapped) {
            debug("NAT mapping %s -> %O", key2, mapped);
            return Object.assign({}, mapped);
          }
        }
        return typeof nodeKey === "string" ? util_1.nodeKeyToRedisOptions(nodeKey) : nodeKey;
      }
      sendCommand(command, stream, node) {
        if (this.status === "wait") {
          this.connect().catch(utils_1.noop);
        }
        if (this.status === "end") {
          command.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));
          return command.promise;
        }
        let to = this.options.scaleReads;
        if (to !== "master") {
          const isCommandReadOnly = command.isReadOnly || commands.exists(command.name) && commands.hasFlag(command.name, "readonly");
          if (!isCommandReadOnly) {
            to = "master";
          }
        }
        let targetSlot = node ? node.slot : command.getSlot();
        const ttl = {};
        const _this = this;
        if (!node && !command.__is_reject_overwritten) {
          command.__is_reject_overwritten = true;
          const reject = command.reject;
          command.reject = function(err) {
            const partialTry = tryConnection.bind(null, true);
            _this.handleError(err, ttl, {
              moved: function(slot, key2) {
                debug("command %s is moved to %s", command.name, key2);
                targetSlot = Number(slot);
                if (_this.slots[slot]) {
                  _this.slots[slot][0] = key2;
                } else {
                  _this.slots[slot] = [key2];
                }
                _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(";")];
                _this.connectionPool.findOrCreate(_this.natMapper(key2));
                tryConnection();
                debug("refreshing slot caches... (triggered by MOVED error)");
                _this.refreshSlotsCache();
              },
              ask: function(slot, key2) {
                debug("command %s is required to ask %s:%s", command.name, key2);
                const mapped = _this.natMapper(key2);
                _this.connectionPool.findOrCreate(mapped);
                tryConnection(false, `${mapped.host}:${mapped.port}`);
              },
              tryagain: partialTry,
              clusterDown: partialTry,
              connectionClosed: partialTry,
              maxRedirections: function(redirectionError) {
                reject.call(command, redirectionError);
              },
              defaults: function() {
                reject.call(command, err);
              }
            });
          };
        }
        tryConnection();
        function tryConnection(random, asking) {
          if (_this.status === "end") {
            command.reject(new redis_errors_1.AbortError("Cluster is ended."));
            return;
          }
          let redis;
          if (_this.status === "ready" || command.name === "cluster") {
            if (node && node.redis) {
              redis = node.redis;
            } else if (command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command.name) || command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command.name)) {
              redis = _this.subscriber.getInstance();
              if (!redis) {
                command.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
                return;
              }
            } else {
              if (!random) {
                if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
                  const nodeKeys = _this.slots[targetSlot];
                  if (typeof to === "function") {
                    const nodes = nodeKeys.map(function(key2) {
                      return _this.connectionPool.getInstanceByKey(key2);
                    });
                    redis = to(nodes, command);
                    if (Array.isArray(redis)) {
                      redis = utils_2.sample(redis);
                    }
                    if (!redis) {
                      redis = nodes[0];
                    }
                  } else {
                    let key2;
                    if (to === "all") {
                      key2 = utils_2.sample(nodeKeys);
                    } else if (to === "slave" && nodeKeys.length > 1) {
                      key2 = utils_2.sample(nodeKeys, 1);
                    } else {
                      key2 = nodeKeys[0];
                    }
                    redis = _this.connectionPool.getInstanceByKey(key2);
                  }
                }
                if (asking) {
                  redis = _this.connectionPool.getInstanceByKey(asking);
                  redis.asking();
                }
              }
              if (!redis) {
                redis = (typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance("all");
              }
            }
            if (node && !node.redis) {
              node.redis = redis;
            }
          }
          if (redis) {
            redis.sendCommand(command, stream);
          } else if (_this.options.enableOfflineQueue) {
            _this.offlineQueue.push({
              command,
              stream,
              node
            });
          } else {
            command.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
          }
        }
        return command.promise;
      }
      handleError(error2, ttl, handlers) {
        if (typeof ttl.value === "undefined") {
          ttl.value = this.options.maxRedirections;
        } else {
          ttl.value -= 1;
        }
        if (ttl.value <= 0) {
          handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error2));
          return;
        }
        const errv = error2.message.split(" ");
        if (errv[0] === "MOVED") {
          const timeout = this.options.retryDelayOnMoved;
          if (timeout && typeof timeout === "number") {
            this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), { timeout });
          } else {
            handlers.moved(errv[1], errv[2]);
          }
        } else if (errv[0] === "ASK") {
          handlers.ask(errv[1], errv[2]);
        } else if (errv[0] === "TRYAGAIN") {
          this.delayQueue.push("tryagain", handlers.tryagain, {
            timeout: this.options.retryDelayOnTryAgain
          });
        } else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
          this.delayQueue.push("clusterdown", handlers.connectionClosed, {
            timeout: this.options.retryDelayOnClusterDown,
            callback: this.refreshSlotsCache.bind(this)
          });
        } else if (error2.message === utils_2.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === "ready") {
          this.delayQueue.push("failover", handlers.connectionClosed, {
            timeout: this.options.retryDelayOnFailover,
            callback: this.refreshSlotsCache.bind(this)
          });
        } else {
          handlers.defaults();
        }
      }
      getInfoFromNode(redis, callback) {
        if (!redis) {
          return callback(new Error("Node is disconnected"));
        }
        const duplicatedConnection = redis.duplicate({
          enableOfflineQueue: true,
          enableReadyCheck: false,
          retryStrategy: null,
          connectionName: util_1.getConnectionName("refresher", this.options.redisOptions && this.options.redisOptions.connectionName)
        });
        duplicatedConnection.on("error", utils_1.noop);
        duplicatedConnection.cluster("slots", utils_2.timeout((err, result) => {
          duplicatedConnection.disconnect();
          if (err) {
            return callback(err);
          }
          if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
            debug("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s", result.length, this.status);
            callback();
            return;
          }
          const nodes = [];
          debug("cluster slots result count: %d", result.length);
          for (let i2 = 0; i2 < result.length; ++i2) {
            const items = result[i2];
            const slotRangeStart = items[0];
            const slotRangeEnd = items[1];
            const keys = [];
            for (let j2 = 2; j2 < items.length; j2++) {
              if (!items[j2][0]) {
                continue;
              }
              items[j2] = this.natMapper({ host: items[j2][0], port: items[j2][1] });
              items[j2].readOnly = j2 !== 2;
              nodes.push(items[j2]);
              keys.push(items[j2].host + ":" + items[j2].port);
            }
            debug("cluster slots result [%d]: slots %d~%d served by %s", i2, slotRangeStart, slotRangeEnd, keys);
            for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {
              this.slots[slot] = keys;
            }
          }
          this._groupsIds = /* @__PURE__ */ Object.create(null);
          let j = 0;
          for (let i2 = 0; i2 < 16384; i2++) {
            const target = (this.slots[i2] || []).join(";");
            if (!target.length) {
              this._groupsBySlot[i2] = void 0;
              continue;
            }
            if (!this._groupsIds[target]) {
              this._groupsIds[target] = ++j;
            }
            this._groupsBySlot[i2] = this._groupsIds[target];
          }
          this.connectionPool.reset(nodes);
          callback();
        }, this.options.slotsRefreshTimeout));
      }
      invokeReadyDelayedCallbacks(err) {
        for (const c of this._readyDelayedCallbacks) {
          process.nextTick(c, err);
        }
        this._readyDelayedCallbacks = [];
      }
      readyCheck(callback) {
        this.cluster("info", function(err, res) {
          if (err) {
            return callback(err);
          }
          if (typeof res !== "string") {
            return callback();
          }
          let state;
          const lines = res.split("\r\n");
          for (let i2 = 0; i2 < lines.length; ++i2) {
            const parts = lines[i2].split(":");
            if (parts[0] === "cluster_state") {
              state = parts[1];
              break;
            }
          }
          if (state === "fail") {
            debug("cluster state not ok (%s)", state);
            callback(null, state);
          } else {
            callback();
          }
        });
      }
      resolveSrv(hostname) {
        return new Promise((resolve2, reject) => {
          this.options.resolveSrv(hostname, (err, records) => {
            if (err) {
              return reject(err);
            }
            const self2 = this, groupedRecords = util_1.groupSrvRecords(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));
            function tryFirstOne(err2) {
              if (!sortedKeys.length) {
                return reject(err2);
              }
              const key2 = sortedKeys[0], group = groupedRecords[key2], record = util_1.weightSrvRecords(group);
              if (!group.records.length) {
                sortedKeys.shift();
              }
              self2.dnsLookup(record.name).then((host) => resolve2({
                host,
                port: record.port
              }), tryFirstOne);
            }
            tryFirstOne();
          });
        });
      }
      dnsLookup(hostname) {
        return new Promise((resolve2, reject) => {
          this.options.dnsLookup(hostname, (err, address) => {
            if (err) {
              debug("failed to resolve hostname %s to IP: %s", hostname, err.message);
              reject(err);
            } else {
              debug("resolved hostname %s to IP %s", hostname, address);
              resolve2(address);
            }
          });
        });
      }
      resolveStartupNodeHostnames() {
        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
          return Promise.reject(new Error("`startupNodes` should contain at least one node."));
        }
        const startupNodes = util_1.normalizeNodeOptions(this.startupNodes);
        const hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);
        if (hostnames.length === 0) {
          return Promise.resolve(startupNodes);
        }
        return Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this))).then((configs) => {
          const hostnameToConfig = utils_2.zipMap(hostnames, configs);
          return startupNodes.map((node) => {
            const config = hostnameToConfig.get(node.host);
            if (!config) {
              return node;
            } else if (this.options.useSRVRecords) {
              return Object.assign({}, node, config);
            } else {
              return Object.assign({}, node, { host: config });
            }
          });
        });
      }
    };
    Object.getOwnPropertyNames(commander_1.default.prototype).forEach((name) => {
      if (!Cluster.prototype.hasOwnProperty(name)) {
        Cluster.prototype[name] = commander_1.default.prototype[name];
      }
    });
    var scanCommands = [
      "sscan",
      "hscan",
      "zscan",
      "sscanBuffer",
      "hscanBuffer",
      "zscanBuffer"
    ];
    scanCommands.forEach((command) => {
      Cluster.prototype[command + "Stream"] = function(key2, options) {
        return new ScanStream_1.default(utils_1.defaults({
          objectMode: true,
          key: key2,
          redis: this,
          command
        }, options));
      };
    });
    require_transaction().addTransactionSupport(Cluster.prototype);
    exports.default = Cluster;
  }
});

// node_modules/ioredis/built/index.js
var require_built2 = __commonJS({
  "node_modules/ioredis/built/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports = module2.exports = require_redis().default;
    var redis_1 = require_redis();
    exports.default = redis_1.default;
    var cluster_1 = require_cluster();
    exports.Cluster = cluster_1.default;
    var command_1 = require_command();
    exports.Command = command_1.default;
    var ScanStream_1 = require_ScanStream();
    exports.ScanStream = ScanStream_1.default;
    var pipeline_1 = require_pipeline();
    exports.Pipeline = pipeline_1.default;
    var AbstractConnector_1 = require_AbstractConnector();
    exports.AbstractConnector = AbstractConnector_1.default;
    var SentinelConnector_1 = require_SentinelConnector();
    exports.SentinelConnector = SentinelConnector_1.default;
    exports.SentinelIterator = SentinelConnector_1.SentinelIterator;
    exports.ReplyError = require_redis_errors().ReplyError;
    var PromiseContainer = require_promiseContainer();
    Object.defineProperty(exports, "Promise", {
      get() {
        return PromiseContainer.get();
      },
      set(lib) {
        PromiseContainer.set(lib);
      }
    });
    function print(err, reply) {
      if (err) {
        console.log("Error: " + err);
      } else {
        console.log("Reply: " + reply);
      }
    }
    exports.print = print;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module2) {
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/lang/Sets.js
var require_Sets = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/lang/Sets.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.setToArray = setToArray;
    exports._Set = exports.SetPoly = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var SetPoly = /* @__PURE__ */ function() {
      function SetPoly2() {
        var _this = this;
        this.__setData__ = [];
        var arrayIterable = arguments[0];
        if (Array.isArray(arrayIterable))
          arrayIterable.forEach(function(value) {
            _this.add(value);
          });
      }
      var _proto = SetPoly2.prototype;
      _proto.clear = function clear() {
        if (!this.__setData__.length)
          return;
        this.__setData__.length = 0;
      };
      _proto.add = function add(value) {
        if (this.has(value))
          return this;
        this.__setData__.push(value);
        return this;
      };
      _proto.delete = function _delete(value) {
        var index = this.__setData__.indexOf(value);
        if (index === -1)
          return false;
        this.__setData__.splice(index, 1);
        return true;
      };
      _proto.has = function has(value) {
        return this.__setData__.indexOf(value) !== -1;
      };
      _proto.forEach = function forEach(cb) {
        var thisArg = arguments[1];
        if (typeof cb !== "function")
          throw new TypeError(cb + " is not a function");
        for (var i2 = 0; i2 < this.__setData__.length; i2++) {
          var value = this.__setData__[i2];
          cb.call(thisArg, value, value, this);
        }
      };
      (0, _createClass2.default)(SetPoly2, [{
        key: "size",
        get: function get2() {
          return this.__setData__.length;
        }
      }]);
      return SetPoly2;
    }();
    exports.SetPoly = SetPoly;
    function setToArray(set3) {
      if (set3 instanceof SetPoly) {
        return set3.__setData__.slice();
      }
      return Array.from(set3);
    }
    function getSetConstructor() {
      if (typeof Array.from === "function" && typeof Set === "function" && Set.prototype && Set.prototype.values) {
        return Set;
      }
      return SetPoly;
    }
    var _Set = getSetConstructor();
    exports._Set = _Set;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module2) {
    function _getPrototypeOf(o) {
      module2.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _getPrototypeOf(o);
    }
    module2.exports = _getPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeFunction.js
var require_isNativeFunction = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeFunction.js"(exports, module2) {
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    module2.exports = _isNativeFunction, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module2) {
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    module2.exports = _isNativeReflectConstruct, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS({
  "node_modules/@babel/runtime/helpers/construct.js"(exports, module2) {
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        module2.exports = _construct = Reflect.construct, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      } else {
        module2.exports = _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            setPrototypeOf(instance, Class2.prototype);
          return instance;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      }
      return _construct.apply(null, arguments);
    }
    module2.exports = _construct, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var require_wrapNativeSuper = __commonJS({
  "node_modules/@babel/runtime/helpers/wrapNativeSuper.js"(exports, module2) {
    var getPrototypeOf = require_getPrototypeOf();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeFunction = require_isNativeFunction();
    var construct = require_construct();
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      module2.exports = _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return construct(Class2, arguments, getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return setPrototypeOf(Wrapper, Class2);
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _wrapNativeSuper(Class);
    }
    module2.exports = _wrapNativeSuper, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/lang/Errors.js
var require_Errors = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/lang/Errors.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.SplitNetworkError = exports.SplitTimeoutError = exports.SplitError = void 0;
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _wrapNativeSuper2 = _interopRequireDefault(require_wrapNativeSuper());
    var SplitError = /* @__PURE__ */ function(_Error) {
      (0, _inheritsLoose2.default)(SplitError2, _Error);
      function SplitError2(msg) {
        var _this;
        if (msg === void 0) {
          msg = "Split Error";
        }
        _this = _Error.call(this, msg) || this;
        _this.message = msg;
        return _this;
      }
      return SplitError2;
    }(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(Error));
    exports.SplitError = SplitError;
    var SplitTimeoutError = /* @__PURE__ */ function(_SplitError) {
      (0, _inheritsLoose2.default)(SplitTimeoutError2, _SplitError);
      function SplitTimeoutError2(msg) {
        return _SplitError.call(this, msg || "Split Timeout Error") || this;
      }
      return SplitTimeoutError2;
    }(SplitError);
    exports.SplitTimeoutError = SplitTimeoutError;
    var SplitNetworkError = /* @__PURE__ */ function(_SplitError2) {
      (0, _inheritsLoose2.default)(SplitNetworkError2, _SplitError2);
      function SplitNetworkError2(msg, code) {
        var _this2;
        _this2 = _SplitError2.call(this, msg || "Split Network Error") || this;
        _this2.statusCode = code;
        return _this2;
      }
      return SplitNetworkError2;
    }(SplitError);
    exports.SplitNetworkError = SplitNetworkError;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/promise/timeout.js
var require_timeout = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/promise/timeout.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _Errors = require_Errors();
    function timeout(ms, promise) {
      if (ms < 1)
        return promise;
      return new Promise(function(resolve2, reject) {
        var tid = setTimeout(function() {
          reject(new _Errors.SplitTimeoutError("Operation timed out because it exceeded the configured time limit of " + ms + "ms."));
        }, ms);
        promise.then(function(res) {
          clearTimeout(tid);
          resolve2(res);
        }, function(err) {
          clearTimeout(tid);
          reject(err);
        });
      });
    }
    var _default = timeout;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/RedisAdapter.js
var require_RedisAdapter = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/RedisAdapter.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _ioredis2 = _interopRequireDefault(require_built2());
    var _lang = require_lang();
    var _Sets = require_Sets();
    var _thenable = _interopRequireDefault(require_thenable());
    var _timeout = _interopRequireDefault(require_timeout());
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-storage:redis-adapter");
    var METHODS_TO_PROMISE_WRAP = ["set", "exec", "del", "get", "keys", "sadd", "srem", "sismember", "smembers", "incr", "rpush", "pipeline", "expire", "mget"];
    var DEFAULT_OPTIONS = {
      connectionTimeout: 1e4,
      operationTimeout: 5e3
    };
    var DEFAULT_LIBRARY_OPTIONS = {
      enableOfflineQueue: false,
      connectTimeout: DEFAULT_OPTIONS.connectionTimeout,
      lazyConnect: false
    };
    var RedisAdapter = /* @__PURE__ */ function(_ioredis) {
      (0, _inheritsLoose2.default)(RedisAdapter2, _ioredis);
      function RedisAdapter2(storageSettings) {
        var _this;
        var options = RedisAdapter2._defineOptions(storageSettings);
        _this = _ioredis.call.apply(_ioredis, [this].concat(RedisAdapter2._defineLibrarySettings(options))) || this;
        _this._options = options;
        _this._notReadyCommandsQueue = [];
        _this._runningCommands = new _Sets._Set();
        _this._listenToEvents();
        _this._setTimeoutWrappers();
        _this._setDisconnectWrapper();
        return _this;
      }
      var _proto = RedisAdapter2.prototype;
      _proto._listenToEvents = function _listenToEvents() {
        var _this2 = this;
        this.once("ready", function() {
          var commandsCount = _this2._notReadyCommandsQueue ? _this2._notReadyCommandsQueue.length : 0;
          log.info("Redis connection established. Queued commands: " + commandsCount + ".");
          commandsCount && _this2._notReadyCommandsQueue.forEach(function(queued) {
            log.info("Executing queued " + queued.name + " command.");
            queued.command().then(queued.resolve).catch(queued.reject);
          });
          _this2._notReadyCommandsQueue = false;
        });
        this.once("close", function() {
          log.info("Redis connection closed.");
        });
      };
      _proto._setTimeoutWrappers = function _setTimeoutWrappers() {
        var instance = this;
        METHODS_TO_PROMISE_WRAP.forEach(function(method) {
          var originalMethod = instance[method];
          instance[method] = function() {
            var params = arguments;
            function commandWrapper() {
              log.debug("Executing " + method + ".");
              var result = originalMethod.apply(instance, params);
              if ((0, _thenable.default)(result)) {
                instance._runningCommands.add(result);
                var cleanUpRunningCommandsCb = function cleanUpRunningCommandsCb2(res) {
                  instance._runningCommands.delete(result);
                  return res;
                };
                result.then(cleanUpRunningCommandsCb, cleanUpRunningCommandsCb);
                return (0, _timeout.default)(instance._options.operationTimeout, result).catch(function(err) {
                  log.error(method + " operation threw an error or exceeded configured timeout of " + instance._options.operationTimeout + "ms. Message: " + err);
                  throw err;
                });
              }
              return result;
            }
            if (instance._notReadyCommandsQueue) {
              return new Promise(function(res, rej) {
                instance._notReadyCommandsQueue.unshift({
                  resolve: res,
                  reject: rej,
                  command: commandWrapper,
                  name: method.toUpperCase()
                });
              });
            } else {
              return commandWrapper();
            }
          };
        });
      };
      _proto._setDisconnectWrapper = function _setDisconnectWrapper() {
        var instance = this;
        var originalMethod = instance.disconnect;
        instance.disconnect = function disconnect() {
          var params = arguments;
          setTimeout(function deferedDisconnect() {
            if (instance._runningCommands.size > 0) {
              log.info("Attempting to disconnect but there are " + instance._runningCommands.size + " commands still waiting for resolution. Defering disconnection until those finish.");
              Promise.all((0, _Sets.setToArray)(instance._runningCommands)).then(function() {
                log.debug("Pending commands finished successfully, disconnecting.");
                originalMethod.apply(instance, params);
              }).catch(function(e2) {
                log.warn("Pending commands finished with error: " + e2 + ". Proceeding with disconnection.");
                originalMethod.apply(instance, params);
              });
            } else {
              log.debug("No commands pending execution, disconnect.");
              originalMethod.apply(instance, params);
            }
          }, 10);
        };
      };
      RedisAdapter2._defineLibrarySettings = function _defineLibrarySettings(options) {
        var opts = (0, _lang.merge)({}, DEFAULT_LIBRARY_OPTIONS);
        var result = [opts];
        if (!(0, _lang.isString)(options.url)) {
          (0, _lang.merge)(opts, {
            host: options.host,
            port: options.port,
            db: options.db,
            password: options.pass
          });
        } else {
          result.unshift(options.url);
        }
        return result;
      };
      RedisAdapter2._defineOptions = function _defineOptions(_ref) {
        var connectionTimeout = _ref.connectionTimeout, operationTimeout = _ref.operationTimeout, url = _ref.url, host = _ref.host, port = _ref.port, db = _ref.db, pass = _ref.pass;
        var parsedOptions = {
          connectionTimeout,
          operationTimeout,
          url,
          host,
          port,
          db,
          pass
        };
        return (0, _lang.merge)({}, DEFAULT_OPTIONS, parsedOptions);
      };
      return RedisAdapter2;
    }(_ioredis2.default);
    exports.default = RedisAdapter;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/splits/usesSegments.js
var require_usesSegments = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/splits/usesSegments.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function usesSegments(conditions) {
      if (conditions === void 0) {
        conditions = [];
      }
      for (var i2 = 0; i2 < conditions.length; i2++) {
        var matchers = conditions[i2].matcherGroup.matchers;
        for (var j = 0; j < matchers.length; j++) {
          if (matchers[j].matcherType === "IN_SEGMENT")
            return true;
        }
      }
      return false;
    }
    var _default = usesSegments;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/SplitCache/killLocally.js
var require_killLocally = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/SplitCache/killLocally.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = killLocally;
    var _thenable = _interopRequireDefault(require_thenable());
    function killLocally(splitName, defaultTreatment, changeNumber) {
      var _this = this;
      var split2 = this.getSplit(splitName);
      var splitPromise = (0, _thenable.default)(split2) ? split2 : Promise.resolve(split2);
      return splitPromise.then(function(split3) {
        if (split3) {
          var parsedSplit = JSON.parse(split3);
          if (!parsedSplit.changeNumber || parsedSplit.changeNumber < changeNumber) {
            parsedSplit.killed = true;
            parsedSplit.defaultTreatment = defaultTreatment;
            parsedSplit.changeNumber = changeNumber;
            var newSplit = JSON.stringify(parsedSplit);
            return _this.addSplit(splitName, newSplit);
          }
        }
        return false;
      });
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/SplitCache/InMemory.js
var require_InMemory = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/SplitCache/InMemory.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _usesSegments = _interopRequireDefault(require_usesSegments());
    var _killLocally = _interopRequireDefault(require_killLocally());
    var SplitCacheInMemory = /* @__PURE__ */ function() {
      function SplitCacheInMemory2() {
        this.flush();
      }
      var _proto = SplitCacheInMemory2.prototype;
      _proto.addSplit = function addSplit(splitName, split2) {
        var splitFromMemory = this.getSplit(splitName);
        if (splitFromMemory) {
          var previousSplit = JSON.parse(splitFromMemory);
          if (previousSplit.trafficTypeName) {
            var previousTtName = previousSplit.trafficTypeName;
            this.ttCache[previousTtName]--;
            if (!this.ttCache[previousTtName])
              delete this.ttCache[previousTtName];
          }
          if ((0, _usesSegments.default)(previousSplit.conditions)) {
            this.splitsWithSegmentsCount--;
          }
        }
        var parsedSplit = JSON.parse(split2);
        if (parsedSplit) {
          this.splitCache[splitName] = split2;
          var ttName = parsedSplit.trafficTypeName;
          if (ttName) {
            if (!this.ttCache[ttName])
              this.ttCache[ttName] = 0;
            this.ttCache[ttName]++;
          }
          if ((0, _usesSegments.default)(parsedSplit.conditions))
            this.splitsWithSegmentsCount++;
          return true;
        } else {
          return false;
        }
      };
      _proto.addSplits = function addSplits(entries) {
        var _this = this;
        var results = [];
        entries.forEach(function(keyValuePair) {
          results.push(_this.addSplit(keyValuePair[0], keyValuePair[1]));
        });
        return results;
      };
      _proto.removeSplit = function removeSplit(splitName) {
        var split2 = this.getSplit(splitName);
        if (split2) {
          delete this.splitCache[splitName];
          var parsedSplit = JSON.parse(split2);
          var ttName = parsedSplit.trafficTypeName;
          if (ttName) {
            this.ttCache[ttName]--;
            if (!this.ttCache[ttName])
              delete this.ttCache[ttName];
          }
          if ((0, _usesSegments.default)(parsedSplit.conditions))
            this.splitsWithSegmentsCount--;
          return 1;
        } else {
          return 0;
        }
      };
      _proto.removeSplits = function removeSplits(splitNames) {
        var _this2 = this;
        splitNames.forEach(function(n) {
          return _this2.removeSplit(n);
        });
        return splitNames.length;
      };
      _proto.getSplit = function getSplit(splitName) {
        return this.splitCache[splitName];
      };
      _proto.setChangeNumber = function setChangeNumber(changeNumber) {
        this.changeNumber = changeNumber;
        return true;
      };
      _proto.getChangeNumber = function getChangeNumber() {
        return this.changeNumber;
      };
      _proto.getAll = function getAll() {
        var _this3 = this;
        return this.getKeys().map(function(key2) {
          return _this3.splitCache[key2];
        });
      };
      _proto.getKeys = function getKeys() {
        return Object.keys(this.splitCache);
      };
      _proto.trafficTypeExists = function trafficTypeExists(trafficType) {
        return (0, _lang.numberIsFinite)(this.ttCache[trafficType]) && this.ttCache[trafficType] > 0;
      };
      _proto.usesSegments = function usesSegments() {
        return this.getChangeNumber() === -1 || this.splitsWithSegmentsCount > 0;
      };
      _proto.flush = function flush() {
        this.splitCache = {};
        this.ttCache = {};
        this.changeNumber = -1;
        this.splitsWithSegmentsCount = 0;
      };
      _proto.fetchMany = function fetchMany(splitNames) {
        var _this4 = this;
        var splits = {};
        splitNames.forEach(function(splitName) {
          splits[splitName] = _this4.splitCache[splitName] || null;
        });
        return splits;
      };
      _proto.checkCache = function checkCache() {
        return false;
      };
      return SplitCacheInMemory2;
    }();
    SplitCacheInMemory.prototype.killLocally = _killLocally.default;
    var _default = SplitCacheInMemory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/SplitCache/InRedis.js
var require_InRedis = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/SplitCache/InRedis.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-storage:redis");
    var processPipelineAnswer = function processPipelineAnswer2(results) {
      return results.reduce(function(accum, errValuePair) {
        if (errValuePair[0] === null)
          accum.push(errValuePair[1]);
        return accum;
      }, []);
    };
    var SplitCacheInRedis = /* @__PURE__ */ function() {
      function SplitCacheInRedis2(keys, redis) {
        var _this = this;
        this.redis = redis;
        this.keys = keys;
        this.redisError = false;
        this.redis.on("error", function(e2) {
          _this.redisError = e2;
        });
        this.redis.on("connect", function() {
          _this.redisError = false;
        });
      }
      var _proto = SplitCacheInRedis2.prototype;
      _proto.addSplit = function addSplit(splitName, split2) {
        return this.redis.set(this.keys.buildSplitKey(splitName), split2).then(function(status) {
          return status === "OK";
        });
      };
      _proto.addSplits = function addSplits(entries) {
        var _this2 = this;
        if (entries.length) {
          var cmds = entries.map(function(keyValuePair) {
            return ["set", _this2.keys.buildSplitKey(keyValuePair[0]), keyValuePair[1]];
          });
          return this.redis.pipeline(cmds).exec().then(processPipelineAnswer).then(function(answers) {
            return answers.map(function(status) {
              return status === "OK";
            });
          });
        } else {
          return [true];
        }
      };
      _proto.removeSplit = function removeSplit(splitName) {
        return this.redis.del(this.keys.buildSplitKey(splitName));
      };
      _proto.removeSplits = function removeSplits(names) {
        var _this3 = this;
        if (names.length) {
          return this.redis.del(names.map(function(n) {
            return _this3.keys.buildSplitKey(n);
          }));
        } else {
          return Promise.resolve(0);
        }
      };
      _proto.getSplit = function getSplit(splitName) {
        if (this.redisError) {
          log.error(this.redisError);
          throw this.redisError;
        }
        return this.redis.get(this.keys.buildSplitKey(splitName));
      };
      _proto.setChangeNumber = function setChangeNumber(changeNumber) {
        return this.redis.set(this.keys.buildSplitsTillKey(), changeNumber + "").then(function(status) {
          return status === "OK";
        });
      };
      _proto.getChangeNumber = function getChangeNumber() {
        return this.redis.get(this.keys.buildSplitsTillKey()).then(function(value) {
          var i2 = parseInt(value, 10);
          return (0, _lang.numberIsNaN)(i2) ? -1 : i2;
        });
      };
      _proto.getAll = function getAll() {
        var _this4 = this;
        return this.redis.keys(this.keys.searchPatternForSplitKeys()).then(function(listOfKeys) {
          return _this4.redis.pipeline(listOfKeys.map(function(k) {
            return ["get", k];
          })).exec();
        }).then(processPipelineAnswer);
      };
      _proto.getKeys = function getKeys() {
        var _this5 = this;
        return this.redis.keys(this.keys.searchPatternForSplitKeys()).then(function(listOfKeys) {
          return listOfKeys.map(_this5.keys.extractKey);
        });
      };
      _proto.trafficTypeExists = function trafficTypeExists(trafficType) {
        return this.redis.get(this.keys.buildTrafficTypeKey(trafficType)).then(function(ttCount) {
          ttCount = parseInt(ttCount, 10);
          if (!(0, _lang.numberIsFinite)(ttCount) || ttCount < 0) {
            log.info("Could not validate traffic type existance of " + trafficType + " due to data corruption of some sorts.");
            return false;
          }
          return ttCount > 0;
        }).catch(function(e2) {
          log.error("Could not validate traffic type existance of " + trafficType + " due to an error: " + e2 + ".");
          return true;
        });
      };
      _proto.usesSegments = function usesSegments() {
        return true;
      };
      _proto.flush = function flush() {
        return this.redis.flushdb().then(function(status) {
          return status === "OK";
        });
      };
      _proto.fetchMany = function fetchMany(splitNames) {
        var _this6 = this, _this$redis;
        if (this.redisError) {
          log.error(this.redisError);
          throw this.redisError;
        }
        var splits = {};
        var keys = splitNames.map(function(splitName) {
          return _this6.keys.buildSplitKey(splitName);
        });
        return (_this$redis = this.redis).mget.apply(_this$redis, keys).then(function(splitDefinitions) {
          splitNames.forEach(function(splitName, idx) {
            splits[splitName] = splitDefinitions[idx];
          });
          return Promise.resolve(splits);
        }).catch(function(e2) {
          log.error("Could not grab splits due to an error: " + e2 + ".");
          return Promise.reject(e2);
        });
      };
      _proto.checkCache = function checkCache() {
        return false;
      };
      return SplitCacheInRedis2;
    }();
    var _default = SplitCacheInRedis;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/SegmentCache/InMemory/node.js
var require_node2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/SegmentCache/InMemory/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _Sets = require_Sets();
    var SegmentCacheInMemory = /* @__PURE__ */ function() {
      function SegmentCacheInMemory2(keys) {
        this.keys = keys;
        this.flush();
      }
      var _proto = SegmentCacheInMemory2.prototype;
      _proto.addToSegment = function addToSegment(segmentName, segmentKeys) {
        var values = this.segmentCache[segmentName];
        var keySet = values ? values : new _Sets._Set();
        segmentKeys.forEach(function(k) {
          return keySet.add(k);
        });
        this.segmentCache[segmentName] = keySet;
        return true;
      };
      _proto.removeFromSegment = function removeFromSegment(segmentName, segmentKeys) {
        var values = this.segmentCache[segmentName];
        var keySet = values ? values : new _Sets._Set();
        segmentKeys.forEach(function(k) {
          return keySet.delete(k);
        });
        this.segmentCache[segmentName] = keySet;
        return true;
      };
      _proto.isInSegment = function isInSegment(segmentName, key2) {
        var segmentValues = this.segmentCache[segmentName];
        if (segmentValues) {
          return segmentValues.has(key2);
        }
        return false;
      };
      _proto.registerSegment = function registerSegment(segmentName) {
        if (!this.segmentCache[segmentName]) {
          this.segmentCache[segmentName] = new _Sets._Set();
        }
        return true;
      };
      _proto.registerSegments = function registerSegments(segments) {
        for (var i2 = 0; i2 < segments.length; i2++) {
          this.registerSegment(segments[i2]);
        }
        return true;
      };
      _proto.getRegisteredSegments = function getRegisteredSegments() {
        return Object.keys(this.segmentCache);
      };
      _proto.setChangeNumber = function setChangeNumber(segmentName, changeNumber) {
        var segmentChangeNumberKey = this.keys.buildSegmentTillKey(segmentName);
        this.segmentChangeNumber[segmentChangeNumberKey] = changeNumber;
        return true;
      };
      _proto.getChangeNumber = function getChangeNumber(segmentName) {
        var segmentChangeNumberKey = this.keys.buildSegmentTillKey(segmentName);
        var value = this.segmentChangeNumber[segmentChangeNumberKey];
        return (0, _lang.numberIsInteger)(value) ? value : -1;
      };
      _proto.flush = function flush() {
        this.segmentCache = {};
        this.segmentChangeNumber = {};
      };
      return SegmentCacheInMemory2;
    }();
    var _default = SegmentCacheInMemory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/SegmentCache/InRedis/index.js
var require_InRedis2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/SegmentCache/InRedis/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var SegmentCacheInRedis = /* @__PURE__ */ function() {
      function SegmentCacheInRedis2(keys, redis) {
        this.redis = redis;
        this.keys = keys;
      }
      var _proto = SegmentCacheInRedis2.prototype;
      _proto.addToSegment = function addToSegment(segmentName, segmentKeys) {
        var segmentKey = this.keys.buildSegmentNameKey(segmentName);
        if (segmentKeys.length) {
          return this.redis.sadd(segmentKey, segmentKeys).then(function() {
            return true;
          });
        } else {
          return Promise.resolve(true);
        }
      };
      _proto.removeFromSegment = function removeFromSegment(segmentName, segmentKeys) {
        var segmentKey = this.keys.buildSegmentNameKey(segmentName);
        if (segmentKeys.length) {
          return this.redis.srem(segmentKey, segmentKeys).then(function() {
            return true;
          });
        } else {
          return Promise.resolve(true);
        }
      };
      _proto.isInSegment = function isInSegment(segmentName, key2) {
        return this.redis.sismember(this.keys.buildSegmentNameKey(segmentName), key2).then(function(matches) {
          return matches !== 0;
        });
      };
      _proto.setChangeNumber = function setChangeNumber(segmentName, changeNumber) {
        return this.redis.set(this.keys.buildSegmentTillKey(segmentName), changeNumber + "").then(function(status) {
          return status === "OK";
        });
      };
      _proto.getChangeNumber = function getChangeNumber(segmentName) {
        return this.redis.get(this.keys.buildSegmentTillKey(segmentName)).then(function(value) {
          var i2 = parseInt(value, 10);
          return (0, _lang.numberIsNaN)(i2) ? -1 : i2;
        });
      };
      _proto.registerSegment = function registerSegment(segment) {
        return this.registerSegments(segment);
      };
      _proto.registerSegments = function registerSegments(segments) {
        if (segments.length) {
          return this.redis.sadd(this.keys.buildRegisteredSegmentsKey(), segments).then(function() {
            return true;
          });
        } else {
          return Promise.resolve(true);
        }
      };
      _proto.getRegisteredSegments = function getRegisteredSegments() {
        return this.redis.smembers(this.keys.buildRegisteredSegmentsKey());
      };
      _proto.flush = function flush() {
        return this.redis.flushdb().then(function(status) {
          return status === "OK";
        });
      };
      return SegmentCacheInRedis2;
    }();
    var _default = SegmentCacheInRedis;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/ImpressionsCache/InMemory.js
var require_InMemory2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/ImpressionsCache/InMemory.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var ImpressionsCacheInMemory = /* @__PURE__ */ function() {
      function ImpressionsCacheInMemory2() {
        this.queue = [];
      }
      var _proto = ImpressionsCacheInMemory2.prototype;
      _proto.state = function state() {
        return this.queue;
      };
      _proto.track = function track(data) {
        var _this$queue;
        (_this$queue = this.queue).push.apply(_this$queue, data);
        return this;
      };
      _proto.clear = function clear() {
        this.queue.length = 0;
        return this;
      };
      _proto.toJSON = function toJSON() {
        return this.queue;
      };
      _proto.isEmpty = function isEmpty() {
        return this.queue.length === 0;
      };
      return ImpressionsCacheInMemory2;
    }();
    var _default = ImpressionsCacheInMemory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/ImpressionsCache/InRedis.js
var require_InRedis3 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/ImpressionsCache/InRedis.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var ImpressionsCacheInRedis = /* @__PURE__ */ function() {
      function ImpressionsCacheInRedis2(keys, redis, meta) {
        this.keys = keys;
        this.redis = redis;
        this.meta = meta;
      }
      var _proto = ImpressionsCacheInRedis2.prototype;
      _proto.track = function track(impressions) {
        var _this = this;
        return this.redis.rpush(this.keys.buildImpressionsKey(), this.toJSON(impressions)).then(function(queuedCount) {
          if (queuedCount === impressions.length) {
            return _this.redis.expire(_this.keys.buildImpressionsKey(), 3600);
          }
        });
      };
      _proto.toJSON = function toJSON(impressions) {
        var _this2 = this;
        return impressions.map(function(impression) {
          var keyName = impression.keyName, bucketingKey = impression.bucketingKey, feature = impression.feature, treatment = impression.treatment, label = impression.label, time = impression.time, changeNumber = impression.changeNumber;
          return JSON.stringify({
            m: _this2.meta,
            i: {
              k: keyName,
              b: bucketingKey,
              f: feature,
              t: treatment,
              r: label,
              c: changeNumber,
              m: time
            }
          });
        });
      };
      _proto.isEmpty = function isEmpty() {
        return true;
      };
      return ImpressionsCacheInRedis2;
    }();
    var _default = ImpressionsCacheInRedis;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/binarySearch/index.js
var require_binarySearch = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/binarySearch/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function bs(items, value) {
      var startIndex = 0;
      var stopIndex = items.length - 1;
      var middle = Math.floor((stopIndex + startIndex) / 2);
      var minIndex = startIndex;
      var maxIndex = stopIndex;
      while (items[middle] !== value && startIndex < stopIndex) {
        if (value < items[middle]) {
          stopIndex = middle - 1;
        } else if (value > items[middle]) {
          startIndex = middle + 1;
        }
        middle = Math.floor((stopIndex + startIndex) / 2);
      }
      if (middle < minIndex) {
        middle = minIndex;
      } else if (middle > maxIndex) {
        middle = maxIndex;
      }
      if (value < items[middle] && middle > minIndex) {
        return middle - 1;
      }
      return middle;
    }
    var _default = bs;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/LatencyCache/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/LatencyCache/findIndex.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _binarySearch = _interopRequireDefault(require_binarySearch());
    var _default = _binarySearch.default.bind(null, [1, 1.5, 2.25, 3.38, 5.06, 7.59, 11.39, 17.09, 25.63, 38.44, 57.67, 86.5, 129.75, 194.62, 291.93, 437.89, 656.84, 985.26, 1477.89, 2216.84, 3325.26, 4987.89, 7481.83]);
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/LatencyCache/InMemory.js
var require_InMemory3 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/LatencyCache/InMemory.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _findIndex = _interopRequireDefault(require_findIndex());
    var LatencyCacheInMemory = /* @__PURE__ */ function() {
      function LatencyCacheInMemory2() {
        this.clear();
      }
      var _proto = LatencyCacheInMemory2.prototype;
      _proto.clear = function clear() {
        this.counters = {};
        return this;
      };
      _proto.state = function state() {
        return this.counters;
      };
      _proto.track = function track(metricName, latency) {
        if (this.counters[metricName] === void 0) {
          this.counters[metricName] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.counters[metricName][(0, _findIndex.default)(latency)]++;
        return this;
      };
      _proto.isEmpty = function isEmpty() {
        return Object.keys(this.counters).length === 0;
      };
      _proto.toJSON = function toJSON() {
        return this.counters;
      };
      return LatencyCacheInMemory2;
    }();
    var _default = LatencyCacheInMemory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/BaseMetricsAsyncCache.js
var require_BaseMetricsAsyncCache = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/BaseMetricsAsyncCache.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var BaseMetricsAsyncCache = /* @__PURE__ */ function() {
      function BaseMetricsAsyncCache2() {
      }
      var _proto = BaseMetricsAsyncCache2.prototype;
      _proto.isEmpty = function isEmpty() {
        return true;
      };
      _proto.clear = function clear() {
      };
      return BaseMetricsAsyncCache2;
    }();
    exports.default = BaseMetricsAsyncCache;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/LatencyCache/InRedis.js
var require_InRedis4 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/LatencyCache/InRedis.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _findIndex = _interopRequireDefault(require_findIndex());
    var _BaseMetricsAsyncCache = _interopRequireDefault(require_BaseMetricsAsyncCache());
    var LatencyCacheInRedis = /* @__PURE__ */ function(_BaseMetricsAsyncCach) {
      (0, _inheritsLoose2.default)(LatencyCacheInRedis2, _BaseMetricsAsyncCach);
      function LatencyCacheInRedis2(keys, redis) {
        var _this;
        _this = _BaseMetricsAsyncCach.call(this) || this;
        _this.keys = keys;
        _this.redis = redis;
        return _this;
      }
      var _proto = LatencyCacheInRedis2.prototype;
      _proto.track = function track(metricName, latency) {
        var bucketNumber = (0, _findIndex.default)(latency);
        return this.redis.incr(this.keys.buildLatencyKey(metricName, bucketNumber)).catch(function() {
        });
      };
      return LatencyCacheInRedis2;
    }(_BaseMetricsAsyncCache.default);
    var _default = LatencyCacheInRedis;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/CountCache/InMemory.js
var require_InMemory4 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/CountCache/InMemory.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var CountCacheInMemory = /* @__PURE__ */ function() {
      function CountCacheInMemory2() {
        this.clear();
      }
      var _proto = CountCacheInMemory2.prototype;
      _proto.clear = function clear() {
        this.counters = {};
        return this;
      };
      _proto.state = function state() {
        return this.counters;
      };
      _proto.track = function track(metricName) {
        if (this.counters[metricName] === void 0)
          this.counters[metricName] = 1;
        else
          this.counters[metricName]++;
        return this.counters[metricName];
      };
      _proto.isEmpty = function isEmpty() {
        return Object.keys(this.counters).length === 0;
      };
      _proto.toJSON = function toJSON() {
        return this.counters;
      };
      return CountCacheInMemory2;
    }();
    var _default = CountCacheInMemory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/CountCache/InRedis.js
var require_InRedis5 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/CountCache/InRedis.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _BaseMetricsAsyncCache = _interopRequireDefault(require_BaseMetricsAsyncCache());
    var CountCacheInRedis = /* @__PURE__ */ function(_BaseMetricsAsyncCach) {
      (0, _inheritsLoose2.default)(CountCacheInRedis2, _BaseMetricsAsyncCach);
      function CountCacheInRedis2(keys, redis) {
        var _this;
        _this = _BaseMetricsAsyncCach.call(this) || this;
        _this.keys = keys;
        _this.redis = redis;
        return _this;
      }
      var _proto = CountCacheInRedis2.prototype;
      _proto.track = function track(metricName) {
        return this.redis.incr(this.keys.buildCountKey(metricName)).catch(function() {
        });
      };
      return CountCacheInRedis2;
    }(_BaseMetricsAsyncCache.default);
    var _default = CountCacheInRedis;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/EventsCache/InMemory.js
var require_InMemory5 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/EventsCache/InMemory.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _thenable = _interopRequireDefault(require_thenable());
    var MAX_QUEUE_BYTE_SIZE = 5 * 1024 * 1024;
    var EventsCache = /* @__PURE__ */ function() {
      function EventsCache2(context) {
        var _this = this;
        var settings = context.get(context.constants.SETTINGS);
        var eventsModule = context.get(context.constants.EVENTS);
        this.onFullQueue = false;
        this.maxQueue = settings.scheduler.eventsQueueSize;
        this.queue = [];
        this.queueByteSize = 0;
        if ((0, _thenable.default)(eventsModule)) {
          eventsModule.then(function(events) {
            _this.onFullQueue = events.flushAndResetTimer;
            _this._checkForFlush();
          });
        } else if (typeof eventsModule.flushAndResetTimer === "function") {
          this.onFullQueue = eventsModule.flushAndResetTimer;
        }
      }
      var _proto = EventsCache2.prototype;
      _proto.state = function state() {
        return this.queue;
      };
      _proto.track = function track(data, size) {
        if (size === void 0) {
          size = 0;
        }
        this.queueByteSize += size;
        this.queue.push(data);
        this._checkForFlush();
        return true;
      };
      _proto.clear = function clear() {
        this.queue = [];
        this.queueByteSize = 0;
        return this;
      };
      _proto.toJSON = function toJSON() {
        return this.queue;
      };
      _proto.isEmpty = function isEmpty() {
        return this.queue.length === 0;
      };
      _proto._checkForFlush = function _checkForFlush() {
        if (this.queueByteSize > MAX_QUEUE_BYTE_SIZE || this.maxQueue > 0 && this.queue.length >= this.maxQueue) {
          this.onFullQueue && this.onFullQueue();
        }
      };
      return EventsCache2;
    }();
    var _default = EventsCache;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/EventsCache/InRedis.js
var require_InRedis6 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/EventsCache/InRedis.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-storage:redis");
    var EventsCache = /* @__PURE__ */ function() {
      function EventsCache2(keys, redis, meta) {
        this.keys = keys;
        this.redis = redis;
        this.meta = meta;
        this.eventsKey = keys.buildEventsKey();
      }
      var _proto = EventsCache2.prototype;
      _proto.track = function track(eventData) {
        return this.redis.rpush(this.eventsKey, this._toJSON(eventData)).then(function() {
          return true;
        }).catch(function(err) {
          log.error("Error adding event to queue: " + err + ".");
          return false;
        });
      };
      _proto._toJSON = function _toJSON(eventData) {
        return JSON.stringify({
          m: this.meta,
          e: eventData
        });
      };
      _proto.isEmpty = function isEmpty() {
        return true;
      };
      return EventsCache2;
    }();
    var _default = EventsCache;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/Keys.js
var require_Keys = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/Keys.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var everythingAtTheEnd = /[^.]+$/;
    var everythingAfterCount = /count\.([^/]+)$/;
    var latencyMetricNameAndBucket = /latency\.([^/]+)\.bucket\.([0-9]+)$/;
    var KeyBuilder = /* @__PURE__ */ function() {
      function KeyBuilder2(settings) {
        this.settings = settings;
      }
      var _proto = KeyBuilder2.prototype;
      _proto.buildSplitKey = function buildSplitKey(splitName) {
        return this.settings.storage.prefix + ".split." + splitName;
      };
      _proto.buildTrafficTypeKey = function buildTrafficTypeKey(trafficType) {
        return this.settings.storage.prefix + ".trafficType." + trafficType;
      };
      _proto.buildSplitsTillKey = function buildSplitsTillKey() {
        return this.settings.storage.prefix + ".splits.till";
      };
      _proto.buildSplitsReady = function buildSplitsReady() {
        return this.settings.storage.prefix + ".splits.ready";
      };
      _proto.isSplitKey = function isSplitKey(key2) {
        return (0, _lang.startsWith)(key2, this.settings.storage.prefix + ".split.");
      };
      _proto.buildSegmentNameKey = function buildSegmentNameKey(segmentName) {
        return this.settings.storage.prefix + ".segment." + segmentName;
      };
      _proto.buildSegmentTillKey = function buildSegmentTillKey(segmentName) {
        return this.settings.storage.prefix + ".segment." + segmentName + ".till";
      };
      _proto.buildRegisteredSegmentsKey = function buildRegisteredSegmentsKey() {
        return this.settings.storage.prefix + ".segments.registered";
      };
      _proto.buildSegmentsReady = function buildSegmentsReady() {
        return this.settings.storage.prefix + ".segments.ready";
      };
      _proto.buildVersionablePrefix = function buildVersionablePrefix() {
        return this.settings.storage.prefix + "/" + this.settings.version + "/" + this.settings.runtime.ip;
      };
      _proto.buildImpressionsKey = function buildImpressionsKey() {
        return this.settings.storage.prefix + ".impressions";
      };
      _proto.buildEventsKey = function buildEventsKey() {
        return this.settings.storage.prefix + ".events";
      };
      _proto.buildLatencyKeyPrefix = function buildLatencyKeyPrefix() {
        return this.buildVersionablePrefix() + "/latency";
      };
      _proto.buildLatencyKey = function buildLatencyKey(metricName, bucketNumber) {
        return this.buildLatencyKeyPrefix() + "." + metricName + ".bucket." + bucketNumber;
      };
      _proto.buildCountKey = function buildCountKey(metricName) {
        return this.buildVersionablePrefix() + "/count." + metricName;
      };
      _proto.buildGaugeKey = function buildGaugeKey(metricName) {
        return this.buildVersionablePrefix() + "/gauge." + metricName;
      };
      _proto.searchPatternForCountKeys = function searchPatternForCountKeys() {
        return this.buildVersionablePrefix() + "/count.*";
      };
      _proto.searchPatternForSplitKeys = function searchPatternForSplitKeys() {
        return this.settings.storage.prefix + ".split.*";
      };
      _proto.searchPatternForLatency = function searchPatternForLatency() {
        return this.buildLatencyKeyPrefix() + ".*";
      };
      _proto.extractKey = function extractKey(builtKey) {
        var s3 = builtKey.match(everythingAtTheEnd);
        if (s3 && s3.length) {
          return s3[0];
        } else {
          throw new Error("Invalid latency key provided");
        }
      };
      _proto.extractCounterName = function extractCounterName(counterKey) {
        var m2 = counterKey.match(everythingAfterCount);
        if (m2 && m2.length) {
          return m2[1];
        } else {
          throw new Error("Invalid counter key provided");
        }
      };
      _proto.extractLatencyMetricNameAndBucket = function extractLatencyMetricNameAndBucket(latencyKey) {
        var parts = latencyKey.match(latencyMetricNameAndBucket);
        if (parts && parts.length > 2) {
          return {
            metricName: parts[1],
            bucketNumber: parts[2]
          };
        } else {
          throw new Error("Invalid counter key provided");
        }
      };
      return KeyBuilder2;
    }();
    var _default = KeyBuilder;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/Meta.js
var require_Meta = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/Meta.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = MetaBuilder;
    function MetaBuilder(settings) {
      return {
        s: settings.version,
        i: settings.runtime.ip,
        n: settings.runtime.hostname
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/storage/node.js
var require_node3 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/storage/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _RedisAdapter = _interopRequireDefault(require_RedisAdapter());
    var _InMemory = _interopRequireDefault(require_InMemory());
    var _InRedis = _interopRequireDefault(require_InRedis());
    var _InMemory2 = _interopRequireDefault(require_node2());
    var _InRedis2 = _interopRequireDefault(require_InRedis2());
    var _InMemory3 = _interopRequireDefault(require_InMemory2());
    var _InRedis3 = _interopRequireDefault(require_InRedis3());
    var _InMemory4 = _interopRequireDefault(require_InMemory3());
    var _InRedis4 = _interopRequireDefault(require_InRedis4());
    var _InMemory5 = _interopRequireDefault(require_InMemory4());
    var _InRedis5 = _interopRequireDefault(require_InRedis5());
    var _InMemory6 = _interopRequireDefault(require_InMemory5());
    var _InRedis6 = _interopRequireDefault(require_InRedis6());
    var _Keys = _interopRequireDefault(require_Keys());
    var _Meta = _interopRequireDefault(require_Meta());
    var _constants = require_constants();
    var NodeStorageFactory = function NodeStorageFactory2(context) {
      var settings = context.get(context.constants.SETTINGS);
      var storage = settings.storage;
      var keys = new _Keys.default(settings);
      switch (storage.type) {
        case _constants.STORAGE_REDIS: {
          var redis = new _RedisAdapter.default(storage.options);
          var meta = (0, _Meta.default)(settings);
          var _context$get = context.get(context.constants.READINESS), splits = _context$get.splits, segments = _context$get.segments;
          redis.on("connect", function() {
            splits.emit(splits.SDK_SPLITS_ARRIVED);
            segments.emit(segments.SDK_SEGMENTS_ARRIVED);
          });
          return {
            splits: new _InRedis.default(keys, redis),
            segments: new _InRedis2.default(keys, redis),
            impressions: new _InRedis3.default(keys, redis, meta),
            metrics: new _InRedis4.default(keys, redis),
            count: new _InRedis5.default(keys, redis),
            events: new _InRedis6.default(keys, redis, meta),
            destroy: function destroy() {
              redis.disconnect();
              this.splits = new _InMemory.default();
              this.segments = new _InMemory2.default(keys);
              this.impressions = new _InMemory3.default();
              this.metrics = new _InMemory4.default();
              this.count = new _InMemory5.default();
              this.events = new _InMemory6.default(context);
            }
          };
        }
        case _constants.STORAGE_MEMORY:
        default:
          return {
            splits: new _InMemory.default(),
            segments: new _InMemory2.default(keys),
            impressions: new _InMemory3.default(),
            metrics: new _InMemory4.default(),
            count: new _InMemory5.default(),
            events: new _InMemory6.default(context),
            destroy: function destroy() {
              this.splits.flush();
              this.segments.flush();
              this.impressions.clear();
              this.metrics.clear();
              this.count.clear();
              this.events.clear();
            }
          };
      }
    };
    var _default = NodeStorageFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/readiness/index.js
var require_readiness = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/readiness/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _events = _interopRequireDefault(require("events"));
    var SPLITS_READY = 2;
    var SEGMENTS_READY = 4;
    var SDK_FIRE_READY = SPLITS_READY | SEGMENTS_READY;
    var SDK_NOTIFY_UPDATE_SINCE_NOW = 8;
    var SDK_FIRE_UPDATE = SDK_FIRE_READY | SDK_NOTIFY_UPDATE_SINCE_NOW;
    var Events = {
      SDK_READY_TIMED_OUT: "init::timeout",
      SDK_READY: "init::ready",
      SDK_READY_FROM_CACHE: "init::cache-ready",
      SDK_SPLITS_ARRIVED: "state::splits-arrived",
      SDK_SEGMENTS_ARRIVED: "state::segments-arrived",
      SDK_SPLITS_CACHE_LOADED: "state::splits-cache-loaded",
      SDK_UPDATE: "state::update",
      READINESS_GATE_CHECK_STATE: "state::check"
    };
    function GateContext() {
      var splitsStatus = 0;
      var splits = new _events.default();
      splits.SDK_SPLITS_CACHE_LOADED = Events.SDK_SPLITS_CACHE_LOADED;
      splits.SDK_SPLITS_ARRIVED = Events.SDK_SPLITS_ARRIVED;
      var refCount = 0;
      function ReadinessGateFactory(splits2, segments) {
        var gate = new _events.default();
        var segmentsStatus = 0;
        var status = 0;
        gate.on(Events.READINESS_GATE_CHECK_STATE, function() {
          if (status !== SDK_FIRE_UPDATE && splitsStatus + segmentsStatus === SDK_FIRE_READY) {
            status = SDK_FIRE_UPDATE;
            gate.emit(Events.SDK_READY);
          } else if (status === SDK_FIRE_UPDATE) {
            gate.emit(Events.SDK_UPDATE);
          }
        });
        splits2.on(Events.SDK_SPLITS_ARRIVED, function(isSplitKill) {
          if (!isSplitKill)
            splitsStatus = SPLITS_READY;
          gate.emit(Events.READINESS_GATE_CHECK_STATE);
        });
        splits2.once(Events.SDK_SPLITS_CACHE_LOADED, function() {
          try {
            gate.emit(Events.SDK_READY_FROM_CACHE);
          } catch (e2) {
            setTimeout(function() {
              throw e2;
            }, 0);
          }
        });
        segments.on(Events.SDK_SEGMENTS_ARRIVED, function() {
          segmentsStatus = SEGMENTS_READY;
          gate.emit(Events.READINESS_GATE_CHECK_STATE);
        });
        return gate;
      }
      function SDKReadinessGateFactory(timeout) {
        if (timeout === void 0) {
          timeout = 0;
        }
        var readinessTimeoutId = 0;
        var segments = new _events.default();
        segments.SDK_SEGMENTS_ARRIVED = Events.SDK_SEGMENTS_ARRIVED;
        var gate = ReadinessGateFactory(splits, segments);
        if (timeout > 0) {
          readinessTimeoutId = setTimeout(function() {
            gate.emit(Events.SDK_READY_TIMED_OUT, "Split SDK emitted SDK_READY_TIMED_OUT event.");
          }, timeout);
          gate.once(Events.SDK_READY, function() {
            return clearTimeout(readinessTimeoutId);
          });
        }
        gate.SDK_READY = Events.SDK_READY;
        gate.SDK_READY_FROM_CACHE = Events.SDK_READY_FROM_CACHE;
        gate.SDK_UPDATE = Events.SDK_UPDATE;
        gate.SDK_READY_TIMED_OUT = Events.SDK_READY_TIMED_OUT;
        refCount++;
        return {
          splits,
          segments,
          gate,
          destroy: function destroy() {
            segments.removeAllListeners();
            gate.removeAllListeners();
            clearTimeout(readinessTimeoutId);
            if (refCount > 0)
              refCount--;
            if (refCount === 0)
              splits.removeAllListeners();
          }
        };
      }
      return SDKReadinessGateFactory;
    }
    var _default = GateContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/language/node.js
var require_node4 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/language/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _default = "nodejs";
    exports.default = _default;
  }
});

// node_modules/ip/lib/ip.js
var require_ip = __commonJS({
  "node_modules/ip/lib/ip.js"(exports) {
    "use strict";
    var ip = exports;
    var Buffer2 = require("buffer").Buffer;
    var os = require("os");
    ip.toBuffer = function(ip2, buff, offset) {
      offset = ~~offset;
      var result;
      if (this.isV4Format(ip2)) {
        result = buff || new Buffer2(offset + 4);
        ip2.split(/\./g).map(function(byte) {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (this.isV6Format(ip2)) {
        var sections = ip2.split(":", 8);
        var i2;
        for (i2 = 0; i2 < sections.length; i2++) {
          var isv4 = this.isV4Format(sections[i2]);
          var v4Buffer;
          if (isv4) {
            v4Buffer = this.toBuffer(sections[i2]);
            sections[i2] = v4Buffer.slice(0, 2).toString("hex");
          }
          if (v4Buffer && ++i2 < 8) {
            sections.splice(i2, 0, v4Buffer.slice(2, 4).toString("hex"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++)
            ;
          var argv = [i2, 1];
          for (i2 = 9 - sections.length; i2 > 0; i2--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = buff || new Buffer2(offset + 16);
        for (i2 = 0; i2 < sections.length; i2++) {
          var word = parseInt(sections[i2], 16);
          result[offset++] = word >> 8 & 255;
          result[offset++] = word & 255;
        }
      }
      if (!result) {
        throw Error("Invalid ip address: " + ip2);
      }
      return result;
    };
    ip.toString = function(buff, offset, length) {
      offset = ~~offset;
      length = length || buff.length - offset;
      var result = [];
      if (length === 4) {
        for (var i2 = 0; i2 < length; i2++) {
          result.push(buff[offset + i2]);
        }
        result = result.join(".");
      } else if (length === 16) {
        for (var i2 = 0; i2 < length; i2 += 2) {
          result.push(buff.readUInt16BE(offset + i2).toString(16));
        }
        result = result.join(":");
        result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        result = result.replace(/:{3,4}/, "::");
      }
      return result;
    };
    var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
    var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
    ip.isV4Format = function(ip2) {
      return ipv4Regex.test(ip2);
    };
    ip.isV6Format = function(ip2) {
      return ipv6Regex.test(ip2);
    };
    function _normalizeFamily(family) {
      return family ? family.toLowerCase() : "ipv4";
    }
    ip.fromPrefixLen = function(prefixlen, family) {
      if (prefixlen > 32) {
        family = "ipv6";
      } else {
        family = _normalizeFamily(family);
      }
      var len = 4;
      if (family === "ipv6") {
        len = 16;
      }
      var buff = new Buffer2(len);
      for (var i2 = 0, n = buff.length; i2 < n; ++i2) {
        var bits = 8;
        if (prefixlen < 8) {
          bits = prefixlen;
        }
        prefixlen -= bits;
        buff[i2] = ~(255 >> bits) & 255;
      }
      return ip.toString(buff);
    };
    ip.mask = function(addr, mask) {
      addr = ip.toBuffer(addr);
      mask = ip.toBuffer(mask);
      var result = new Buffer2(Math.max(addr.length, mask.length));
      var i2 = 0;
      if (addr.length === mask.length) {
        for (i2 = 0; i2 < addr.length; i2++) {
          result[i2] = addr[i2] & mask[i2];
        }
      } else if (mask.length === 4) {
        for (i2 = 0; i2 < mask.length; i2++) {
          result[i2] = addr[addr.length - 4 + i2] & mask[i2];
        }
      } else {
        for (var i2 = 0; i2 < result.length - 6; i2++) {
          result[i2] = 0;
        }
        result[10] = 255;
        result[11] = 255;
        for (i2 = 0; i2 < addr.length; i2++) {
          result[i2 + 12] = addr[i2] & mask[i2 + 12];
        }
        i2 = i2 + 12;
      }
      for (; i2 < result.length; i2++)
        result[i2] = 0;
      return ip.toString(result);
    };
    ip.cidr = function(cidrString) {
      var cidrParts = cidrString.split("/");
      var addr = cidrParts[0];
      if (cidrParts.length !== 2)
        throw new Error("invalid CIDR subnet: " + addr);
      var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.mask(addr, mask);
    };
    ip.subnet = function(addr, mask) {
      var networkAddress = ip.toLong(ip.mask(addr, mask));
      var maskBuffer = ip.toBuffer(mask);
      var maskLength = 0;
      for (var i2 = 0; i2 < maskBuffer.length; i2++) {
        if (maskBuffer[i2] === 255) {
          maskLength += 8;
        } else {
          var octet = maskBuffer[i2] & 255;
          while (octet) {
            octet = octet << 1 & 255;
            maskLength++;
          }
        }
      }
      var numberOfAddresses = Math.pow(2, 32 - maskLength);
      return {
        networkAddress: ip.fromLong(networkAddress),
        firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
        lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
        broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
        subnetMask: mask,
        subnetMaskLength: maskLength,
        numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
        length: numberOfAddresses,
        contains: function(other) {
          return networkAddress === ip.toLong(ip.mask(other, mask));
        }
      };
    };
    ip.cidrSubnet = function(cidrString) {
      var cidrParts = cidrString.split("/");
      var addr = cidrParts[0];
      if (cidrParts.length !== 2)
        throw new Error("invalid CIDR subnet: " + addr);
      var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.subnet(addr, mask);
    };
    ip.not = function(addr) {
      var buff = ip.toBuffer(addr);
      for (var i2 = 0; i2 < buff.length; i2++) {
        buff[i2] = 255 ^ buff[i2];
      }
      return ip.toString(buff);
    };
    ip.or = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (var i2 = 0; i2 < a.length; ++i2) {
          a[i2] |= b[i2];
        }
        return ip.toString(a);
      } else {
        var buff = a;
        var other = b;
        if (b.length > a.length) {
          buff = b;
          other = a;
        }
        var offset = buff.length - other.length;
        for (var i2 = offset; i2 < buff.length; ++i2) {
          buff[i2] |= other[i2 - offset];
        }
        return ip.toString(buff);
      }
    };
    ip.isEqual = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (var i2 = 0; i2 < a.length; i2++) {
          if (a[i2] !== b[i2])
            return false;
        }
        return true;
      }
      if (b.length === 4) {
        var t2 = b;
        b = a;
        a = t2;
      }
      for (var i2 = 0; i2 < 10; i2++) {
        if (b[i2] !== 0)
          return false;
      }
      var word = b.readUInt16BE(10);
      if (word !== 0 && word !== 65535)
        return false;
      for (var i2 = 0; i2 < 4; i2++) {
        if (a[i2] !== b[i2 + 12])
          return false;
      }
      return true;
    };
    ip.isPrivate = function(addr) {
      return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.isPublic = function(addr) {
      return !ip.isPrivate(addr);
    };
    ip.isLoopback = function(addr) {
      return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.loopback = function(family) {
      family = _normalizeFamily(family);
      if (family !== "ipv4" && family !== "ipv6") {
        throw new Error("family must be ipv4 or ipv6");
      }
      return family === "ipv4" ? "127.0.0.1" : "fe80::1";
    };
    ip.address = function(name, family) {
      var interfaces = os.networkInterfaces();
      var all;
      family = _normalizeFamily(family);
      if (name && name !== "private" && name !== "public") {
        var res = interfaces[name].filter(function(details) {
          var itemFamily = details.family.toLowerCase();
          return itemFamily === family;
        });
        if (res.length === 0)
          return void 0;
        return res[0].address;
      }
      var all = Object.keys(interfaces).map(function(nic) {
        var addresses = interfaces[nic].filter(function(details) {
          details.family = details.family.toLowerCase();
          if (details.family !== family || ip.isLoopback(details.address)) {
            return false;
          } else if (!name) {
            return true;
          }
          return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
        });
        return addresses.length ? addresses[0].address : void 0;
      }).filter(Boolean);
      return !all.length ? ip.loopback(family) : all[0];
    };
    ip.toLong = function(ip2) {
      var ipl = 0;
      ip2.split(".").forEach(function(octet) {
        ipl <<= 8;
        ipl += parseInt(octet);
      });
      return ipl >>> 0;
    };
    ip.fromLong = function(ipl) {
      return (ipl >>> 24) + "." + (ipl >> 16 & 255) + "." + (ipl >> 8 & 255) + "." + (ipl & 255);
    };
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/runtime/node.js
var require_node5 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/runtime/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = generateRuntimeSettings;
    var _os = _interopRequireDefault(require("os"));
    var _ip = _interopRequireDefault(require_ip());
    var _constants = require_constants();
    function generateRuntimeSettings(isIPAddressesEnabled, isConsumerMode) {
      var ip = _ip.default.address() || (isConsumerMode ? _constants.UNKNOWN : false);
      var hostname = _os.default.hostname() || (isConsumerMode ? _constants.UNKNOWN : false);
      if (!isIPAddressesEnabled) {
        ip = hostname = isConsumerMode ? _constants.NA : false;
      }
      return {
        ip,
        hostname
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/defaults/node.js
var require_node6 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/defaults/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _default = {
      core: {
        IPAddressesEnabled: true
      },
      startup: {
        requestTimeoutBeforeReady: 15,
        retriesOnFailureBeforeReady: 1,
        readyTimeout: 15,
        eventsFirstPushWindow: 0
      },
      scheduler: {
        featuresRefreshRate: 5,
        impressionsRefreshRate: 300
      },
      features: ".split"
    };
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/storage/node.js
var require_node7 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/storage/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _constants = require_constants();
    var ParseStorageSettings = function ParseStorageSettings2(settings) {
      var mode = settings.mode, _settings$storage = settings.storage, type = _settings$storage.type, _settings$storage$opt = _settings$storage.options, options = _settings$storage$opt === void 0 ? {} : _settings$storage$opt, prefix = _settings$storage.prefix;
      if (prefix) {
        prefix += ".SPLITIO";
      } else {
        prefix = "SPLITIO";
      }
      if (mode === _constants.LOCALHOST_MODE)
        return {
          type: _constants.STORAGE_MEMORY,
          prefix
        };
      switch (type) {
        case _constants.STORAGE_REDIS: {
          var host = options.host, port = options.port, db = options.db, pass = options.pass, url = options.url, connectionTimeout = options.connectionTimeout, operationTimeout = options.operationTimeout;
          if (process.env.REDIS_HOST)
            host = process.env.REDIS_HOST;
          if (process.env.REDIS_PORT)
            port = process.env.REDIS_PORT;
          if (process.env.REDIS_DB)
            db = process.env.REDIS_DB;
          if (process.env.REDIS_PASS)
            pass = process.env.REDIS_PASS;
          if (process.env.REDIS_URL)
            url = process.env.REDIS_URL;
          var newOpts = {
            connectionTimeout,
            operationTimeout
          };
          if (url) {
            newOpts.url = url;
          } else {
            newOpts.host = host;
            newOpts.port = port;
            newOpts.db = db;
            newOpts.pass = pass;
          }
          return {
            type,
            prefix,
            options: newOpts
          };
        }
        case _constants.STORAGE_MEMORY:
        default: {
          return {
            type: _constants.STORAGE_MEMORY,
            prefix
          };
        }
      }
    };
    var _default = ParseStorageSettings;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/integrations/node.js
var require_node8 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/integrations/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var validateNodeIntegrationsSettings = function validateNodeIntegrationsSettings2() {
      return [];
    };
    var _default = validateNodeIntegrationsSettings;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/mode.js
var require_mode = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/mode.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _constants = require_constants();
    function mode(key2, mode2) {
      if (key2 === "localhost")
        return _constants.LOCALHOST_MODE;
      if ([_constants.STANDALONE_MODE, _constants.PRODUCER_MODE, _constants.CONSUMER_MODE].indexOf(mode2) === -1)
        throw Error("Invalid mode provided");
      return mode2;
    }
    var _default = mode;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/inputValidation/splitFilters.js
var require_splitFilters = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/inputValidation/splitFilters.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = validateSplitFilters;
    var _constants = require_constants();
    var _splits = require_splits();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-settings");
    function validateFilterType(filterType) {
      return _constants.FILTERS_METADATA.some(function(filterMetadata) {
        return filterMetadata.type === filterType;
      });
    }
    function validateSplitFilter(type, values, maxLength) {
      var result = (0, _splits.validateSplits)(values, "settings", type + " filter", type + " filter value");
      if (result) {
        if (result.length > maxLength)
          throw new Error(maxLength + " unique values can be specified at most for '" + type + "' filter. You passed " + result.length + ". Please consider reducing the amount or using other filter.");
        result.sort();
      }
      return result || [];
    }
    function queryStringBuilder(groupedFilters) {
      var queryParams = [];
      _constants.FILTERS_METADATA.forEach(function(_ref) {
        var type = _ref.type, queryParam = _ref.queryParam;
        var filter = groupedFilters[type];
        if (filter.length > 0)
          queryParams.push(queryParam + filter.map(function(value) {
            return encodeURIComponent(value);
          }).join(","));
      });
      return queryParams.length > 0 ? "&" + queryParams.join("&") : null;
    }
    function validateSplitFilters(splitFilters, mode) {
      var res = {
        validFilters: [],
        queryString: null,
        groupedFilters: {
          byName: [],
          byPrefix: []
        }
      };
      if (!splitFilters)
        return res;
      if (mode !== _constants.STANDALONE_MODE) {
        log.warn("split filters have been configured but will have no effect if mode is not '" + _constants.STANDALONE_MODE + "', since synchronization is being deferred to an external tool.");
        return res;
      }
      if (!Array.isArray(splitFilters) || splitFilters.length === 0) {
        log.warn("splitFilters configuration must be a non-empty array of filter objects.");
        return res;
      }
      res.validFilters = splitFilters.filter(function(filter, index) {
        if (filter && validateFilterType(filter.type) && Array.isArray(filter.values)) {
          res.groupedFilters[filter.type] = res.groupedFilters[filter.type].concat(filter.values);
          return true;
        } else {
          log.warn("split filter at position '" + index + "' is invalid. It must be an object with a valid filter type ('byName' or 'byPrefix') and a list of 'values'.");
        }
        return false;
      });
      _constants.FILTERS_METADATA.forEach(function(_ref2) {
        var type = _ref2.type, maxLength = _ref2.maxLength;
        if (res.groupedFilters[type].length > 0)
          res.groupedFilters[type] = validateSplitFilter(type, res.groupedFilters[type], maxLength);
      });
      res.queryString = queryStringBuilder(res.groupedFilters);
      log.debug("splits filtering criteria is '" + res.queryString + "'.");
      return res;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/impressionsMode.js
var require_impressionsMode = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/impressionsMode.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _constants = require_constants();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-settings");
    function validImpressionsMode(impressionsMode) {
      impressionsMode = impressionsMode.toUpperCase();
      if ([_constants.DEBUG, _constants.OPTIMIZED].indexOf(impressionsMode) === -1) {
        log.error("You passed an invalid impressionsMode, impressionsMode should be one of the following values: '" + _constants.DEBUG + "' or '" + _constants.OPTIMIZED + "'. Defaulting to '" + _constants.OPTIMIZED + "' mode.");
        impressionsMode = _constants.OPTIMIZED;
      }
      return impressionsMode;
    }
    var _default = validImpressionsMode;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/settings/index.js
var require_settings = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/settings/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _lang = require_lang();
    var _language = _interopRequireDefault(require_node4());
    var _runtime = _interopRequireDefault(require_node5());
    var _defaults = _interopRequireDefault(require_node6());
    var _storage = _interopRequireDefault(require_node7());
    var _integrations = _interopRequireDefault(require_node8());
    var _mode = _interopRequireDefault(require_mode());
    var _splitFilters = _interopRequireDefault(require_splitFilters());
    var _logger = require_logger();
    var _constants = require_constants();
    var _impressionsMode = _interopRequireDefault(require_impressionsMode());
    var version = "10.17.3";
    var eventsEndpointMatcher = /^\/(testImpressions|metrics|events)/;
    var authEndpointMatcher = /^\/v2\/auth/;
    var streamingEndpointMatcher = /^\/(sse|event-stream)/;
    var base2 = {
      mode: _constants.STANDALONE_MODE,
      core: {
        authorizationKey: void 0,
        key: void 0,
        trafficType: void 0,
        labelsEnabled: true,
        IPAddressesEnabled: void 0
      },
      scheduler: {
        featuresRefreshRate: 30,
        segmentsRefreshRate: 60,
        metricsRefreshRate: 120,
        impressionsRefreshRate: 60,
        offlineRefreshRate: 15,
        eventsPushRate: 60,
        eventsQueueSize: 500,
        pushRetryBackoffBase: 1
      },
      urls: {
        sdk: "https://sdk.split.io/api",
        events: "https://events.split.io/api",
        auth: "https://auth.split.io/api",
        streaming: "https://streaming.split.io"
      },
      storage: {
        type: _constants.STORAGE_MEMORY
      },
      debug: void 0,
      impressionListener: void 0,
      version: _language.default + "-" + version,
      integrations: void 0,
      streamingEnabled: true,
      sync: {
        splitFilters: void 0,
        impressionsMode: _constants.OPTIMIZED
      }
    };
    function fromSecondsToMillis(n) {
      return Math.round(n * 1e3);
    }
    function setupLogger(debugValue) {
      if (typeof debugValue === "boolean") {
        if (debugValue) {
          _logger.API.enable();
        } else {
          _logger.API.disable();
        }
      } else if (typeof debugValue === "string") {
        _logger.API.setLogLevel(debugValue);
      }
    }
    function defaults(custom) {
      var withDefaults = (0, _lang.merge)({}, base2, _defaults.default, custom);
      withDefaults.scheduler.featuresRefreshRate = fromSecondsToMillis(withDefaults.scheduler.featuresRefreshRate);
      withDefaults.scheduler.segmentsRefreshRate = fromSecondsToMillis(withDefaults.scheduler.segmentsRefreshRate);
      withDefaults.scheduler.metricsRefreshRate = fromSecondsToMillis(withDefaults.scheduler.metricsRefreshRate);
      withDefaults.scheduler.impressionsRefreshRate = fromSecondsToMillis(withDefaults.scheduler.impressionsRefreshRate);
      withDefaults.scheduler.offlineRefreshRate = fromSecondsToMillis(withDefaults.scheduler.offlineRefreshRate);
      withDefaults.scheduler.eventsPushRate = fromSecondsToMillis(withDefaults.scheduler.eventsPushRate);
      withDefaults.startup.requestTimeoutBeforeReady = fromSecondsToMillis(withDefaults.startup.requestTimeoutBeforeReady);
      withDefaults.startup.readyTimeout = fromSecondsToMillis(withDefaults.startup.readyTimeout);
      withDefaults.startup.eventsFirstPushWindow = fromSecondsToMillis(withDefaults.startup.eventsFirstPushWindow);
      withDefaults.mode = (0, _mode.default)(withDefaults.core.authorizationKey, withDefaults.mode);
      withDefaults.storage = (0, _storage.default)(withDefaults);
      setupLogger(withDefaults.debug);
      withDefaults.runtime = (0, _runtime.default)(withDefaults.core.IPAddressesEnabled, withDefaults.mode === _constants.CONSUMER_MODE);
      withDefaults.integrations = (0, _integrations.default)(withDefaults);
      if (withDefaults.streamingEnabled !== false) {
        withDefaults.streamingEnabled = true;
        withDefaults.scheduler.pushRetryBackoffBase = fromSecondsToMillis(withDefaults.scheduler.pushRetryBackoffBase);
      }
      var splitFiltersValidation = (0, _splitFilters.default)(withDefaults.sync.splitFilters, withDefaults.mode);
      withDefaults.sync.splitFilters = splitFiltersValidation.validFilters;
      withDefaults.sync.__splitFiltersValidation = splitFiltersValidation;
      withDefaults.sync.impressionsMode = (0, _impressionsMode.default)(withDefaults.sync.impressionsMode);
      return withDefaults;
    }
    var proto = {
      url: function url(target) {
        if (eventsEndpointMatcher.test(target)) {
          return "" + this.urls.events + target;
        }
        if (authEndpointMatcher.test(target)) {
          return "" + this.urls.auth + target;
        }
        if (streamingEndpointMatcher.test(target)) {
          return "" + this.urls.streaming + target;
        }
        return "" + this.urls.sdk + target;
      },
      overrideKeyAndTT: function overrideKeyAndTT(key2, trafficType) {
        return (0, _objectAssign.default)(Object.create(proto), this, {
          core: (0, _objectAssign.default)({}, this.core, {
            key: key2,
            trafficType
          })
        });
      }
    };
    var SettingsFactory = function SettingsFactory2(settings) {
      return (0, _objectAssign.default)(Object.create(proto), defaults(settings));
    };
    var _default = SettingsFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/context/constants.js
var require_constants2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/context/constants.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = exports.IMPRESSIONS_COUNTER = exports.STORAGE = exports.STATUS_MANAGER = exports.SETTINGS = exports.READY_FROM_CACHE = exports.READY = exports.READINESS = exports.PRODUCER = exports.MY_SEGMENTS_CHANGE_WORKER = exports.INTEGRATIONS_MANAGER = exports.HAS_TIMEDOUT = exports.EVENTS = exports.DESTROYED = exports.COLLECTORS = void 0;
    var COLLECTORS = "metrics_collectors";
    exports.COLLECTORS = COLLECTORS;
    var DESTROYED = "is_destroyed";
    exports.DESTROYED = DESTROYED;
    var EVENTS = "events_publisher";
    exports.EVENTS = EVENTS;
    var HAS_TIMEDOUT = "has_timedout";
    exports.HAS_TIMEDOUT = HAS_TIMEDOUT;
    var INTEGRATIONS_MANAGER = "integrations_manager";
    exports.INTEGRATIONS_MANAGER = INTEGRATIONS_MANAGER;
    var MY_SEGMENTS_CHANGE_WORKER = "my_segments_change_worker";
    exports.MY_SEGMENTS_CHANGE_WORKER = MY_SEGMENTS_CHANGE_WORKER;
    var PRODUCER = "producer";
    exports.PRODUCER = PRODUCER;
    var READINESS = "readiness_gate";
    exports.READINESS = READINESS;
    var READY = "is_ready";
    exports.READY = READY;
    var READY_FROM_CACHE = "is_ready_from_cache";
    exports.READY_FROM_CACHE = READY_FROM_CACHE;
    var SETTINGS = "settings";
    exports.SETTINGS = SETTINGS;
    var STATUS_MANAGER = "status_manager";
    exports.STATUS_MANAGER = STATUS_MANAGER;
    var STORAGE = "storage";
    exports.STORAGE = STORAGE;
    var IMPRESSIONS_COUNTER = "impressions_counter";
    exports.IMPRESSIONS_COUNTER = IMPRESSIONS_COUNTER;
    var _default = {
      COLLECTORS,
      DESTROYED,
      EVENTS,
      HAS_TIMEDOUT,
      INTEGRATIONS_MANAGER,
      MY_SEGMENTS_CHANGE_WORKER,
      PRODUCER,
      READINESS,
      READY,
      READY_FROM_CACHE,
      SETTINGS,
      STATUS_MANAGER,
      STORAGE,
      IMPRESSIONS_COUNTER
    };
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/context/index.js
var require_context = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/context/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _thenable = _interopRequireDefault(require_thenable());
    var _constants = _interopRequireDefault(require_constants2());
    var Context = /* @__PURE__ */ function() {
      function Context2() {
        this._map = {};
        this.constants = _constants.default;
      }
      var _proto = Context2.prototype;
      _proto.get = function get2(name, flagCheck) {
        if (flagCheck === void 0) {
          flagCheck = false;
        }
        if (typeof name !== "string" || typeof name === "string" && !name.length)
          return;
        var item = this._map[name];
        if (item !== void 0) {
          return item;
        } else if (!flagCheck) {
          var resolve2;
          var promise = new Promise(function(res) {
            return resolve2 = res;
          });
          promise.manualResolve = resolve2;
          this._map[name] = promise;
          return promise;
        }
      };
      _proto.getAll = function getAll() {
        return (0, _objectAssign.default)({}, this._map);
      };
      _proto.put = function put(name, item) {
        var _this = this;
        if (typeof name !== "string" || typeof name === "string" && !name.length || item === void 0)
          return false;
        var existingItem = this._map[name];
        if (existingItem !== void 0 && typeof existingItem.manualResolve !== "function")
          return false;
        if ((0, _thenable.default)(existingItem) && existingItem.manualResolve)
          existingItem.manualResolve(item);
        if ((0, _thenable.default)(item)) {
          item.then(function(item2) {
            _this._map[name] = item2;
            return item2;
          }).catch(function(err) {
            _this._map[name] = void 0;
            return err;
          });
        }
        this._map[name] = item;
        return true;
      };
      return Context2;
    }();
    var _default = Context;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/key/parser.js
var require_parser2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/key/parser.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _default = function _default2(key2) {
      if ((0, _lang.isObject)(key2)) {
        return {
          matchingKey: key2.matchingKey,
          bucketingKey: key2.bucketingKey
        };
      } else {
        return {
          matchingKey: key2,
          bucketingKey: key2
        };
      }
    };
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/now/node.js
var require_node9 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/now/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = now;
    function now() {
      var time = process.hrtime();
      return time[0] * 1e3 + time[1] * 1e-6;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/timeTracker/timer.js
var require_timer = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/timeTracker/timer.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _now = _interopRequireDefault(require_node9());
    function start() {
      var st = (0, _now.default)();
      return function stop() {
        return Math.round((0, _now.default)() - st);
      };
    }
    var _default = start;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/timeTracker/index.js
var require_timeTracker = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/timeTracker/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _LoggerFactory = require_LoggerFactory();
    var _timer = _interopRequireDefault(require_timer());
    var _thenable = _interopRequireDefault(require_thenable());
    var _CALLBACKS;
    var logger = new _LoggerFactory.Logger("[TIME TRACKER]", {
      showLevel: false
    });
    var timers = {};
    var CONSTANTS = {
      SDK_READY: "Getting ready - Split SDK",
      SDK_GET_TREATMENT: "SDK - Get Treatment",
      SDK_GET_TREATMENTS: "SDK - Get Treatments",
      SDK_GET_TREATMENT_WITH_CONFIG: "SDK - Get Treatment with config",
      SDK_GET_TREATMENTS_WITH_CONFIG: "SDK - Get Treatments with config",
      SPLITS_READY: "Getting ready - Splits",
      SEGMENTS_READY: "Getting ready - Segments",
      METRICS_PUSH: "Pushing - Metrics",
      IMPRESSIONS_PUSH: "Pushing - Impressions",
      EVENTS_PUSH: "Pushing - Events",
      MY_SEGMENTS_FETCH: "Fetching - My Segments",
      SEGMENTS_FETCH: "Fetching - Segments",
      SPLITS_FETCH: "Fetching - Splits"
    };
    var CALLBACKS = (_CALLBACKS = {}, _CALLBACKS[CONSTANTS.SDK_READY] = {
      collector: "client",
      method: "ready"
    }, _CALLBACKS[CONSTANTS.SDK_GET_TREATMENT] = {
      collector: "client",
      method: "getTreatment"
    }, _CALLBACKS[CONSTANTS.SDK_GET_TREATMENTS] = {
      collector: "client",
      method: "getTreatments"
    }, _CALLBACKS[CONSTANTS.SDK_GET_TREATMENT_WITH_CONFIG] = {
      collector: "client",
      method: "getTreatmentWithConfig"
    }, _CALLBACKS[CONSTANTS.SDK_GET_TREATMENTS_WITH_CONFIG] = {
      collector: "client",
      method: "getTreatmentsWithConfig"
    }, _CALLBACKS[CONSTANTS.MY_SEGMENTS_FETCH] = {
      collector: "mySegments",
      method: "latency"
    }, _CALLBACKS[CONSTANTS.SEGMENTS_FETCH] = {
      collector: "segmentChanges",
      method: "latency"
    }, _CALLBACKS[CONSTANTS.SPLITS_FETCH] = {
      collector: "splitChanges",
      method: "latency"
    }, _CALLBACKS);
    var generateTimerKey = function generateTimerKey2(task, modifier) {
      return typeof modifier === "string" ? task + modifier : task;
    };
    var getCollectorForTask = function getCollectorForTask2(task, collectors) {
      var callbackData = CALLBACKS[task];
      if (callbackData && collectors)
        return collectors[callbackData.collector];
      return false;
    };
    var getCallbackForTask = function getCallbackForTask2(task, collector) {
      var callbackData = CALLBACKS[task];
      if (callbackData && collector)
        return collector[callbackData.method];
      return false;
    };
    var TrackerAPI = {
      __attachToPromise: function __attachToPromise(promise, task, collector, modifier) {
        var _this = this;
        return promise.then(function(resp) {
          _this.stop(task, modifier);
          if (collector && collector.count)
            collector.count(resp.status);
          return resp;
        }).catch(function(err) {
          _this.stop(task, modifier);
          if (collector && collector.countException)
            collector.countException();
          throw err;
        });
      },
      start: function start(task, collectors, promise) {
        var taskUniqueId = (0, _lang.uniqueId)();
        var taskCollector = getCollectorForTask(task, collectors);
        var result;
        if ((0, _thenable.default)(promise)) {
          result = this.__attachToPromise(promise, task, taskCollector, taskUniqueId);
        } else {
          result = this.stop.bind(this, task, taskUniqueId);
          if (CALLBACKS[task] && !taskCollector) {
            result.setCollectorForTask = this.setCollectorForTask.bind(this, task, taskUniqueId);
          }
        }
        var trackingKey = generateTimerKey(task, taskUniqueId);
        var cb = getCallbackForTask(task, taskCollector);
        timers[trackingKey] = {
          cb,
          timer: (0, _timer.default)()
        };
        return result;
      },
      setCollectorForTask: function setCollectorForTask(task, taskUniqueId, collectors) {
        var taskCollector = getCollectorForTask(task, collectors);
        if (taskCollector) {
          var trackingKey = generateTimerKey(task, taskUniqueId);
          timers[trackingKey].cb = getCallbackForTask(task, taskCollector);
        }
      },
      stop: function stop(task, modifier) {
        var timerName = generateTimerKey(task, modifier);
        var timerData = timers[timerName];
        if (timerData) {
          var et = timerData.timer();
          logger.debug("[" + task + "] took " + et + "ms to finish.");
          if (timerData.cb) {
            timerData.cb(et);
          }
          delete timers[timerName];
          return et;
        }
      },
      TaskNames: CONSTANTS
    };
    var _default = TrackerAPI;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/types.js
var require_types = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.matcherTypesMapper = matcherTypesMapper;
    exports.matcherDataTypes = exports.matcherTypes = void 0;
    var matcherTypes = {
      UNDEFINED: 0,
      ALL_KEYS: 1,
      IN_SEGMENT: 2,
      WHITELIST: 3,
      EQUAL_TO: 4,
      GREATER_THAN_OR_EQUAL_TO: 5,
      LESS_THAN_OR_EQUAL_TO: 6,
      BETWEEN: 7,
      EQUAL_TO_SET: 8,
      CONTAINS_ANY_OF_SET: 9,
      CONTAINS_ALL_OF_SET: 10,
      PART_OF_SET: 11,
      ENDS_WITH: 12,
      STARTS_WITH: 13,
      CONTAINS_STRING: 14,
      IN_SPLIT_TREATMENT: 15,
      EQUAL_TO_BOOLEAN: 16,
      MATCHES_STRING: 17
    };
    exports.matcherTypes = matcherTypes;
    var matcherDataTypes = {
      BOOLEAN: "BOOLEAN",
      STRING: "STRING",
      NUMBER: "NUMBER",
      SET: "SET",
      DATETIME: "DATETIME",
      NOT_SPECIFIED: "NOT_SPECIFIED"
    };
    exports.matcherDataTypes = matcherDataTypes;
    function matcherTypesMapper(matcherType) {
      var type = matcherTypes[matcherType];
      if (type)
        return type;
      else
        return matcherTypes.UNDEFINED;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/transforms/segment.js
var require_segment = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/transforms/segment.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function transform(segment) {
      if (segment === void 0) {
        segment = {};
      }
      return segment.segmentName;
    }
    var _default = transform;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/transforms/whitelist.js
var require_whitelist = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/transforms/whitelist.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _Sets = require_Sets();
    function transform(whitelistObject) {
      return new _Sets._Set(whitelistObject.whitelist);
    }
    var _default = transform;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/transforms/set.js
var require_set = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/transforms/set.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function transform(whitelistObject) {
      return whitelistObject.whitelist;
    }
    var _default = transform;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/transforms/unaryNumeric.js
var require_unaryNumeric = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/transforms/unaryNumeric.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function transform(unaryNumericObject) {
      return unaryNumericObject.value;
    }
    var _default = transform;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/convertions/index.js
var require_convertions = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/convertions/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.zeroSinceHH = zeroSinceHH;
    exports.zeroSinceSS = zeroSinceSS;
    function zeroSinceHH(millisSinceEpoch) {
      return new Date(millisSinceEpoch).setUTCHours(0, 0, 0, 0);
    }
    function zeroSinceSS(millisSinceEpoch) {
      return new Date(millisSinceEpoch).setUTCSeconds(0, 0);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/transforms/matchers.js
var require_matchers = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/transforms/matchers.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _types = require_types();
    var _segment = _interopRequireDefault(require_segment());
    var _whitelist = _interopRequireDefault(require_whitelist());
    var _set = _interopRequireDefault(require_set());
    var _unaryNumeric = _interopRequireDefault(require_unaryNumeric());
    var _convertions = require_convertions();
    function transform(matchers) {
      var parsedMatchers = matchers.map(function(matcher) {
        var matcherType = matcher.matcherType, negate = matcher.negate, keySelector = matcher.keySelector, segmentObject = matcher.userDefinedSegmentMatcherData, whitelistObject = matcher.whitelistMatcherData, unaryNumericObject = matcher.unaryNumericMatcherData, betweenObject = matcher.betweenMatcherData, dependencyObject = matcher.dependencyMatcherData, booleanMatcherData = matcher.booleanMatcherData, stringMatcherData = matcher.stringMatcherData;
        var attribute = keySelector && keySelector.attribute;
        var type = (0, _types.matcherTypesMapper)(matcherType);
        var dataType = _types.matcherDataTypes.STRING;
        var value = void 0;
        if (type === _types.matcherTypes.IN_SEGMENT) {
          value = (0, _segment.default)(segmentObject);
        } else if (type === _types.matcherTypes.WHITELIST) {
          value = (0, _whitelist.default)(whitelistObject);
        } else if (type === _types.matcherTypes.EQUAL_TO) {
          value = (0, _unaryNumeric.default)(unaryNumericObject);
          dataType = _types.matcherDataTypes.NUMBER;
          if (unaryNumericObject.dataType === "DATETIME") {
            value = (0, _convertions.zeroSinceHH)(value);
            dataType = _types.matcherDataTypes.DATETIME;
          }
        } else if (type === _types.matcherTypes.GREATER_THAN_OR_EQUAL_TO || type === _types.matcherTypes.LESS_THAN_OR_EQUAL_TO) {
          value = (0, _unaryNumeric.default)(unaryNumericObject);
          dataType = _types.matcherDataTypes.NUMBER;
          if (unaryNumericObject.dataType === "DATETIME") {
            value = (0, _convertions.zeroSinceSS)(value);
            dataType = _types.matcherDataTypes.DATETIME;
          }
        } else if (type === _types.matcherTypes.BETWEEN) {
          value = betweenObject;
          dataType = _types.matcherDataTypes.NUMBER;
          if (betweenObject.dataType === "DATETIME") {
            value.start = (0, _convertions.zeroSinceSS)(value.start);
            value.end = (0, _convertions.zeroSinceSS)(value.end);
            dataType = _types.matcherDataTypes.DATETIME;
          }
        } else if (type === _types.matcherTypes.EQUAL_TO_SET || type === _types.matcherTypes.CONTAINS_ANY_OF_SET || type === _types.matcherTypes.CONTAINS_ALL_OF_SET || type === _types.matcherTypes.PART_OF_SET) {
          value = (0, _set.default)(whitelistObject);
          dataType = _types.matcherDataTypes.SET;
        } else if (type === _types.matcherTypes.STARTS_WITH || type === _types.matcherTypes.ENDS_WITH || type === _types.matcherTypes.CONTAINS_STRING) {
          value = (0, _set.default)(whitelistObject);
        } else if (type === _types.matcherTypes.IN_SPLIT_TREATMENT) {
          value = dependencyObject;
          dataType = _types.matcherDataTypes.NOT_SPECIFIED;
        } else if (type === _types.matcherTypes.EQUAL_TO_BOOLEAN) {
          dataType = _types.matcherDataTypes.BOOLEAN;
          value = booleanMatcherData;
        } else if (type === _types.matcherTypes.MATCHES_STRING) {
          value = stringMatcherData;
        }
        return {
          attribute,
          negate,
          type,
          value,
          dataType
        };
      });
      if ((0, _lang.findIndex)(parsedMatchers, function(m2) {
        return m2.type === _types.matcherTypes.UNDEFINED;
      }) === -1) {
        return parsedMatchers;
      } else {
        return [];
      }
    }
    var _default = transform;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/treatments/index.js
var require_treatments = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/treatments/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    function Treatments(ranges, treatments) {
      if (!(this instanceof Treatments)) {
        return new Treatments(ranges, treatments);
      }
      if (ranges[ranges.length - 1] !== 100) {
        throw new RangeError("Provided invalid dataset as input");
      }
      this._ranges = ranges;
      this._treatments = treatments;
    }
    Treatments.parse = function parse(data) {
      var _data$reduce = data.reduce(function(accum, value) {
        var size = value.size, treatment = value.treatment;
        accum.ranges.push(accum.inc += size);
        accum.treatments.push(treatment);
        return accum;
      }, {
        inc: 0,
        ranges: [],
        treatments: []
      }), ranges = _data$reduce.ranges, treatments = _data$reduce.treatments;
      return new Treatments(ranges, treatments);
    };
    Treatments.prototype.getTreatmentFor = function getTreatmentFor(x2) {
      if (x2 < 0 || x2 > 100) {
        throw new RangeError("Please provide a value between 0 and 100");
      }
      var index = (0, _lang.findIndex)(this._ranges, function(range) {
        return x2 <= range;
      });
      var treatment = this._treatments[index];
      return treatment;
    };
    var _default = Treatments;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/all.js
var require_all = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/all.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function allMatcher(runtimeAttr) {
      log.debug("[allMatcher] is always true");
      return runtimeAttr != null;
    }
    function allMatcherContext() {
      return allMatcher;
    }
    var _default = allMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/segment.js
var require_segment2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/segment.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function matcherSegmentContext(segmentName, storage) {
      function segmentMatcher(key2) {
        var isInSegment = storage.segments.isInSegment(segmentName, key2);
        if ((0, _thenable.default)(isInSegment)) {
          isInSegment.then(function(result) {
            log.debug("[asyncSegmentMatcher] evaluated " + segmentName + " / " + key2 + " => " + isInSegment);
            return result;
          });
        } else {
          log.debug("[segmentMatcher] evaluated " + segmentName + " / " + key2 + " => " + isInSegment);
        }
        return isInSegment;
      }
      return segmentMatcher;
    }
    var _default = matcherSegmentContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/whitelist.js
var require_whitelist2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/whitelist.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _Sets = require_Sets();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function whitelistMatcherContext(ruleAttr) {
      return function whitelistMatcher(runtimeAttr) {
        var isInWhitelist = ruleAttr.has(runtimeAttr);
        log.debug("[whitelistMatcher] evaluated " + runtimeAttr + " in [" + (0, _Sets.setToArray)(ruleAttr).join(",") + "] => " + isInWhitelist);
        return isInWhitelist;
      };
    }
    var _default = whitelistMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/eq.js
var require_eq = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/eq.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function equalToMatcherContext(ruleAttr) {
      return function equalToMatcher(runtimeAttr) {
        var isEqual = runtimeAttr === ruleAttr;
        log.debug("[equalToMatcher] is " + runtimeAttr + " equal to " + ruleAttr + "? " + isEqual);
        return isEqual;
      };
    }
    var _default = equalToMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/gte.js
var require_gte = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/gte.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function greaterThanEqualMatcherContext(ruleAttr) {
      return function greaterThanEqualMatcher(runtimeAttr) {
        var isGreaterEqualThan = runtimeAttr >= ruleAttr;
        log.debug("[greaterThanEqualMatcher] is " + runtimeAttr + " greater than " + ruleAttr + "? " + isGreaterEqualThan);
        return isGreaterEqualThan;
      };
    }
    var _default = greaterThanEqualMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/lte.js
var require_lte = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/lte.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function lessThanEqualMatcherContext(ruleAttr) {
      return function lessThanEqualMatcher(runtimeAttr) {
        var isLessEqualThan = runtimeAttr <= ruleAttr;
        log.debug("[lessThanEqualMatcher] is " + runtimeAttr + " less than " + ruleAttr + "? " + isLessEqualThan);
        return isLessEqualThan;
      };
    }
    var _default = lessThanEqualMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/between.js
var require_between = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/between.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function betweenMatcherContext(ruleVO) {
      return function betweenMatcher(runtimeAttr) {
        var isBetween = runtimeAttr >= ruleVO.start && runtimeAttr <= ruleVO.end;
        log.debug("[betweenMatcher] is " + runtimeAttr + " between " + ruleVO.start + " and " + ruleVO.end + "? " + isBetween);
        return isBetween;
      };
    }
    var _default = betweenMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/eq_set.js
var require_eq_set = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/eq_set.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-engine:matcher");
    function equalToSetMatcherContext(ruleAttr) {
      return function equalToSetMatcher(runtimeAttr) {
        var isEqual = runtimeAttr.length === ruleAttr.length;
        var _loop = function _loop2(i3) {
          if ((0, _lang.findIndex)(ruleAttr, function(e2) {
            return e2 === runtimeAttr[i3];
          }) < 0)
            isEqual = false;
        };
        for (var i2 = 0; i2 < runtimeAttr.length && isEqual; i2++) {
          _loop(i2);
        }
        log.debug("[equalToSetMatcher] is " + runtimeAttr + " equal to set " + ruleAttr + "? " + isEqual);
        return isEqual;
      };
    }
    var _default = equalToSetMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/cont_all.js
var require_cont_all = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/cont_all.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-engine:matcher");
    function containsAllMatcherContext(ruleAttr) {
      return function containsAllMatcher(runtimeAttr) {
        var containsAll = true;
        if (runtimeAttr.length < ruleAttr.length) {
          containsAll = false;
        } else {
          var _loop = function _loop2(i3) {
            if ((0, _lang.findIndex)(runtimeAttr, function(e2) {
              return e2 === ruleAttr[i3];
            }) < 0)
              containsAll = false;
          };
          for (var i2 = 0; i2 < ruleAttr.length && containsAll; i2++) {
            _loop(i2);
          }
        }
        log.debug("[containsAllMatcher] " + runtimeAttr + " contains all elements of " + ruleAttr + "? " + containsAll);
        return containsAll;
      };
    }
    var _default = containsAllMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/cont_any.js
var require_cont_any = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/cont_any.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-engine:matcher");
    function containsAnyMatcherContext(ruleAttr) {
      return function containsAnyMatcher(runtimeAttr) {
        var containsAny = false;
        var _loop = function _loop2(i3) {
          if ((0, _lang.findIndex)(runtimeAttr, function(e2) {
            return e2 === ruleAttr[i3];
          }) >= 0)
            containsAny = true;
        };
        for (var i2 = 0; i2 < ruleAttr.length && !containsAny; i2++) {
          _loop(i2);
        }
        log.debug("[containsAnyMatcher] " + runtimeAttr + " contains at least an element of " + ruleAttr + "? " + containsAny);
        return containsAny;
      };
    }
    var _default = containsAnyMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/part_of.js
var require_part_of = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/part_of.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-engine:matcher");
    function partOfMatcherContext(ruleAttr) {
      return function partOfMatcher(runtimeAttr) {
        var isPartOf = runtimeAttr.length <= ruleAttr.length;
        var _loop = function _loop2(i3) {
          if ((0, _lang.findIndex)(ruleAttr, function(e2) {
            return e2 === runtimeAttr[i3];
          }) < 0)
            isPartOf = false;
        };
        for (var i2 = 0; i2 < runtimeAttr.length && isPartOf; i2++) {
          _loop(i2);
        }
        log.debug("[partOfMatcher] " + runtimeAttr + " is part of " + ruleAttr + "? " + isPartOf);
        return isPartOf;
      };
    }
    var _default = partOfMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/sw.js
var require_sw = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/sw.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-engine:matcher");
    function startsWithMatcherContext(ruleAttr) {
      return function startsWithMatcher(runtimeAttr) {
        var matches = ruleAttr.some(function(e2) {
          return (0, _lang.startsWith)(runtimeAttr, e2);
        });
        log.debug("[startsWithMatcher] " + runtimeAttr + " starts with " + ruleAttr + "? " + matches);
        return matches;
      };
    }
    var _default = startsWithMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/ew.js
var require_ew = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/ew.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-engine:matcher");
    function endsWithMatcherContext(ruleAttr) {
      return function endsWithMatcher(runtimeAttr) {
        var endsWith = ruleAttr.some(function(e2) {
          return (0, _lang.endsWith)(runtimeAttr, e2);
        });
        log.debug("[endsWithMatcher] " + runtimeAttr + " ends with " + ruleAttr + "? " + endsWith);
        return endsWith;
      };
    }
    var _default = endsWithMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/cont_str.js
var require_cont_str = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/cont_str.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function containsStringMatcherContext(ruleAttr) {
      return function containsStringMatcher(runtimeAttr) {
        var contains = ruleAttr.some(function(e2) {
          return (0, _lang.isString)(runtimeAttr) && runtimeAttr.indexOf(e2) > -1;
        });
        log.debug("[containsStringMatcher] " + runtimeAttr + " contains " + ruleAttr + "? " + contains);
        return contains;
      };
    }
    var _default = containsStringMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/dependency.js
var require_dependency = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/dependency.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function checkTreatment(evaluation, acceptableTreatments, parentName) {
      var matches = false;
      if (Array.isArray(acceptableTreatments)) {
        matches = acceptableTreatments.indexOf(evaluation.treatment) !== -1;
      }
      log.debug('[dependencyMatcher] Parent split "' + parentName + '" evaluated to "' + evaluation.treatment + '" with label "' + evaluation.label + '". ' + parentName + " evaluated treatment is part of [" + acceptableTreatments + "] ? " + matches + ".");
      return matches;
    }
    function dependencyMatcherContext(_ref, storage) {
      var split2 = _ref.split, treatments = _ref.treatments;
      return function dependencyMatcher(_ref2, splitEvaluator) {
        var key2 = _ref2.key, attributes = _ref2.attributes;
        log.debug('[dependencyMatcher] will evaluate parent split: "' + split2 + '" with key: ' + JSON.stringify(key2) + " " + (attributes ? "\n attributes: " + JSON.stringify(attributes) : ""));
        var evaluation = splitEvaluator(key2, split2, attributes, storage);
        if ((0, _thenable.default)(evaluation)) {
          return evaluation.then(function(ev) {
            return checkTreatment(ev, treatments, split2);
          });
        } else {
          return checkTreatment(evaluation, treatments, split2);
        }
      };
    }
    var _default = dependencyMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/boolean.js
var require_boolean = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/boolean.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function booleanMatcherContext(ruleAttr) {
      return function booleanMatcher(runtimeAttr) {
        var booleanMatches = ruleAttr === runtimeAttr;
        log.debug("[booleanMatcher] " + ruleAttr + " === " + runtimeAttr);
        return booleanMatches;
      };
    }
    var _default = booleanMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/string.js
var require_string = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/string.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-engine:matcher");
    function stringMatcherContext(ruleAttr) {
      return function stringMatcher(runtimeAttr) {
        var re;
        try {
          re = new RegExp(ruleAttr);
        } catch (e2) {
          log.debug("[stringMatcher] " + ruleAttr + " is an invalid regex");
          return false;
        }
        var regexMatches = re.test(runtimeAttr);
        log.debug("[stringMatcher] does " + runtimeAttr + " matches with " + ruleAttr + "? " + (regexMatches ? "yes" : "no"));
        return regexMatches;
      };
    }
    var _default = stringMatcherContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/matchers/index.js
var require_matchers2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/matchers/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _all = _interopRequireDefault(require_all());
    var _segment = _interopRequireDefault(require_segment2());
    var _whitelist = _interopRequireDefault(require_whitelist2());
    var _eq = _interopRequireDefault(require_eq());
    var _gte = _interopRequireDefault(require_gte());
    var _lte = _interopRequireDefault(require_lte());
    var _between = _interopRequireDefault(require_between());
    var _eq_set = _interopRequireDefault(require_eq_set());
    var _cont_all = _interopRequireDefault(require_cont_all());
    var _cont_any = _interopRequireDefault(require_cont_any());
    var _part_of = _interopRequireDefault(require_part_of());
    var _sw = _interopRequireDefault(require_sw());
    var _ew = _interopRequireDefault(require_ew());
    var _cont_str = _interopRequireDefault(require_cont_str());
    var _dependency = _interopRequireDefault(require_dependency());
    var _boolean = _interopRequireDefault(require_boolean());
    var _string = _interopRequireDefault(require_string());
    var matchers = [
      void 0,
      _all.default,
      _segment.default,
      _whitelist.default,
      _eq.default,
      _gte.default,
      _lte.default,
      _between.default,
      _eq_set.default,
      _cont_any.default,
      _cont_all.default,
      _part_of.default,
      _ew.default,
      _sw.default,
      _cont_str.default,
      _dependency.default,
      _boolean.default,
      _string.default
    ];
    function MatcherFactory(matcherDto, storage) {
      var type = matcherDto.type, value = matcherDto.value;
      var matcherFn;
      if (matchers[type])
        matcherFn = matchers[type](value, storage);
      return matcherFn;
    }
    var _default = MatcherFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/value/sanitize.js
var require_sanitize = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/value/sanitize.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var _convertions = require_convertions();
    var _types = require_types();
    var log = (0, _logger.default)("splitio-engine:sanitize");
    function sanitizeNumber(val) {
      var num = (0, _lang.toNumber)(val);
      return isNaN(num) ? void 0 : num;
    }
    function sanitizeString(val) {
      var valueToSanitize = val;
      if ((0, _lang.isObject)(val)) {
        valueToSanitize = val.matchingKey ? val.matchingKey : void 0;
      }
      var str = (0, _lang.toString)(valueToSanitize);
      return str ? str : void 0;
    }
    function sanitizeArray(val) {
      var arr = Array.isArray(val) ? (0, _lang.uniq)(val.map(function(e2) {
        return e2 + "";
      })) : [];
      return arr.length ? arr : void 0;
    }
    function sanitizeBoolean(val) {
      if (val === true || val === false)
        return val;
      if (typeof val === "string") {
        var lowerCaseValue = val.toLocaleLowerCase();
        if (lowerCaseValue === "true")
          return true;
        if (lowerCaseValue === "false")
          return false;
      }
      return void 0;
    }
    function dependencyProcessor(sanitizedValue, attributes) {
      return {
        key: sanitizedValue,
        attributes
      };
    }
    function getProcessingFunction(matcherTypeID, dataType) {
      switch (matcherTypeID) {
        case _types.matcherTypes.EQUAL_TO:
          return dataType === "DATETIME" ? _convertions.zeroSinceHH : void 0;
        case _types.matcherTypes.GREATER_THAN_OR_EQUAL_TO:
        case _types.matcherTypes.LESS_THAN_OR_EQUAL_TO:
        case _types.matcherTypes.BETWEEN:
          return dataType === "DATETIME" ? _convertions.zeroSinceSS : void 0;
        case _types.matcherTypes.IN_SPLIT_TREATMENT:
          return dependencyProcessor;
        default:
          return void 0;
      }
    }
    function sanitizeValue(matcherTypeID, value, dataType, attributes) {
      var processor = getProcessingFunction(matcherTypeID, dataType);
      var sanitizedValue;
      switch (dataType) {
        case _types.matcherDataTypes.NUMBER:
        case _types.matcherDataTypes.DATETIME:
          sanitizedValue = sanitizeNumber(value);
          break;
        case _types.matcherDataTypes.STRING:
          sanitizedValue = sanitizeString(value);
          break;
        case _types.matcherDataTypes.SET:
          sanitizedValue = sanitizeArray(value);
          break;
        case _types.matcherDataTypes.BOOLEAN:
          sanitizedValue = sanitizeBoolean(value);
          break;
        case _types.matcherDataTypes.NOT_SPECIFIED:
          sanitizedValue = value;
          break;
        default:
          sanitizedValue = void 0;
      }
      if (processor) {
        sanitizedValue = processor(sanitizedValue, attributes);
      }
      log.debug("Attempted to sanitize [" + value + "] which should be of type [" + dataType + "]. \n Sanitized and processed value => [" + (sanitizedValue instanceof Object ? JSON.stringify(sanitizedValue) : sanitizedValue) + "]");
      return sanitizedValue;
    }
    var _default = sanitizeValue;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/value/index.js
var require_value = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/value/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _sanitize = _interopRequireDefault(require_sanitize());
    var log = (0, _logger.default)("splitio-engine:value");
    function parseValue(key2, attributeName, attributes) {
      var value2 = void 0;
      if (attributeName) {
        if (attributes) {
          value2 = attributes[attributeName];
          log.debug("Extracted attribute [" + attributeName + "], [" + value2 + "] will be used for matching.");
        } else {
          log.warn("Defined attribute [" + attributeName + "], no attributes received.");
        }
      } else {
        value2 = key2;
      }
      return value2;
    }
    function value(key2, matcherDto, attributes) {
      var attributeName = matcherDto.attribute;
      var valueToMatch = parseValue(key2, attributeName, attributes);
      var sanitizedValue = (0, _sanitize.default)(matcherDto.type, valueToMatch, matcherDto.dataType, attributes);
      if (sanitizedValue !== void 0) {
        return sanitizedValue;
      } else {
        log.warn("Value " + valueToMatch + " " + (attributeName ? "for attribute " + attributeName + " " : +"") + "doesn't match with expected type.");
        return;
      }
    }
    var _default = value;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/legacy.js
var require_legacy = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/legacy.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function ToInteger(x2) {
      x2 = Number(x2);
      return x2 < 0 ? Math.ceil(x2) : Math.floor(x2);
    }
    function modulo(a, b) {
      return a - Math.floor(a / b) * b;
    }
    function ToUint32(x2) {
      return modulo(ToInteger(x2), Math.pow(2, 32));
    }
    function ToInt32(x2) {
      var uint32 = ToUint32(x2);
      if (uint32 >= Math.pow(2, 31)) {
        return uint32 - Math.pow(2, 32);
      } else {
        return uint32;
      }
    }
    function hash2(str, seed) {
      var h2 = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        h2 = ToInt32(ToInt32(31 * h2) + str.charCodeAt(i2));
      }
      return ToInt32(h2 ^ seed);
    }
    function bucket(str, seed) {
      return Math.abs(hash2(str, seed) % 100) + 1;
    }
    var _default = {
      hash: hash2,
      bucket
    };
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/utfx.js
var require_utfx = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/utfx.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.encodeUTF16toUTF8 = encodeUTF16toUTF8;
    exports.stringSource = stringSource;
    exports.stringDestination = stringDestination;
    function encodeUTF8(src, dst) {
      var cp = null;
      if (typeof src === "number")
        cp = src, src = function src2() {
          return null;
        };
      while (cp !== null || (cp = src()) !== null) {
        if (cp < 128)
          dst(cp & 127);
        else if (cp < 2048)
          dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
        else if (cp < 65536)
          dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
        else
          dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
        cp = null;
      }
    }
    function UTF16toUTF8(src, dst) {
      var c1, c2 = null;
      while (true) {
        if ((c1 = c2 !== null ? c2 : src()) === null)
          break;
        if (c1 >= 55296 && c1 <= 57343) {
          if ((c2 = src()) !== null) {
            if (c2 >= 56320 && c2 <= 57343) {
              dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
              c2 = null;
              continue;
            }
          }
        }
        dst(c1);
      }
      if (c2 !== null)
        dst(c2);
    }
    function encodeUTF16toUTF8(src, dst) {
      UTF16toUTF8(src, function(cp) {
        encodeUTF8(cp, dst);
      });
    }
    var stringFromCharCode = String.fromCharCode;
    function stringSource(s3) {
      if (typeof s3 !== "string")
        throw TypeError("Illegal argument: " + typeof s3);
      var i2 = 0;
      return function() {
        return i2 >= s3.length ? null : s3.charCodeAt(i2++);
      };
    }
    function stringDestination() {
      var cs = [], ps = [];
      return function() {
        if (arguments.length === 0)
          return ps.join("") + stringFromCharCode.apply(String, cs);
        if (cs.length + arguments.length > 1024)
          ps.push(stringFromCharCode.apply(String, cs)), cs.length = 0;
        Array.prototype.push.apply(cs, arguments);
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/common.js
var require_common2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/common.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.UTF16ToUTF8 = UTF16ToUTF8;
    exports.x86Multiply = x86Multiply;
    exports.x86Rotl = x86Rotl;
    exports.x86Fmix = x86Fmix;
    var _utfx = require_utfx();
    function UTF16ToUTF8(key2) {
      var sd;
      (0, _utfx.encodeUTF16toUTF8)((0, _utfx.stringSource)(key2), sd = (0, _utfx.stringDestination)());
      return sd();
    }
    function x86Multiply(m2, n) {
      return (m2 & 65535) * n + (((m2 >>> 16) * n & 65535) << 16);
    }
    function x86Rotl(m2, n) {
      return m2 << n | m2 >>> 32 - n;
    }
    function x86Fmix(h2) {
      h2 ^= h2 >>> 16;
      h2 = x86Multiply(h2, 2246822507);
      h2 ^= h2 >>> 13;
      h2 = x86Multiply(h2, 3266489909);
      h2 ^= h2 >>> 16;
      return h2;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3.js
var require_murmur3 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _common = require_common2();
    function hash32(key2, seed) {
      key2 = key2 || "";
      seed = seed || 0;
      var remainder = key2.length % 4;
      var bytes = key2.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i2 = 0; i2 < bytes; i2 = i2 + 4) {
        k1 = key2.charCodeAt(i2) & 255 | (key2.charCodeAt(i2 + 1) & 255) << 8 | (key2.charCodeAt(i2 + 2) & 255) << 16 | (key2.charCodeAt(i2 + 3) & 255) << 24;
        k1 = (0, _common.x86Multiply)(k1, c1);
        k1 = (0, _common.x86Rotl)(k1, 15);
        k1 = (0, _common.x86Multiply)(k1, c2);
        h1 ^= k1;
        h1 = (0, _common.x86Rotl)(h1, 13);
        h1 = (0, _common.x86Multiply)(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key2.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          k1 ^= (key2.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          k1 ^= key2.charCodeAt(i2) & 255;
          k1 = (0, _common.x86Multiply)(k1, c1);
          k1 = (0, _common.x86Rotl)(k1, 15);
          k1 = (0, _common.x86Multiply)(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key2.length;
      h1 = (0, _common.x86Fmix)(h1);
      return h1 >>> 0;
    }
    function hash2(str, seed) {
      return hash32((0, _common.UTF16ToUTF8)(str), seed >>> 0);
    }
    function bucket(str, seed) {
      return Math.abs(hash2(str, seed) % 100) + 1;
    }
    var _default = {
      hash: hash2,
      bucket
    };
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/index.js
var require_engine = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _legacy = _interopRequireDefault(require_legacy());
    var _murmur = _interopRequireDefault(require_murmur3());
    var log = (0, _logger.default)("splitio-engine");
    var MURMUR_ID = 2;
    function getBucketAlgo(algoId) {
      if (algoId === MURMUR_ID) {
        return _murmur.default.bucket;
      } else {
        return _legacy.default.bucket;
      }
    }
    var engine = {
      getTreatment: function getTreatment(key2, seed, treatments, algoId) {
        var bucket = getBucketAlgo(algoId)(key2, seed);
        var treatment = treatments.getTreatmentFor(bucket);
        log.debug("[engine] using algo " + (algoId !== MURMUR_ID ? "legacy" : "murmur") + " bucket " + bucket + " for key " + key2 + " using seed " + seed + " - treatment " + treatment);
        return treatment;
      },
      shouldApplyRollout: function shouldApplyRollout(trafficAllocation, key2, trafficAllocationSeed, algoId) {
        if (trafficAllocation < 100) {
          var bucket = getBucketAlgo(algoId)(key2, trafficAllocationSeed);
          if (bucket > trafficAllocation) {
            return false;
          }
        }
        return true;
      }
    };
    var _default = engine;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/condition/index.js
var require_condition = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/condition/index.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _engine = _interopRequireDefault(require_engine());
    var _thenable = _interopRequireDefault(require_thenable());
    var LabelsConstants = _interopRequireWildcard(require_labels());
    function match(matchingResult, bucketingKey, seed, treatments, label, algo) {
      if (matchingResult) {
        var treatment = _engine.default.getTreatment(bucketingKey, seed, treatments, algo);
        return {
          treatment,
          label
        };
      }
      return void 0;
    }
    function conditionContext(matcherEvaluator, treatments, label, conditionType) {
      function conditionEvaluator(key2, seed, trafficAllocation, trafficAllocationSeed, splitEvaluator, attributes, algo) {
        if (conditionType === "ROLLOUT" && !_engine.default.shouldApplyRollout(trafficAllocation, key2.bucketingKey, trafficAllocationSeed, algo)) {
          return {
            treatment: void 0,
            label: LabelsConstants.NOT_IN_SPLIT
          };
        }
        var matches = matcherEvaluator(key2, attributes, splitEvaluator);
        if ((0, _thenable.default)(matches)) {
          return matches.then(function(result) {
            return match(result, key2.bucketingKey, seed, treatments, label, algo);
          });
        }
        return match(matches, key2.bucketingKey, seed, treatments, label, algo);
      }
      return conditionEvaluator;
    }
    var _default = conditionContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/combiners/ifelseif.js
var require_ifelseif = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/combiners/ifelseif.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var LabelsConstants = _interopRequireWildcard(require_labels());
    var _constants = require_constants();
    var log = (0, _logger.default)("splitio-engine:combiner");
    function unexpectedInputHandler() {
      log.error("Invalid Split provided, no valid conditions found");
      return {
        treatment: _constants.CONTROL,
        label: LabelsConstants.EXCEPTION
      };
    }
    function computeTreatment(predicateResults) {
      var len = predicateResults.length;
      for (var i2 = 0; i2 < len; i2++) {
        var evaluation = predicateResults[i2];
        if (evaluation !== void 0) {
          log.debug("Treatment found: " + evaluation.treatment);
          return evaluation;
        }
      }
      log.debug("All predicates evaluated, no treatment found.");
      return void 0;
    }
    function ifElseIfCombinerContext(predicates) {
      function ifElseIfCombiner(key2, seed, trafficAllocation, trafficAllocationSeed, attributes, algo, splitEvaluator) {
        var predicateResults = predicates.map(function(evaluator) {
          return evaluator(key2, seed, trafficAllocation, trafficAllocationSeed, splitEvaluator, attributes, algo);
        });
        if ((0, _lang.findIndex)(predicateResults, _thenable.default) !== -1) {
          return Promise.all(predicateResults).then(function(results) {
            return computeTreatment(results);
          });
        }
        return computeTreatment(predicateResults);
      }
      if (!Array.isArray(predicates) || Array.isArray(predicates) && predicates.length === 0) {
        return unexpectedInputHandler;
      } else {
        return ifElseIfCombiner;
      }
    }
    var _default = ifElseIfCombinerContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/combiners/and.js
var require_and = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/combiners/and.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-engine:combiner");
    function andResults(results) {
      var i2 = 0;
      var len = results.length;
      var hasMatchedAll;
      for (; i2 < len && results[i2]; i2++) {
      }
      hasMatchedAll = i2 === len;
      log.debug("[andCombiner] evaluates to " + hasMatchedAll);
      return hasMatchedAll;
    }
    function andCombinerContext(matchers) {
      function andCombiner() {
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }
        var matcherResults = matchers.map(function(matcher) {
          return matcher.apply(void 0, params);
        });
        if ((0, _lang.findIndex)(matcherResults, _thenable.default) !== -1) {
          return Promise.all(matcherResults).then(andResults);
        } else {
          return andResults(matcherResults);
        }
      }
      return andCombiner;
    }
    var _default = andCombinerContext;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/parser/index.js
var require_parser3 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/parser/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _matchers = _interopRequireDefault(require_matchers());
    var _treatments = _interopRequireDefault(require_treatments());
    var _matchers2 = _interopRequireDefault(require_matchers2());
    var _value = _interopRequireDefault(require_value());
    var _condition = _interopRequireDefault(require_condition());
    var _ifelseif = _interopRequireDefault(require_ifelseif());
    var _and = _interopRequireDefault(require_and());
    var _thenable = _interopRequireDefault(require_thenable());
    function parse(conditions, storage) {
      var predicates = [];
      for (var i2 = 0; i2 < conditions.length; i2++) {
        var _conditions$i = conditions[i2], matchers = _conditions$i.matcherGroup.matchers, partitions = _conditions$i.partitions, label = _conditions$i.label, conditionType = _conditions$i.conditionType;
        matchers = (0, _matchers.default)(matchers);
        var expressions = matchers.map(function(matcherDto) {
          var matcher = (0, _matchers2.default)(matcherDto, storage);
          return function(key2, attributes, splitEvaluator) {
            var value = (0, _value.default)(key2, matcherDto, attributes);
            var result = value !== void 0 ? matcher(value, splitEvaluator) : false;
            if ((0, _thenable.default)(result)) {
              return result.then(function(res) {
                return Boolean(res ^ matcherDto.negate);
              });
            }
            return Boolean(result ^ matcherDto.negate);
          };
        });
        if (expressions.length === 0) {
          predicates = [];
          break;
        }
        predicates.push((0, _condition.default)((0, _and.default)(expressions), _treatments.default.parse(partitions), label, conditionType));
      }
      return (0, _ifelseif.default)(predicates);
    }
    var _default = parse;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/index.js
var require_engine2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/index.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _lang = require_lang();
    var _parser = _interopRequireDefault(require_parser3());
    var _parser2 = _interopRequireDefault(require_parser2());
    var _thenable = _interopRequireDefault(require_thenable());
    var LabelsConstants = _interopRequireWildcard(require_labels());
    var _constants = require_constants();
    function defaults(inst) {
      if (typeof inst.baseInfo.defaultTreatment !== "string") {
        inst.baseInfo.defaultTreatment = _constants.CONTROL;
      }
    }
    function evaluationResult(result, defaultTreatment) {
      return {
        treatment: (0, _lang.get)(result, "treatment", defaultTreatment),
        label: (0, _lang.get)(result, "label", LabelsConstants.NO_CONDITION_MATCH)
      };
    }
    function Split(baseInfo, evaluator) {
      if (!(this instanceof Split)) {
        return new Split(baseInfo, evaluator);
      }
      this.baseInfo = baseInfo;
      this.evaluator = evaluator;
      defaults(this);
    }
    Split.parse = function parse(splitFlatStructure, storage) {
      var conditions = splitFlatStructure.conditions;
      var evaluator = (0, _parser.default)(conditions, storage);
      return new Split((0, _objectAssign.default)({}, splitFlatStructure), evaluator);
    };
    Split.prototype.getKey = function getKey() {
      return this.baseInfo.name;
    };
    Split.prototype.getTreatment = function getTreatment(key2, attributes, splitEvaluator) {
      var _this$baseInfo = this.baseInfo, killed = _this$baseInfo.killed, seed = _this$baseInfo.seed, defaultTreatment = _this$baseInfo.defaultTreatment, trafficAllocation = _this$baseInfo.trafficAllocation, trafficAllocationSeed = _this$baseInfo.trafficAllocationSeed, algo = _this$baseInfo.algo;
      var parsedKey;
      var treatment;
      var label;
      try {
        parsedKey = (0, _parser2.default)(key2);
      } catch (err) {
        return {
          treatment: _constants.CONTROL,
          label: LabelsConstants.EXCEPTION
        };
      }
      if (this.isGarbage()) {
        treatment = _constants.CONTROL;
        label = LabelsConstants.SPLIT_ARCHIVED;
      } else if (killed) {
        treatment = defaultTreatment;
        label = LabelsConstants.SPLIT_KILLED;
      } else {
        var evaluation = this.evaluator(parsedKey, seed, trafficAllocation, trafficAllocationSeed, attributes, algo, splitEvaluator);
        if ((0, _thenable.default)(evaluation)) {
          return evaluation.then(function(result) {
            return evaluationResult(result, defaultTreatment);
          });
        } else {
          return evaluationResult(evaluation, defaultTreatment);
        }
      }
      return {
        treatment,
        label
      };
    };
    Split.prototype.isGarbage = function isGarbage() {
      return this.baseInfo.status === "ARCHIVED";
    };
    Split.prototype.getChangeNumber = function getChangeNumber() {
      return this.baseInfo.changeNumber;
    };
    var _default = Split;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/evaluator/index.js
var require_evaluator = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/evaluator/index.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.evaluateFeature = evaluateFeature;
    exports.evaluateFeatures = evaluateFeatures;
    var _ = _interopRequireDefault(require_engine2());
    var _thenable = _interopRequireDefault(require_thenable());
    var LabelsConstants = _interopRequireWildcard(require_labels());
    var _constants = require_constants();
    var treatmentException = {
      treatment: _constants.CONTROL,
      label: LabelsConstants.EXCEPTION,
      config: null
    };
    function evaluateFeature(key2, splitName, attributes, storage) {
      var stringifiedSplit;
      try {
        stringifiedSplit = storage.splits.getSplit(splitName);
      } catch (e2) {
        return Promise.resolve(treatmentException);
      }
      if ((0, _thenable.default)(stringifiedSplit)) {
        return stringifiedSplit.then(function(result) {
          return getEvaluation(result, key2, attributes, storage);
        });
      }
      return getEvaluation(stringifiedSplit, key2, attributes, storage);
    }
    function evaluateFeatures(key2, splitNames, attributes, storage) {
      var stringifiedSplits;
      var evaluations = {};
      try {
        stringifiedSplits = storage.splits.fetchMany(splitNames);
      } catch (e2) {
        splitNames.forEach(function(splitName) {
          evaluations[splitName] = treatmentException;
        });
        return Promise.resolve(evaluations);
      }
      return (0, _thenable.default)(stringifiedSplits) ? stringifiedSplits.then(function(splits) {
        return getEvaluations(splitNames, splits, key2, attributes, storage);
      }) : getEvaluations(splitNames, stringifiedSplits, key2, attributes, storage);
    }
    function getEvaluation(stringifiedSplit, key2, attributes, storage) {
      var evaluation = {
        treatment: _constants.CONTROL,
        label: LabelsConstants.SPLIT_NOT_FOUND,
        config: null
      };
      if (stringifiedSplit) {
        var splitJSON = JSON.parse(stringifiedSplit);
        var split2 = _.default.parse(splitJSON, storage);
        evaluation = split2.getTreatment(key2, attributes, evaluateFeature);
        if ((0, _thenable.default)(evaluation)) {
          return evaluation.then(function(result) {
            result.changeNumber = split2.getChangeNumber();
            result.config = splitJSON.configurations && splitJSON.configurations[result.treatment] || null;
            return result;
          });
        } else {
          evaluation.changeNumber = split2.getChangeNumber();
          evaluation.config = splitJSON.configurations && splitJSON.configurations[evaluation.treatment] || null;
        }
      }
      return evaluation;
    }
    function getEvaluations(splitNames, splits, key2, attributes, storage) {
      var result = {};
      var thenables = [];
      splitNames.forEach(function(splitName) {
        var evaluation = getEvaluation(splits[splitName], key2, attributes, storage);
        if ((0, _thenable.default)(evaluation)) {
          thenables.push(evaluation.then(function(res) {
            result[splitName] = res;
          }));
        } else {
          result[splitName] = evaluation;
        }
      });
      return thenables.length > 0 ? Promise.all(thenables).then(function() {
        return result;
      }) : result;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/lrucache/linkedlist.js
var require_linkedlist = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/lrucache/linkedlist.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.LinkedList = exports.Node = void 0;
    var Node = function Node2(value, prev, next, list) {
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    };
    exports.Node = Node;
    var LinkedList = /* @__PURE__ */ function() {
      function LinkedList2() {
        this.tail = null;
        this.head = null;
        this.length = 0;
      }
      var _proto = LinkedList2.prototype;
      _proto.removeNode = function removeNode(node) {
        if (!node || !(node instanceof Node))
          return;
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      _proto.unshiftNode = function unshiftNode(node) {
        if (!node || !(node instanceof Node))
          return;
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      _proto.unshift = function unshift() {
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          this.head = new Node(arguments[i2], null, this.head, this);
          if (!this.tail) {
            this.tail = this.head;
          }
          this.length++;
        }
        return this.length;
      };
      return LinkedList2;
    }();
    exports.LinkedList = LinkedList;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/lrucache/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/lrucache/lrucache.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _linkedlist = require_linkedlist();
    var _Map = typeof Map !== "undefined" ? Map : /* @__PURE__ */ function() {
      function MapPoly() {
      }
      var _proto = MapPoly.prototype;
      _proto.set = function set3(key2, value) {
        this[key2] = value;
      };
      _proto.get = function get2(key2) {
        return this[key2];
      };
      _proto.delete = function _delete(key2) {
        delete this[key2];
      };
      (0, _createClass2.default)(MapPoly, [{
        key: "size",
        get: function get2() {
          return Object.keys(this).length;
        }
      }]);
      return MapPoly;
    }();
    var LRUCache = /* @__PURE__ */ function() {
      function LRUCache2(maxSize) {
        this.maxLen = maxSize || 1;
        this.items = new _Map();
        this.lru = new _linkedlist.LinkedList();
      }
      var _proto2 = LRUCache2.prototype;
      _proto2.get = function get2(key2) {
        var node = this.items.get(key2);
        if (!node || !(node instanceof _linkedlist.Node))
          return void 0;
        this.lru.unshiftNode(node);
        return node.value.value;
      };
      _proto2.set = function set3(key2, value) {
        var node = this.items.get(key2);
        if (node) {
          if (!(node instanceof _linkedlist.Node))
            return false;
          this.lru.unshiftNode(node);
          this.lru.head.value.value = value;
        } else {
          if (this.lru.length === this.maxLen) {
            var last = this.lru.tail;
            if (!last)
              return false;
            this.items.delete(last.value.key);
            this.lru.removeNode(this.lru.tail);
          }
          this.lru.unshift({
            key: key2,
            value
          });
          this.items.set(key2, this.lru.head);
        }
        return true;
      };
      return LRUCache2;
    }();
    var _default = LRUCache;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/impressions/observer/observer.js
var require_observer = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/impressions/observer/observer.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _lrucache = _interopRequireDefault(require_lrucache());
    var ImpressionObserver = /* @__PURE__ */ function() {
      function ImpressionObserver2(size, hasher) {
        this.cache = new _lrucache.default(size);
        this.hasher = hasher;
      }
      var _proto = ImpressionObserver2.prototype;
      _proto.testAndSet = function testAndSet(impression) {
        var hash2 = this.hasher(impression);
        var previous = this.cache.get(hash2);
        this.cache.set(hash2, impression.time);
        return previous;
      };
      return ImpressionObserver2;
    }();
    var _default = ImpressionObserver;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3_128_x86.js
var require_murmur3_128_x86 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3_128_x86.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.hash128 = hash128;
    var _common = require_common2();
    function hash128x86(key2, seed) {
      key2 = key2 || "";
      seed = seed || 0;
      var remainder = key2.length % 16;
      var bytes = key2.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i2 = 0; i2 < bytes; i2 = i2 + 16) {
        k1 = key2.charCodeAt(i2) & 255 | (key2.charCodeAt(i2 + 1) & 255) << 8 | (key2.charCodeAt(i2 + 2) & 255) << 16 | (key2.charCodeAt(i2 + 3) & 255) << 24;
        k2 = key2.charCodeAt(i2 + 4) & 255 | (key2.charCodeAt(i2 + 5) & 255) << 8 | (key2.charCodeAt(i2 + 6) & 255) << 16 | (key2.charCodeAt(i2 + 7) & 255) << 24;
        k3 = key2.charCodeAt(i2 + 8) & 255 | (key2.charCodeAt(i2 + 9) & 255) << 8 | (key2.charCodeAt(i2 + 10) & 255) << 16 | (key2.charCodeAt(i2 + 11) & 255) << 24;
        k4 = key2.charCodeAt(i2 + 12) & 255 | (key2.charCodeAt(i2 + 13) & 255) << 8 | (key2.charCodeAt(i2 + 14) & 255) << 16 | (key2.charCodeAt(i2 + 15) & 255) << 24;
        k1 = (0, _common.x86Multiply)(k1, c1);
        k1 = (0, _common.x86Rotl)(k1, 15);
        k1 = (0, _common.x86Multiply)(k1, c2);
        h1 ^= k1;
        h1 = (0, _common.x86Rotl)(h1, 19);
        h1 += h2;
        h1 = (0, _common.x86Multiply)(h1, 5) + 1444728091;
        k2 = (0, _common.x86Multiply)(k2, c2);
        k2 = (0, _common.x86Rotl)(k2, 16);
        k2 = (0, _common.x86Multiply)(k2, c3);
        h2 ^= k2;
        h2 = (0, _common.x86Rotl)(h2, 17);
        h2 += h3;
        h2 = (0, _common.x86Multiply)(h2, 5) + 197830471;
        k3 = (0, _common.x86Multiply)(k3, c3);
        k3 = (0, _common.x86Rotl)(k3, 17);
        k3 = (0, _common.x86Multiply)(k3, c4);
        h3 ^= k3;
        h3 = (0, _common.x86Rotl)(h3, 15);
        h3 += h4;
        h3 = (0, _common.x86Multiply)(h3, 5) + 2530024501;
        k4 = (0, _common.x86Multiply)(k4, c4);
        k4 = (0, _common.x86Rotl)(k4, 18);
        k4 = (0, _common.x86Multiply)(k4, c1);
        h4 ^= k4;
        h4 = (0, _common.x86Rotl)(h4, 13);
        h4 += h1;
        h4 = (0, _common.x86Multiply)(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= key2.charCodeAt(i2 + 14) << 16;
        case 14:
          k4 ^= key2.charCodeAt(i2 + 13) << 8;
        case 13:
          k4 ^= key2.charCodeAt(i2 + 12);
          k4 = (0, _common.x86Multiply)(k4, c4);
          k4 = (0, _common.x86Rotl)(k4, 18);
          k4 = (0, _common.x86Multiply)(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= key2.charCodeAt(i2 + 11) << 24;
        case 11:
          k3 ^= key2.charCodeAt(i2 + 10) << 16;
        case 10:
          k3 ^= key2.charCodeAt(i2 + 9) << 8;
        case 9:
          k3 ^= key2.charCodeAt(i2 + 8);
          k3 = (0, _common.x86Multiply)(k3, c3);
          k3 = (0, _common.x86Rotl)(k3, 17);
          k3 = (0, _common.x86Multiply)(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= key2.charCodeAt(i2 + 7) << 24;
        case 7:
          k2 ^= key2.charCodeAt(i2 + 6) << 16;
        case 6:
          k2 ^= key2.charCodeAt(i2 + 5) << 8;
        case 5:
          k2 ^= key2.charCodeAt(i2 + 4);
          k2 = (0, _common.x86Multiply)(k2, c2);
          k2 = (0, _common.x86Rotl)(k2, 16);
          k2 = (0, _common.x86Multiply)(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= key2.charCodeAt(i2 + 3) << 24;
        case 3:
          k1 ^= key2.charCodeAt(i2 + 2) << 16;
        case 2:
          k1 ^= key2.charCodeAt(i2 + 1) << 8;
        case 1:
          k1 ^= key2.charCodeAt(i2);
          k1 = (0, _common.x86Multiply)(k1, c1);
          k1 = (0, _common.x86Rotl)(k1, 15);
          k1 = (0, _common.x86Multiply)(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key2.length;
      h2 ^= key2.length;
      h3 ^= key2.length;
      h4 ^= key2.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = (0, _common.x86Fmix)(h1);
      h2 = (0, _common.x86Fmix)(h2);
      h3 = (0, _common.x86Fmix)(h3);
      h4 = (0, _common.x86Fmix)(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    }
    function hash128(str, seed) {
      return hash128x86((0, _common.UTF16ToUTF8)(str), seed >>> 0);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/impressions/hasher/buildKey.js
var require_buildKey = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/impressions/hasher/buildKey.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.buildKey = buildKey;
    function buildKey(impression) {
      return impression.keyName + ":" + impression.feature + ":" + impression.treatment + ":" + impression.label + ":" + impression.changeNumber;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/impressions/hasher/hashImpression128.js
var require_hashImpression128 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/impressions/hasher/hashImpression128.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.hashImpression128 = hashImpression128;
    var _murmur3_128_x = require_murmur3_128_x86();
    var _buildKey = require_buildKey();
    function hashImpression128(impression) {
      return (0, _murmur3_128_x.hash128)((0, _buildKey.buildKey)(impression));
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/impressions/observer/node.js
var require_node10 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/impressions/observer/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _observer = _interopRequireDefault(require_observer());
    var _hashImpression = require_hashImpression128();
    var LAST_SEEN_CACHE_SIZE = 5e5;
    var NodeImpressionObserverFactory = function NodeImpressionObserverFactory2() {
      return new _observer.default(LAST_SEEN_CACHE_SIZE, _hashImpression.hashImpression128);
    };
    var _default = NodeImpressionObserverFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/time/index.js
var require_time = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/time/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.truncateTimeFrame = truncateTimeFrame;
    var DEDUP_WINDOW_SIZE_MS = 3600 * 1e3;
    function truncateTimeFrame(timestampInMs) {
      return timestampInMs - timestampInMs % DEDUP_WINDOW_SIZE_MS;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/trackers/impressions.js
var require_impressions = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/trackers/impressions.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var _observer = _interopRequireDefault(require_node10());
    var _time = require_time();
    var _constants = require_constants();
    var log = (0, _logger.default)("splitio-client:impressions-tracker");
    function shouldAddPt(settings) {
      return [_constants.PRODUCER_MODE, _constants.STANDALONE_MODE].indexOf(settings.mode) > -1 ? true : false;
    }
    function shouldBeOptimized(settings) {
      if (!shouldAddPt(settings))
        return false;
      return settings.sync.impressionsMode === _constants.OPTIMIZED ? true : false;
    }
    function ImpressionsTracker(context) {
      var collector = context.get(context.constants.STORAGE).impressions;
      var settings = context.get(context.constants.SETTINGS);
      var listener = settings.impressionListener;
      var integrationsManager = context.get(context.constants.INTEGRATIONS_MANAGER, true);
      var _settings$runtime = settings.runtime, ip = _settings$runtime.ip, hostname = _settings$runtime.hostname;
      var sdkLanguageVersion = settings.version;
      var _queue = [];
      var shouldAddPreviousTime = shouldAddPt(settings);
      var isOptimized = shouldBeOptimized(settings);
      var observer = (0, _observer.default)();
      var impressionsCounter = context.get(context.constants.IMPRESSIONS_COUNTER);
      return {
        queue: function queue(impression, attributes) {
          _queue.push({
            impression,
            attributes
          });
        },
        track: function track() {
          var impressionsCount = _queue.length;
          var slice = _queue.splice(0, impressionsCount);
          var impressionsToStore = [];
          slice.forEach(function(_ref) {
            var impression = _ref.impression;
            if (shouldAddPreviousTime) {
              impression.pt = observer.testAndSet(impression);
            }
            var now = Date.now();
            if (isOptimized && impressionsCounter) {
              impressionsCounter.inc(impression.feature, now, 1);
            }
            if (!isOptimized || !impression.pt || impression.pt < (0, _time.truncateTimeFrame)(now)) {
              impressionsToStore.push(impression);
            }
          });
          var res = collector.track(impressionsToStore);
          if ((0, _thenable.default)(res)) {
            res.then(function() {
              log.debug("Successfully stored " + impressionsCount + " impression" + (impressionsCount === 1 ? "" : "s") + ".");
            }).catch(function(err) {
              log.error("Could not store impressions bulk with " + impressionsCount + " impression" + (impressionsCount === 1 ? "" : "s") + ". Error: " + err);
            });
          }
          if (listener || integrationsManager) {
            var _loop = function _loop2(i3) {
              var impressionData = {
                impression: (0, _objectAssign.default)({}, slice[i3].impression),
                attributes: slice[i3].attributes,
                ip,
                hostname,
                sdkLanguageVersion
              };
              setTimeout(function() {
                if (integrationsManager)
                  integrationsManager.handleImpression(impressionData);
                try {
                  if (listener)
                    listener.logImpression(impressionData);
                } catch (err) {
                  log.error("Impression listener logImpression method threw: " + err + ".");
                }
              }, 0);
            };
            for (var i2 = 0; i2 < impressionsCount; i2++) {
              _loop(i2);
            }
          }
        }
      };
    }
    var _default = ImpressionsTracker;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/trackers/event.js
var require_event2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/trackers/event.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-client:event-tracker");
    function EventTracker(context) {
      var collector = context.get(context.constants.STORAGE).events;
      var integrationsManager = context.get(context.constants.INTEGRATIONS_MANAGER, true);
      function queueEventsCallback(eventData, tracked) {
        var eventTypeId = eventData.eventTypeId, trafficTypeName = eventData.trafficTypeName, key2 = eventData.key, value = eventData.value, timestamp = eventData.timestamp, properties = eventData.properties;
        var msg = 'event of type "' + eventTypeId + '" for traffic type "' + trafficTypeName + '". Key: ' + key2 + ". Value: " + value + ". Timestamp: " + timestamp + ". " + (properties ? "With properties." : "With no properties.");
        if (tracked) {
          log.info("Successfully queued " + msg);
          if (integrationsManager) {
            setTimeout(function() {
              var eventDataCopy = (0, _objectAssign.default)({}, eventData);
              if (eventData.properties)
                eventDataCopy.properties = (0, _objectAssign.default)({}, eventData.properties);
              integrationsManager.handleEvent(eventDataCopy);
            }, 0);
          }
        } else {
          log.warn("Failed to queue " + msg);
        }
        return tracked;
      }
      return {
        track: function track(eventData, size) {
          var tracked = collector.track(eventData, size);
          if ((0, _thenable.default)(tracked)) {
            return tracked.then(queueEventsCallback.bind(null, eventData));
          } else {
            return queueEventsCallback(eventData, tracked);
          }
        }
      };
    }
    var _default = EventTracker;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/key/factory.js
var require_factory = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/key/factory.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.bucketing = exports.matching = void 0;
    var _lang = require_lang();
    function KeyGetterFactory(keyProperty, undefinedIfNotObj) {
      if (undefinedIfNotObj === void 0) {
        undefinedIfNotObj = false;
      }
      return function getKeyProperty(key2) {
        if ((0, _lang.isObject)(key2)) {
          return key2[keyProperty];
        }
        return undefinedIfNotObj ? void 0 : key2;
      };
    }
    var matching = KeyGetterFactory("matchingKey");
    exports.matching = matching;
    var bucketing = KeyGetterFactory("bucketingKey", true);
    exports.bucketing = bucketing;
  }
});

// node_modules/@splitsoftware/splitio/lib/client/client.js
var require_client = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/client/client.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _evaluator = require_evaluator();
    var _impressions = _interopRequireDefault(require_impressions());
    var _event = _interopRequireDefault(require_event2());
    var _timeTracker = _interopRequireDefault(require_timeTracker());
    var _thenable = _interopRequireDefault(require_thenable());
    var _factory = require_factory();
    var _inputValidation = require_inputValidation();
    var _labels = require_labels();
    var _constants = require_constants();
    var log = (0, _logger.default)("splitio-client");
    function ClientFactory(context) {
      var storage = context.get(context.constants.STORAGE);
      var metricCollectors = context.get(context.constants.COLLECTORS);
      var impressionsTracker = (0, _impressions.default)(context);
      var eventTracker = (0, _event.default)(context);
      function getTreatment(key2, splitName, attributes, withConfig) {
        if (withConfig === void 0) {
          withConfig = false;
        }
        var taskToBeTracked = _timeTracker.default.TaskNames[withConfig ? "SDK_GET_TREATMENT_WITH_CONFIG" : "SDK_GET_TREATMENT"];
        var stopLatencyTracker = _timeTracker.default.start(taskToBeTracked, metricCollectors);
        var evaluation = (0, _evaluator.evaluateFeature)(key2, splitName, attributes, storage);
        var wrapUp = function wrapUp2(evaluationResult) {
          var treatment = processEvaluation(evaluationResult, splitName, key2, attributes, withConfig, "getTreatment" + (withConfig ? "withConfig" : ""));
          impressionsTracker.track();
          stopLatencyTracker();
          return treatment;
        };
        return (0, _thenable.default)(evaluation) ? evaluation.then(function(res) {
          return wrapUp(res);
        }) : wrapUp(evaluation);
      }
      function getTreatmentWithConfig(key2, splitName, attributes) {
        return getTreatment(key2, splitName, attributes, true);
      }
      function getTreatments(key2, splitNames, attributes, withConfig) {
        if (withConfig === void 0) {
          withConfig = false;
        }
        var taskToBeTracked = _timeTracker.default.TaskNames[withConfig ? "SDK_GET_TREATMENTS_WITH_CONFIG" : "SDK_GET_TREATMENTS"];
        var stopLatencyTracker = _timeTracker.default.start(taskToBeTracked, metricCollectors);
        var wrapUp = function wrapUp2(evaluationResults) {
          var results = {};
          Object.keys(evaluationResults).forEach(function(splitName) {
            results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key2, attributes, withConfig, "getTreatments" + (withConfig ? "withConfig" : ""));
          });
          impressionsTracker.track();
          stopLatencyTracker();
          return results;
        };
        var evaluations = (0, _evaluator.evaluateFeatures)(key2, splitNames, attributes, storage);
        return (0, _thenable.default)(evaluations) ? evaluations.then(function(res) {
          return wrapUp(res);
        }) : wrapUp(evaluations);
      }
      function getTreatmentsWithConfig(key2, splitNames, attributes) {
        return getTreatments(key2, splitNames, attributes, true);
      }
      function processEvaluation(evaluation, splitName, key2, attributes, withConfig, invokingMethodName) {
        var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);
        var matchingKey = (0, _factory.matching)(key2);
        var bucketingKey = (0, _factory.bucketing)(key2);
        if (!isSdkReady) {
          evaluation = {
            treatment: _constants.CONTROL,
            label: _labels.SDK_NOT_READY
          };
        }
        var _evaluation = evaluation, treatment = _evaluation.treatment, label = _evaluation.label, changeNumber = _evaluation.changeNumber, _evaluation$config = _evaluation.config, config = _evaluation$config === void 0 ? null : _evaluation$config;
        log.info("Split: " + splitName + ". Key: " + matchingKey + ". Evaluation: " + treatment + ". Label: " + label);
        if ((0, _inputValidation.validateSplitExistance)(context, splitName, label, invokingMethodName)) {
          log.info("Queueing corresponding impression.");
          impressionsTracker.queue({
            feature: splitName,
            keyName: matchingKey,
            treatment,
            time: Date.now(),
            bucketingKey,
            label,
            changeNumber
          }, attributes);
        }
        if (withConfig) {
          return {
            treatment,
            config
          };
        }
        return treatment;
      }
      function track(key2, trafficTypeName, eventTypeId, value, properties, size) {
        if (value === void 0) {
          value = null;
        }
        if (properties === void 0) {
          properties = null;
        }
        if (size === void 0) {
          size = 1024;
        }
        var matchingKey = (0, _factory.matching)(key2);
        var timestamp = Date.now();
        var eventData = {
          eventTypeId,
          trafficTypeName,
          value,
          timestamp,
          key: matchingKey,
          properties
        };
        (0, _inputValidation.validateTrafficTypeExistance)(trafficTypeName, context, "track");
        return eventTracker.track(eventData, size);
      }
      return {
        getTreatment,
        getTreatmentWithConfig,
        getTreatments,
        getTreatmentsWithConfig,
        track
      };
    }
    var _default = ClientFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/client/inputValidation.js
var require_inputValidation2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/client/inputValidation.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _client = _interopRequireDefault(require_client());
    var _inputValidation = require_inputValidation();
    var _lang = require_lang();
    var _constants = require_constants();
    function ClientInputValidationLayer(context, isKeyBinded, isTTBinded) {
      var settings = context.get(context.constants.SETTINGS);
      var isStorageSync = settings.storage.type !== _constants.STORAGE_REDIS;
      var client = (0, _client.default)(context);
      var clientGetTreatment = client.getTreatment;
      var clientGetTreatmentWithConfig = client.getTreatmentWithConfig;
      var clientGetTreatments = client.getTreatments;
      var clientGetTreatmentsWithConfig = client.getTreatmentsWithConfig;
      var clientTrack = client.track;
      function validateEvaluationParams(maybeKey, maybeSplitOrSplits, maybeAttributes, methodName) {
        var multi = (0, _lang.startsWith)(methodName, "getTreatments");
        var key2 = isKeyBinded ? maybeKey : (0, _inputValidation.validateKey)(maybeKey, methodName);
        var splitOrSplits = multi ? (0, _inputValidation.validateSplits)(maybeSplitOrSplits, methodName) : (0, _inputValidation.validateSplit)(maybeSplitOrSplits, methodName);
        var attributes = (0, _inputValidation.validateAttributes)(maybeAttributes, methodName);
        var isOperational = (0, _inputValidation.validateIfDestroyed)(context);
        (0, _inputValidation.validateIfReady)(context, methodName);
        var valid = isOperational && key2 && splitOrSplits && attributes !== false;
        return {
          valid,
          key: key2,
          splitOrSplits,
          attributes
        };
      }
      client.getTreatment = function getTreatment(maybeKey, maybeSplit, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, "getTreatment");
        if (params.valid) {
          return clientGetTreatment(params.key, params.splitOrSplits, params.attributes);
        } else {
          if (isStorageSync)
            return _constants.CONTROL;
          return Promise.resolve(_constants.CONTROL);
        }
      };
      client.getTreatmentWithConfig = function getTreatmentWithConfig(maybeKey, maybeSplit, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, "getTreatmentWithConfig");
        if (params.valid) {
          return clientGetTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);
        } else {
          if (isStorageSync)
            return (0, _objectAssign.default)({}, _constants.CONTROL_WITH_CONFIG);
          return Promise.resolve((0, _objectAssign.default)({}, _constants.CONTROL_WITH_CONFIG));
        }
      };
      client.getTreatments = function getTreatments(maybeKey, maybeSplits, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, "getTreatments");
        if (params.valid) {
          return clientGetTreatments(params.key, params.splitOrSplits, params.attributes);
        } else {
          var res = {};
          if (params.splitOrSplits)
            params.splitOrSplits.forEach(function(split2) {
              return res[split2] = _constants.CONTROL;
            });
          if (isStorageSync)
            return res;
          return Promise.resolve(res);
        }
      };
      client.getTreatmentsWithConfig = function getTreatmentsWithConfig(maybeKey, maybeSplits, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, "getTreatmentsWithConfig");
        if (params.valid) {
          return clientGetTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);
        } else {
          var res = {};
          if (params.splitOrSplits)
            params.splitOrSplits.forEach(function(split2) {
              return res[split2] = (0, _objectAssign.default)({}, _constants.CONTROL_WITH_CONFIG);
            });
          if (isStorageSync)
            return res;
          return Promise.resolve(res);
        }
      };
      client.track = function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {
        var key2 = isKeyBinded ? maybeKey : (0, _inputValidation.validateKey)(maybeKey, "track");
        var tt = isTTBinded ? maybeTT : (0, _inputValidation.validateTrafficType)(maybeTT, "track");
        var event = (0, _inputValidation.validateEvent)(maybeEvent, "track");
        var eventValue = (0, _inputValidation.validateEventValue)(maybeEventValue, "track");
        var _validateEventPropert = (0, _inputValidation.validateEventProperties)(maybeProperties, "track"), properties = _validateEventPropert.properties, size = _validateEventPropert.size;
        var isOperational = (0, _inputValidation.validateIfDestroyed)(context);
        if (isOperational && key2 && tt && event && eventValue !== false && properties !== false) {
          return clientTrack(key2, tt, event, eventValue, properties, size);
        } else {
          if (isStorageSync)
            return false;
          return Promise.resolve(false);
        }
      };
      return client;
    }
    var _default = ClientInputValidationLayer;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/client/node.js
var require_node11 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/client/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = NodeClientFactory;
    var _inputValidation = _interopRequireDefault(require_inputValidation2());
    function NodeClientFactory(context) {
      var client = (0, _inputValidation.default)(context);
      client.isBrowserClient = false;
      return client;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/fn/repeat.js
var require_repeat = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/fn/repeat.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function repeat(fn, delay) {
      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        rest[_key - 2] = arguments[_key];
      }
      var tid;
      var stopped = false;
      function next(_delay) {
        if (_delay === void 0) {
          _delay = delay;
        }
        for (var _len2 = arguments.length, rest2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest2[_key2 - 1] = arguments[_key2];
        }
        if (!stopped) {
          tid = setTimeout(function() {
            fn.apply(void 0, rest2.concat([next]));
          }, _delay);
        }
      }
      function till() {
        clearTimeout(tid);
        tid = void 0;
        stopped = true;
      }
      till.reset = function() {
        clearTimeout(tid);
        tid = void 0;
        next.apply(void 0, [delay].concat(rest));
      };
      fn.apply(void 0, rest.concat([next]));
      return till;
    }
    var _default = repeat;
    exports.default = _default;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function evenRound(x2) {
      if (x2 % 1 === 0.5 && (x2 & 1) === 0) {
        return Math.floor(x2);
      } else {
        return Math.round(x2);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x2 = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw new TypeError("Argument is not a finite number");
          }
          x2 = sign(x2) * Math.floor(Math.abs(x2));
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x2;
        }
        if (!isNaN(x2) && opts.clamp) {
          x2 = evenRound(x2);
          if (x2 < lowerBound)
            x2 = lowerBound;
          if (x2 > upperBound)
            x2 = upperBound;
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = sign(x2) * Math.floor(Math.abs(x2));
        x2 = x2 % moduloVal;
        if (!typeOpts.unsigned && x2 >= moduloBound) {
          return x2 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x2 < 0) {
            x2 += moduloVal;
          } else if (x2 === -0) {
            return 0;
          }
        }
        return x2;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x2 = +V;
      if (!Number.isFinite(x2)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x2;
    };
    conversions["unrestricted double"] = function(V) {
      const x2 = +V;
      if (isNaN(x2)) {
        throw new TypeError("Argument is NaN");
      }
      return x2;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x2 = String(V);
      let c = void 0;
      for (let i2 = 0; (c = x2.codePointAt(i2)) !== void 0; ++i2) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x2;
    };
    conversions["USVString"] = function(V) {
      const S2 = String(V);
      const n = S2.length;
      const U = [];
      for (let i2 = 0; i2 < n; ++i2) {
        const c = S2.charCodeAt(i2);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S2.charCodeAt(i2 + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i2;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize2(str) {
      return str.split("\0").map(function(s3) {
        return s3.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error2 = false;
      if (normalize2(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error2 = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error2 = true;
          break;
        }
      }
      return {
        label,
        error: error2
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize2(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e2) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e2) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme2) {
      return specialSchemes[scheme2] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme2) {
      return specialSchemes[scheme2];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) {
        str += percentEncode(buf[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base2, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base2 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2) {
          if (buffer[i2] < 33 || buffer[i2] > 126 || buffer[i2] === 34 || buffer[i2] === 35 || buffer[i2] === 60 || buffer[i2] === 62) {
            this.url.query += percentEncode(buffer[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i2]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e2) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base2 = constructorArgs[1];
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils3();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream2 = _interopDefault(require("stream"));
    var http2 = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https2 = _interopDefault(require("https"));
    var zlib2 = _interopDefault(require("zlib"));
    var Readable2 = Stream2.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob3 = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob3) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable3 = new Readable2();
        readable3._read = function() {
        };
        readable3.push(this[BUFFER]);
        readable3.push(null);
        return readable3;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob3([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob3.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob3.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError2(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError2.prototype = Object.create(Error.prototype);
    FetchError2.prototype.constructor = FetchError2;
    FetchError2.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e2) {
    }
    var INTERNALS2 = Symbol("Body internals");
    var PassThrough2 = Stream2.PassThrough;
    function Body2(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob2(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream2)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS2] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream2) {
        body.on("error", function(err) {
          const error2 = err.name === "AbortError" ? err : new FetchError2(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS2].error = error2;
        });
      }
    }
    Body2.prototype = {
      get body() {
        return this[INTERNALS2].body;
      },
      get bodyUsed() {
        return this[INTERNALS2].disturbed;
      },
      arrayBuffer() {
        return consumeBody2.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody2.call(this).then(function(buf) {
          return Object.assign(new Blob3([], {
            type: ct.toLowerCase()
          }), {
            [BUFFER]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody2.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body2.Promise.reject(new FetchError2(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody2.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody2.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody2.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body2.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body2.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body2.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody2() {
      var _this4 = this;
      if (this[INTERNALS2].disturbed) {
        return Body2.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS2].disturbed = true;
      if (this[INTERNALS2].error) {
        return Body2.Promise.reject(this[INTERNALS2].error);
      }
      let body = this.body;
      if (body === null) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob2(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body2.Promise.resolve(body);
      }
      if (!(body instanceof Stream2)) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body2.Promise(function(resolve2, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError2(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError2(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError2(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError2(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob2(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone2(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream2 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough2();
        p2 = new PassThrough2();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS2].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType2(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob2(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream2) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes2(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob2(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream2(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob2(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body2.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key2 in map) {
        if (key2.toLowerCase() === name) {
          return key2;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers3 = class {
      constructor() {
        let init3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init3 instanceof Headers3) {
          const rawHeaders = init3.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init3 == null)
          ;
        else if (typeof init3 === "object") {
          const method = init3[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init3) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key2 of Object.keys(init3)) {
              const value = init3[key2];
              this.append(key2, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key2 = find(this[MAP], name);
        if (key2 === void 0) {
          return null;
        }
        return this[MAP][key2].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key2 = find(this[MAP], name);
        this[MAP][key2 !== void 0 ? key2 : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key2 = find(this[MAP], name);
        if (key2 !== void 0) {
          this[MAP][key2].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key2 = find(this[MAP], name);
        if (key2 !== void 0) {
          delete this[MAP][key2];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers3.prototype.entries = Headers3.prototype[Symbol.iterator];
    Object.defineProperty(Headers3.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers3.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers3();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$12 = Symbol("Response internals");
    var STATUS_CODES = http2.STATUS_CODES;
    var Response3 = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body2.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers3(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$12] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$12].url || "";
      }
      get status() {
        return this[INTERNALS$12].status;
      }
      get ok() {
        return this[INTERNALS$12].status >= 200 && this[INTERNALS$12].status < 300;
      }
      get redirected() {
        return this[INTERNALS$12].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$12].statusText;
      }
      get headers() {
        return this[INTERNALS$12].headers;
      }
      clone() {
        return new Response3(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body2.mixIn(Response3.prototype);
    Object.defineProperties(Response3.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response3.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$22 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream2.Readable.prototype;
    function isRequest2(input) {
      return typeof input === "object" && typeof input[INTERNALS$22] === "object";
    }
    function isAbortSignal2(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request3 = class {
      constructor(input) {
        let init3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest2(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init3.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init3.body != null || isRequest2(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init3.body != null ? init3.body : isRequest2(input) && input.body !== null ? clone2(input) : null;
        Body2.call(this, inputBody, {
          timeout: init3.timeout || input.timeout || 0,
          size: init3.size || input.size || 0
        });
        const headers = new Headers3(init3.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest2(input) ? input.signal : null;
        if ("signal" in init3)
          signal = init3.signal;
        if (signal != null && !isAbortSignal2(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$22] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init3.follow !== void 0 ? init3.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init3.compress !== void 0 ? init3.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init3.counter || input.counter || 0;
        this.agent = init3.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$22].method;
      }
      get url() {
        return format_url(this[INTERNALS$22].parsedURL);
      }
      get headers() {
        return this[INTERNALS$22].headers;
      }
      get redirect() {
        return this[INTERNALS$22].redirect;
      }
      get signal() {
        return this[INTERNALS$22].signal;
      }
      clone() {
        return new Request3(this);
      }
    };
    Body2.mixIn(Request3.prototype);
    Object.defineProperty(Request3.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions2(request) {
      const parsedURL = request[INTERNALS$22].parsedURL;
      const headers = new Headers3(request[INTERNALS$22].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream2.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes2(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError2(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError2.prototype = Object.create(Error.prototype);
    AbortError2.prototype.constructor = AbortError2;
    AbortError2.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream2.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    function fetch3(url, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body2.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve2, reject) {
        const request = new Request3(url, opts);
        const options = getNodeRequestOptions2(request);
        const send = (options.protocol === "https:" ? https2 : http2).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error2 = new AbortError2("The user aborted a request.");
          reject(error2);
          if (request.body && request.body instanceof Stream2.Readable) {
            request.body.destroy(error2);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error2);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError2(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError2(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError2(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError2(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers3(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes2(request) === null) {
                  reject(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch3(new Request3(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response3(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib2.createGunzip(zlibOptions));
            response = new Response3(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib2.createInflate());
              } else {
                body = body.pipe(zlib2.createInflateRaw());
              }
              response = new Response3(body, response_options);
              resolve2(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
            body = body.pipe(zlib2.createBrotliDecompress());
            response = new Response3(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response3(body, response_options);
          resolve2(response);
        });
        writeToStream2(req, request);
      });
    }
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports = fetch3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers3;
    exports.Request = Request3;
    exports.Response = Response3;
    exports.FetchError = FetchError2;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/getFetch/node.js
var require_node12 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/getFetch/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.__setFetch = __setFetch;
    exports.default = getFetch;
    var nodeFetch;
    try {
      nodeFetch = require_lib3();
      if (typeof nodeFetch !== "function")
        nodeFetch = nodeFetch.default;
    } catch (error2) {
      nodeFetch = typeof fetch === "function" ? fetch : void 0;
    }
    function __setFetch(fetch3) {
      nodeFetch = fetch3;
    }
    function getFetch() {
      return nodeFetch;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/transport/index.js
var require_transport = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/transport/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = Fetcher;
    var _getFetch = _interopRequireDefault(require_node12());
    var _Errors = require_Errors();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-services:service");
    var messageNoFetch = "Global fetch API is not available.";
    function Fetcher(request) {
      var url = request.url;
      var fetch3 = (0, _getFetch.default)();
      return fetch3 ? fetch3(url, request).then(function(response) {
        if (!response.ok) {
          return response.text().then(function(message) {
            return Promise.reject({
              response,
              message
            });
          });
        }
        return response;
      }).catch(function(error2) {
        var resp = error2 && error2.response;
        var msg = "";
        if (resp) {
          switch (resp.status) {
            case 404:
              msg = "Invalid API key or resource not found.";
              break;
            default:
              msg = error2.message;
              break;
          }
        } else {
          msg = error2.message;
        }
        if (!resp || resp.status !== 403) {
          log[request.logErrorsAsInfo ? "info" : "error"]("Response status is not OK. Status: " + (resp ? resp.status : "NO_STATUS") + ". URL: " + url + ". Message: " + msg);
        }
        throw new _Errors.SplitNetworkError(msg, resp && resp.status);
      }) : Promise.reject(new _Errors.SplitNetworkError(messageNoFetch));
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/metrics/index.js
var require_metrics = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/metrics/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _transport = _interopRequireDefault(require_transport());
    var _default = _transport.default;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/request/options/node.js
var require_node13 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/request/options/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = getOptions;
    var _https = _interopRequireDefault(require("https"));
    var agent = new _https.default.Agent({
      keepAlive: true,
      keepAliveMsecs: 1500
    });
    function getOptions() {
      return {
        agent
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/request/index.js
var require_request = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/request/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.noCacheExtraHeader = exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _options = _interopRequireDefault(require_node13());
    function RequestFactory(settings, relativeUrl, params, extraHeaders) {
      var token = settings.core.authorizationKey;
      var version = settings.version;
      var _settings$runtime = settings.runtime, ip = _settings$runtime.ip, hostname = _settings$runtime.hostname;
      var headers = {};
      var baseline = (0, _options.default)();
      headers["Accept"] = "application/json";
      headers["Content-Type"] = "application/json";
      headers["Authorization"] = "Bearer " + token;
      headers["SplitSDKVersion"] = version;
      if (ip)
        headers["SplitSDKMachineIP"] = ip;
      if (hostname)
        headers["SplitSDKMachineName"] = hostname;
      if (extraHeaders)
        (0, _objectAssign.default)(headers, extraHeaders);
      return (0, _objectAssign.default)({
        headers,
        url: settings.url(relativeUrl)
      }, baseline, params);
    }
    var _default = RequestFactory;
    exports.default = _default;
    var noCacheExtraHeader = {
      "Cache-Control": "no-cache"
    };
    exports.noCacheExtraHeader = noCacheExtraHeader;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/metrics/times.js
var require_times = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/metrics/times.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = POST;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _request = _interopRequireDefault(require_request());
    function POST(settings, params) {
      return (0, _request.default)(settings, "/metrics/times", (0, _objectAssign.default)({
        method: "POST"
      }, params, {
        logErrorsAsInfo: true
      }));
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/metrics/counters.js
var require_counters = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/metrics/counters.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = POST;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _request = _interopRequireDefault(require_request());
    function POST(settings, params) {
      return (0, _request.default)(settings, "/metrics/counters", (0, _objectAssign.default)({
        method: "POST"
      }, params, {
        logErrorsAsInfo: true
      }));
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/metrics/dto.js
var require_dto = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/metrics/dto.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.fromLatenciesCollector = fromLatenciesCollector;
    exports.fromCountersCollector = fromCountersCollector;
    var _lang = require_lang();
    function fromLatenciesCollector(latenciesCollector) {
      var result = [];
      var metrics = latenciesCollector.toJSON();
      (0, _lang.forOwn)(metrics, function(latencies, key2) {
        result.push({
          name: key2,
          latencies
        });
      });
      return result;
    }
    function fromCountersCollector(countersCollector) {
      var result = [];
      var metrics = countersCollector.toJSON();
      (0, _lang.forOwn)(metrics, function(delta, key2) {
        result.push({
          name: key2,
          delta
        });
      });
      return result;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/impressions/index.js
var require_impressions2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/impressions/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _transport = _interopRequireDefault(require_transport());
    var _default = _transport.default;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/impressions/bulk.js
var require_bulk = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/impressions/bulk.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = BULK;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _request = _interopRequireDefault(require_request());
    var _constants = require_constants();
    function BULK(settings, params) {
      return (0, _request.default)(settings, "/testImpressions/bulk", (0, _objectAssign.default)({
        method: "POST"
      }, params), {
        SplitSDKImpressionsMode: settings.sync.impressionsMode === _constants.OPTIMIZED ? _constants.OPTIMIZED : _constants.DEBUG
      });
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/impressions/count.js
var require_count = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/impressions/count.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = COUNT;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _request = _interopRequireDefault(require_request());
    function COUNT(settings, params) {
      return (0, _request.default)(settings, "/testImpressions/count", (0, _objectAssign.default)({
        method: "POST"
      }, params));
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/impressions/dto.js
var require_dto2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/impressions/dto.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.fromImpressionsCollector = fromImpressionsCollector;
    exports.fromImpressionsCountCollector = fromImpressionsCountCollector;
    var _lang = require_lang();
    function fromImpressionsCollector(collector, settings) {
      var sendLabels = settings.core.labelsEnabled;
      var groupedByFeature = (0, _lang.groupBy)(collector.state(), "feature");
      var dto = [];
      (0, _lang.forOwn)(groupedByFeature, function(value, name) {
        dto.push({
          f: name,
          i: value.map(function(entry6) {
            var keyImpression = {
              k: entry6.keyName,
              t: entry6.treatment,
              m: entry6.time,
              c: entry6.changeNumber
            };
            if (sendLabels)
              keyImpression.r = entry6.label;
            if (entry6.bucketingKey)
              keyImpression.b = entry6.bucketingKey;
            if (entry6.pt)
              keyImpression.pt = entry6.pt;
            return keyImpression;
          })
        });
      });
      return dto;
    }
    function fromImpressionsCountCollector(collector) {
      var imprCounts = collector ? collector.size() : 0;
      var pf = [];
      if (imprCounts === 0)
        return pf;
      var impressionsCount = collector.popAll();
      var keys = Object.keys(impressionsCount);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var splitted = keys[i2].split("::");
        if (splitted.length !== 2)
          continue;
        var featureName = splitted[0];
        var timeFrame = splitted[1];
        var impressionsInTimeframe = {
          f: featureName,
          m: Number(timeFrame),
          rc: impressionsCount[keys[i2]]
        };
        pf.push(impressionsInTimeframe);
      }
      return pf;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/metrics/Collectors.js
var require_Collectors = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/metrics/Collectors.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.ClientCollector = exports.MySegmentsCollector = exports.SplitChangesCollector = exports.SegmentChangesCollector = void 0;
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var ProducerMetricsCollector = /* @__PURE__ */ function() {
      function ProducerMetricsCollector2(storage) {
        this.storage = storage;
        this.latency = this.latency.bind(this);
        this.count = this.count.bind(this);
        this.countException = this.countException.bind(this);
      }
      var _proto = ProducerMetricsCollector2.prototype;
      _proto.latency = function latency(ms) {
        this.storage.metrics.track(this.metricType + ".time", ms);
      };
      _proto.count = function count(status) {
        this.storage.count.track(this.metricType + ".status." + status);
      };
      _proto.countException = function countException() {
        this.storage.count.track(this.metricType + ".exception");
      };
      return ProducerMetricsCollector2;
    }();
    var SegmentChangesCollector = /* @__PURE__ */ function(_ProducerMetricsColle) {
      (0, _inheritsLoose2.default)(SegmentChangesCollector2, _ProducerMetricsColle);
      function SegmentChangesCollector2(storage) {
        var _this;
        _this = _ProducerMetricsColle.call(this, storage) || this;
        _this.metricType = "segmentChangeFetcher";
        return _this;
      }
      return SegmentChangesCollector2;
    }(ProducerMetricsCollector);
    exports.SegmentChangesCollector = SegmentChangesCollector;
    var SplitChangesCollector = /* @__PURE__ */ function(_ProducerMetricsColle2) {
      (0, _inheritsLoose2.default)(SplitChangesCollector2, _ProducerMetricsColle2);
      function SplitChangesCollector2(storage) {
        var _this2;
        _this2 = _ProducerMetricsColle2.call(this, storage) || this;
        _this2.metricType = "splitChangeFetcher";
        return _this2;
      }
      return SplitChangesCollector2;
    }(ProducerMetricsCollector);
    exports.SplitChangesCollector = SplitChangesCollector;
    var MySegmentsCollector = /* @__PURE__ */ function(_ProducerMetricsColle3) {
      (0, _inheritsLoose2.default)(MySegmentsCollector2, _ProducerMetricsColle3);
      function MySegmentsCollector2(storage) {
        var _this3;
        _this3 = _ProducerMetricsColle3.call(this, storage) || this;
        _this3.metricType = "mySegmentsFetcher";
        return _this3;
      }
      return MySegmentsCollector2;
    }(ProducerMetricsCollector);
    exports.MySegmentsCollector = MySegmentsCollector;
    var ClientCollector = /* @__PURE__ */ function() {
      function ClientCollector2(storage) {
        this.storage = storage;
        this.ready = this.ready.bind(this);
        this.getTreatment = this.getTreatment.bind(this);
        this.getTreatments = this.getTreatments.bind(this);
        this.getTreatmentWithConfig = this.getTreatmentWithConfig.bind(this);
        this.getTreatmentsWithConfig = this.getTreatmentsWithConfig.bind(this);
      }
      var _proto2 = ClientCollector2.prototype;
      _proto2.ready = function ready(ms) {
        this.storage.metrics.track("sdk.ready", ms);
      };
      _proto2.getTreatment = function getTreatment(ms) {
        this.storage.metrics.track("sdk.getTreatment", ms);
      };
      _proto2.getTreatments = function getTreatments(ms) {
        this.storage.metrics.track("sdk.getTreatments", ms);
      };
      _proto2.getTreatmentWithConfig = function getTreatmentWithConfig(ms) {
        this.storage.metrics.track("sdk.getTreatmentWithConfig", ms);
      };
      _proto2.getTreatmentsWithConfig = function getTreatmentsWithConfig(ms) {
        this.storage.metrics.track("sdk.getTreatmentsWithConfig", ms);
      };
      return ClientCollector2;
    }();
    exports.ClientCollector = ClientCollector;
  }
});

// node_modules/@splitsoftware/splitio/lib/metrics/index.js
var require_metrics2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/metrics/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _timeTracker = _interopRequireDefault(require_timeTracker());
    var _repeat = _interopRequireDefault(require_repeat());
    var _metrics = _interopRequireDefault(require_metrics());
    var _times = _interopRequireDefault(require_times());
    var _counters = _interopRequireDefault(require_counters());
    var _dto = require_dto();
    var _impressions = _interopRequireDefault(require_impressions2());
    var _bulk = _interopRequireDefault(require_bulk());
    var _count = _interopRequireDefault(require_count());
    var _dto2 = require_dto2();
    var _Collectors = require_Collectors();
    var _constants = require_constants();
    var log = (0, _logger.default)("splitio-metrics");
    var IMPRESSIONS_COUNT_RATE = 18e5;
    var MetricsFactory = function MetricsFactory2(context) {
      var impressionsRetries = 0;
      var settings = context.get(context.constants.SETTINGS);
      var storage = context.get(context.constants.STORAGE);
      var impressionsCounter = context.get(context.constants.IMPRESSIONS_COUNTER);
      var shouldPushImpressionsCount = settings.sync.impressionsMode === _constants.OPTIMIZED;
      var pushMetrics = function pushMetrics2() {
        if (storage.metrics.isEmpty() && storage.count.isEmpty())
          return Promise.resolve();
        log.debug("Pushing metrics");
        var latencyTrackerStop = _timeTracker.default.start(_timeTracker.default.TaskNames.METRICS_PUSH);
        var latenciesPromise = storage.metrics.isEmpty() ? null : (0, _metrics.default)((0, _times.default)(settings, {
          body: JSON.stringify((0, _dto.fromLatenciesCollector)(storage.metrics))
        })).then(function() {
          return storage.metrics.clear();
        }).catch(function() {
          return storage.metrics.clear();
        });
        var countersPromise = storage.count.isEmpty() ? null : (0, _metrics.default)((0, _counters.default)(settings, {
          body: JSON.stringify((0, _dto.fromCountersCollector)(storage.count))
        })).then(function() {
          return storage.count.clear();
        }).catch(function() {
          return storage.count.clear();
        });
        return Promise.all([latenciesPromise, countersPromise]).then(function(resp) {
          latencyTrackerStop();
          return resp;
        });
      };
      var pushImpressions = function pushImpressions2() {
        if (storage.impressions.isEmpty())
          return Promise.resolve();
        var imprCount = storage.impressions.queue.length;
        log.info("Pushing " + imprCount + " impressions");
        var latencyTrackerStop = _timeTracker.default.start(_timeTracker.default.TaskNames.IMPRESSIONS_PUSH);
        return (0, _impressions.default)((0, _bulk.default)(settings, {
          body: JSON.stringify((0, _dto2.fromImpressionsCollector)(storage.impressions, settings))
        })).then(function() {
          impressionsRetries = 0;
          storage.impressions.clear();
        }).catch(function(err) {
          if (impressionsRetries) {
            log.warn("Droping " + imprCount + " impressions after retry. Reason " + err + ".");
            impressionsRetries = 0;
            storage.impressions.clear();
          } else {
            impressionsRetries++;
            log.warn("Failed to push " + imprCount + " impressions, keeping data to retry on next iteration. Reason " + err + ".");
          }
        }).then(function() {
          return latencyTrackerStop();
        });
      };
      var pushImpressionsCount = function pushImpressionsCount2() {
        var pf = (0, _dto2.fromImpressionsCountCollector)(impressionsCounter);
        var imprCounts = pf.length;
        if (imprCounts === 0)
          return Promise.resolve();
        log.info("Pushing count of impressions for " + imprCounts + " features");
        return (0, _impressions.default)((0, _count.default)(settings, {
          body: JSON.stringify({
            pf
          })
        })).then(function() {
          impressionsRetries = 0;
        }).catch(function(err) {
          if (impressionsRetries) {
            log.warn("Droping count of impressions for " + imprCounts + " features after retry. Reason " + err + ".");
            impressionsRetries = 0;
          } else {
            impressionsRetries++;
            log.warn("Failed to push impressions count for " + imprCounts + " features, keeping data to retry on next iteration. Reason " + err + ".");
          }
        });
      };
      var stopImpressionsPublisher = false;
      var stopPerformancePublisher = false;
      var stopImpressionsCountPublisher = false;
      return {
        start: function start() {
          stopImpressionsPublisher = (0, _repeat.default)(function(schedulePublisher) {
            return pushImpressions().then(function() {
              return schedulePublisher();
            });
          }, settings.scheduler.impressionsRefreshRate);
          stopPerformancePublisher = (0, _repeat.default)(function(schedulePublisher) {
            return pushMetrics().then(function() {
              return schedulePublisher();
            });
          }, settings.scheduler.metricsRefreshRate);
          if (shouldPushImpressionsCount) {
            stopImpressionsCountPublisher = (0, _repeat.default)(function(schedulePublisher) {
              return pushImpressionsCount().then(function() {
                return schedulePublisher();
              });
            }, IMPRESSIONS_COUNT_RATE);
          }
        },
        flush: function flush() {
          if (shouldPushImpressionsCount)
            pushImpressionsCount();
          return pushImpressions();
        },
        stop: function stop() {
          stopImpressionsPublisher && stopImpressionsPublisher();
          stopPerformancePublisher && stopPerformancePublisher();
          stopImpressionsCountPublisher && stopImpressionsCountPublisher();
        },
        collectors: {
          segmentChanges: new _Collectors.SegmentChangesCollector(storage),
          splitChanges: new _Collectors.SplitChangesCollector(storage),
          mySegments: new _Collectors.MySegmentsCollector(storage),
          client: new _Collectors.ClientCollector(storage)
        }
      };
    };
    var _default = MetricsFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/events/index.js
var require_events = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/events/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _transport = _interopRequireDefault(require_transport());
    var _default = _transport.default;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/events/bulk.js
var require_bulk2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/events/bulk.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = BULK;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _request = _interopRequireDefault(require_request());
    function BULK(settings, params) {
      return (0, _request.default)(settings, "/events/bulk", (0, _objectAssign.default)({
        method: "POST"
      }, params));
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/events/index.js
var require_events2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/events/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _timeTracker = _interopRequireDefault(require_timeTracker());
    var _repeat = _interopRequireDefault(require_repeat());
    var _events = _interopRequireDefault(require_events());
    var _bulk = _interopRequireDefault(require_bulk2());
    var log = (0, _logger.default)("splitio-events");
    var EventsFactory = function EventsFactory2(context) {
      var settings = context.get(context.constants.SETTINGS);
      var storage = context.get(context.constants.STORAGE);
      var pushEvents = function pushEvents2() {
        if (storage.events.isEmpty())
          return Promise.resolve();
        log.info("Pushing " + storage.events.state().length + " queued events.");
        var latencyTrackerStop = _timeTracker.default.start(_timeTracker.default.TaskNames.EVENTS_PUSH);
        var json = JSON.stringify(storage.events.toJSON());
        var wrapUpCb = function wrapUpCb2() {
          return latencyTrackerStop();
        };
        storage.events.clear();
        return (0, _events.default)((0, _bulk.default)(settings, {
          body: json
        })).then(wrapUpCb).catch(wrapUpCb);
      };
      var stopEventPublisherTimeout = false;
      var stopEventsPublisher = false;
      var startEventsPublisher = function startEventsPublisher2() {
        return stopEventsPublisher = (0, _repeat.default)(function(schedulePublisher) {
          return pushEvents().then(function() {
            return schedulePublisher();
          });
        }, settings.scheduler.eventsPushRate);
      };
      return {
        start: function start() {
          if (settings.startup.eventsFirstPushWindow > 0) {
            stopEventPublisherTimeout = setTimeout(startEventsPublisher, settings.startup.eventsFirstPushWindow);
          } else {
            startEventsPublisher();
          }
        },
        flush: function flush() {
          return pushEvents();
        },
        stop: function stop() {
          stopEventPublisherTimeout && clearTimeout(stopEventPublisherTimeout);
          stopEventsPublisher && stopEventsPublisher();
        },
        flushAndResetTimer: function flushAndResetTimer() {
          log.info("Flushing events and reseting timer.");
          stopEventsPublisher && stopEventsPublisher.reset();
          return pushEvents();
        }
      };
    };
    var _default = EventsFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/auth/index.js
var require_auth = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/auth/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _transport = _interopRequireDefault(require_transport());
    var _default = _transport.default;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/auth/auth.js
var require_auth2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/auth/auth.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = GET;
    var _request = _interopRequireDefault(require_request());
    function userKeyToQueryParam(userKey) {
      return "users=" + encodeURIComponent(userKey);
    }
    function GET(settings, userKeys) {
      var relativeUrl = "/v2/auth";
      if (userKeys) {
        var queryParams = userKeys.map(userKeyToQueryParam).join("&");
        if (queryParams)
          relativeUrl += "?" + queryParams;
      }
      return (0, _request.default)(settings, relativeUrl);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/base64/node.js
var require_node14 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/base64/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.decodeFromBase64 = decodeFromBase64;
    exports.encodeToBase64 = encodeToBase64;
    function decodeFromBase64(value) {
      return Buffer.from(value, "base64").toString("binary");
    }
    function encodeToBase64(value) {
      return Buffer.from(value).toString("base64");
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/jwt/index.js
var require_jwt = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/jwt/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.decodeJWTtoken = decodeJWTtoken;
    var _base = require_node14();
    function decodeJWTtoken(token) {
      var base64Url = token.split(".")[1];
      var base642 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
      var jsonPayload = decodeURIComponent((0, _base.decodeFromBase64)(base642).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
      return JSON.parse(jsonPayload);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/AuthClient/index.js
var require_AuthClient = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/AuthClient/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = authenticate;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _auth = _interopRequireDefault(require_auth());
    var _auth2 = _interopRequireDefault(require_auth2());
    var _jwt = require_jwt();
    function authenticate(settings, userKeys) {
      var authPromise = (0, _auth.default)((0, _auth2.default)(settings, userKeys));
      return authPromise.then(function(resp) {
        return resp.json();
      }).then(function(json) {
        if (json.token) {
          var decodedToken = (0, _jwt.decodeJWTtoken)(json.token);
          if (typeof decodedToken.iat !== "number" || typeof decodedToken.exp !== "number")
            throw new Error('token properties "issuedAt" (iat) or "expiration" (exp) are missing or invalid');
          var channels = JSON.parse(decodedToken["x-ably-capability"]);
          return (0, _objectAssign.default)({
            decodedToken,
            channels
          }, json);
        }
        return json;
      });
    }
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e2) {
        return null;
      }
    }
    function encode2(input) {
      try {
        return encodeURIComponent(input);
      } catch (e2) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key2 = decode(part[1]), value = decode(part[2]);
        if (key2 === null || value === null || key2 in result)
          continue;
        result[key2] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key2;
      if (typeof prefix !== "string")
        prefix = "?";
      for (key2 in obj) {
        if (has.call(obj, key2)) {
          value = obj[key2];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key2 = encode2(key2);
          value = encode2(value);
          if (key2 === null || value === null)
            continue;
          pairs.push(key2 + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports.stringify = querystringify;
    exports.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      ["?", "query"],
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      ["@", "auth", 1],
      [NaN, "host", void 0, 1, 1],
      [/:(\d*)$/, "port", void 0, 1],
      [NaN, "hostname", void 0, 1, 1]
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof global !== "undefined")
        globalVar = global;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key2;
      if (loc.protocol === "blob:") {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if (type === "string") {
        finaldestination = new Url(loc, {});
        for (key2 in ignore)
          delete finaldestination[key2];
      } else if (type === "object") {
        for (key2 in loc) {
          if (key2 in ignore)
            continue;
          finaldestination[key2] = loc[key2];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme2) {
      return scheme2 === "file:" || scheme2 === "ftp:" || scheme2 === "http:" || scheme2 === "https:" || scheme2 === "ws:" || scheme2 === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve2(relative, base2) {
      if (relative === "")
        return base2;
      var path = (base2 || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path.length, last = path[i2 - 1], unshift = false, up = 0;
      while (i2--) {
        if (path[i2] === ".") {
          path.splice(i2, 1);
        } else if (path[i2] === "..") {
          path.splice(i2, 1);
          up++;
        } else if (up) {
          if (i2 === 0)
            unshift = true;
          path.splice(i2, 1);
          up--;
        }
      }
      if (unshift)
        path.unshift("");
      if (last === "." || last === "..")
        path.push("");
      return path.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse, instruction, index, key2, instructions = rules.slice(), type = typeof location, url = this, i2 = 0;
      if (type !== "object" && type !== "string") {
        parser = location;
        location = null;
      }
      if (parser && typeof parser !== "function")
        parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i2 < instructions.length; i2++) {
        instruction = instructions[i2];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key2 = instruction[1];
        if (parse !== parse) {
          url[key2] = address;
        } else if (typeof parse === "string") {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if (typeof instruction[2] === "number") {
              url[key2] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key2] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key2] = index[1];
          address = address.slice(0, index.index);
        }
        url[key2] = url[key2] || (relative && instruction[3] ? location[key2] || "" : "");
        if (instruction[4])
          url[key2] = url[key2].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve2(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set3(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if (typeof value === "string" && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        var ins = rules[i2];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || typeof stringify !== "function")
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = typeof url.query === "object" ? stringify(url.query) : url.query;
      if (query)
        result += query.charAt(0) !== "?" ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set: set3, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// node_modules/original/index.js
var require_original = __commonJS({
  "node_modules/original/index.js"(exports, module2) {
    "use strict";
    var parse = require_url_parse();
    function origin(url) {
      if (typeof url === "string")
        url = parse(url);
      if (!url.protocol || !url.hostname)
        return "null";
      return (url.protocol + "//" + url.host).toLowerCase();
    }
    origin.same = function same(a, b) {
      return origin(a) === origin(b);
    };
    module2.exports = origin;
  }
});

// node_modules/eventsource/lib/eventsource.js
var require_eventsource = __commonJS({
  "node_modules/eventsource/lib/eventsource.js"(exports, module2) {
    var original = require_original();
    var parse = require("url").parse;
    var events = require("events");
    var https2 = require("https");
    var http2 = require("http");
    var util = require("util");
    var httpsOptions = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "secureProtocol",
      "servername",
      "checkServerIdentity"
    ];
    var bom = [239, 187, 191];
    var colon = 58;
    var space = 32;
    var lineFeed = 10;
    var carriageReturn = 13;
    function hasBom(buf) {
      return bom.every(function(charCode, index) {
        return buf[index] === charCode;
      });
    }
    function EventSource2(url, eventSourceInitDict) {
      var readyState = EventSource2.CONNECTING;
      Object.defineProperty(this, "readyState", {
        get: function() {
          return readyState;
        }
      });
      Object.defineProperty(this, "url", {
        get: function() {
          return url;
        }
      });
      var self2 = this;
      self2.reconnectInterval = 1e3;
      self2.connectionInProgress = false;
      function onConnectionClosed(message) {
        if (readyState === EventSource2.CLOSED)
          return;
        readyState = EventSource2.CONNECTING;
        _emit("error", new Event2("error", { message }));
        if (reconnectUrl) {
          url = reconnectUrl;
          reconnectUrl = null;
        }
        setTimeout(function() {
          if (readyState !== EventSource2.CONNECTING || self2.connectionInProgress) {
            return;
          }
          self2.connectionInProgress = true;
          connect();
        }, self2.reconnectInterval);
      }
      var req;
      var lastEventId = "";
      if (eventSourceInitDict && eventSourceInitDict.headers && eventSourceInitDict.headers["Last-Event-ID"]) {
        lastEventId = eventSourceInitDict.headers["Last-Event-ID"];
        delete eventSourceInitDict.headers["Last-Event-ID"];
      }
      var discardTrailingNewline = false;
      var data = "";
      var eventName = "";
      var reconnectUrl = null;
      function connect() {
        var options = parse(url);
        var isSecure = options.protocol === "https:";
        options.headers = { "Cache-Control": "no-cache", "Accept": "text/event-stream" };
        if (lastEventId)
          options.headers["Last-Event-ID"] = lastEventId;
        if (eventSourceInitDict && eventSourceInitDict.headers) {
          for (var i2 in eventSourceInitDict.headers) {
            var header = eventSourceInitDict.headers[i2];
            if (header) {
              options.headers[i2] = header;
            }
          }
        }
        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
        if (eventSourceInitDict && eventSourceInitDict.createConnection !== void 0) {
          options.createConnection = eventSourceInitDict.createConnection;
        }
        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
        if (useProxy) {
          var proxy = parse(eventSourceInitDict.proxy);
          isSecure = proxy.protocol === "https:";
          options.protocol = isSecure ? "https:" : "http:";
          options.path = url;
          options.headers.Host = options.host;
          options.hostname = proxy.hostname;
          options.host = proxy.host;
          options.port = proxy.port;
        }
        if (eventSourceInitDict && eventSourceInitDict.https) {
          for (var optName in eventSourceInitDict.https) {
            if (httpsOptions.indexOf(optName) === -1) {
              continue;
            }
            var option = eventSourceInitDict.https[optName];
            if (option !== void 0) {
              options[optName] = option;
            }
          }
        }
        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== void 0) {
          options.withCredentials = eventSourceInitDict.withCredentials;
        }
        req = (isSecure ? https2 : http2).request(options, function(res) {
          self2.connectionInProgress = false;
          if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
            _emit("error", new Event2("error", { status: res.statusCode, message: res.statusMessage }));
            onConnectionClosed();
            return;
          }
          if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
            if (!res.headers.location) {
              _emit("error", new Event2("error", { status: res.statusCode, message: res.statusMessage }));
              return;
            }
            if (res.statusCode === 307)
              reconnectUrl = url;
            url = res.headers.location;
            process.nextTick(connect);
            return;
          }
          if (res.statusCode !== 200) {
            _emit("error", new Event2("error", { status: res.statusCode, message: res.statusMessage }));
            return self2.close();
          }
          readyState = EventSource2.OPEN;
          res.on("close", function() {
            res.removeAllListeners("close");
            res.removeAllListeners("end");
            onConnectionClosed();
          });
          res.on("end", function() {
            res.removeAllListeners("close");
            res.removeAllListeners("end");
            onConnectionClosed();
          });
          _emit("open", new Event2("open"));
          var isFirst = true;
          var buf;
          var startingPos = 0;
          var startingFieldLength = -1;
          res.on("data", function(chunk) {
            buf = buf ? Buffer.concat([buf, chunk]) : chunk;
            if (isFirst && hasBom(buf)) {
              buf = buf.slice(bom.length);
            }
            isFirst = false;
            var pos = 0;
            var length = buf.length;
            while (pos < length) {
              if (discardTrailingNewline) {
                if (buf[pos] === lineFeed) {
                  ++pos;
                }
                discardTrailingNewline = false;
              }
              var lineLength = -1;
              var fieldLength = startingFieldLength;
              var c;
              for (var i3 = startingPos; lineLength < 0 && i3 < length; ++i3) {
                c = buf[i3];
                if (c === colon) {
                  if (fieldLength < 0) {
                    fieldLength = i3 - pos;
                  }
                } else if (c === carriageReturn) {
                  discardTrailingNewline = true;
                  lineLength = i3 - pos;
                } else if (c === lineFeed) {
                  lineLength = i3 - pos;
                }
              }
              if (lineLength < 0) {
                startingPos = length - pos;
                startingFieldLength = fieldLength;
                break;
              } else {
                startingPos = 0;
                startingFieldLength = -1;
              }
              parseEventStreamLine(buf, pos, fieldLength, lineLength);
              pos += lineLength + 1;
            }
            if (pos === length) {
              buf = void 0;
            } else if (pos > 0) {
              buf = buf.slice(pos);
            }
          });
        });
        req.on("error", function(err) {
          self2.connectionInProgress = false;
          onConnectionClosed(err.message);
        });
        if (req.setNoDelay)
          req.setNoDelay(true);
        req.end();
      }
      connect();
      function _emit() {
        if (self2.listeners(arguments[0]).length > 0) {
          self2.emit.apply(self2, arguments);
        }
      }
      this._close = function() {
        if (readyState === EventSource2.CLOSED)
          return;
        readyState = EventSource2.CLOSED;
        if (req.abort)
          req.abort();
        if (req.xhr && req.xhr.abort)
          req.xhr.abort();
      };
      function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
        if (lineLength === 0) {
          if (data.length > 0) {
            var type = eventName || "message";
            _emit(type, new MessageEvent(type, {
              data: data.slice(0, -1),
              lastEventId,
              origin: original(url)
            }));
            data = "";
          }
          eventName = void 0;
        } else if (fieldLength > 0) {
          var noValue = fieldLength < 0;
          var step = 0;
          var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
          if (noValue) {
            step = lineLength;
          } else if (buf[pos + fieldLength + 1] !== space) {
            step = fieldLength + 1;
          } else {
            step = fieldLength + 2;
          }
          pos += step;
          var valueLength = lineLength - step;
          var value = buf.slice(pos, pos + valueLength).toString();
          if (field === "data") {
            data += value + "\n";
          } else if (field === "event") {
            eventName = value;
          } else if (field === "id") {
            lastEventId = value;
          } else if (field === "retry") {
            var retry = parseInt(value, 10);
            if (!Number.isNaN(retry)) {
              self2.reconnectInterval = retry;
            }
          }
        }
      }
    }
    module2.exports = EventSource2;
    util.inherits(EventSource2, events.EventEmitter);
    EventSource2.prototype.constructor = EventSource2;
    ["open", "error", "message"].forEach(function(method) {
      Object.defineProperty(EventSource2.prototype, "on" + method, {
        get: function get2() {
          var listener = this.listeners(method)[0];
          return listener ? listener._listener ? listener._listener : listener : void 0;
        },
        set: function set3(listener) {
          this.removeAllListeners(method);
          this.addEventListener(method, listener);
        }
      });
    });
    Object.defineProperty(EventSource2, "CONNECTING", { enumerable: true, value: 0 });
    Object.defineProperty(EventSource2, "OPEN", { enumerable: true, value: 1 });
    Object.defineProperty(EventSource2, "CLOSED", { enumerable: true, value: 2 });
    EventSource2.prototype.CONNECTING = 0;
    EventSource2.prototype.OPEN = 1;
    EventSource2.prototype.CLOSED = 2;
    EventSource2.prototype.close = function() {
      this._close();
    };
    EventSource2.prototype.addEventListener = function addEventListener2(type, listener) {
      if (typeof listener === "function") {
        listener._listener = listener;
        this.on(type, listener);
      }
    };
    EventSource2.prototype.dispatchEvent = function dispatchEvent(event) {
      if (!event.type) {
        throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
      }
      this.emit(event.type, event.detail);
    };
    EventSource2.prototype.removeEventListener = function removeEventListener2(type, listener) {
      if (typeof listener === "function") {
        listener._listener = void 0;
        this.removeListener(type, listener);
      }
    };
    function Event2(type, optionalProperties) {
      Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
      if (optionalProperties) {
        for (var f3 in optionalProperties) {
          if (optionalProperties.hasOwnProperty(f3)) {
            Object.defineProperty(this, f3, { writable: false, value: optionalProperties[f3], enumerable: true });
          }
        }
      }
    }
    function MessageEvent(type, eventInitDict) {
      Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
      for (var f3 in eventInitDict) {
        if (eventInitDict.hasOwnProperty(f3)) {
          Object.defineProperty(this, f3, { writable: false, value: eventInitDict[f3], enumerable: true });
        }
      }
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/getEventSource/node.js
var require_node15 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/getEventSource/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.__setEventSource = __setEventSource;
    exports.__restore = __restore;
    exports.default = getEventSource;
    var __isCustom = false;
    var __eventSource = void 0;
    function __setEventSource(eventSource) {
      __eventSource = eventSource;
      __isCustom = true;
    }
    function __restore() {
      __isCustom = false;
    }
    function getEventSource() {
      try {
        return __isCustom ? __eventSource : require_eventsource();
      } catch (error2) {
        return typeof EventSource === "function" ? EventSource : void 0;
      }
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/PushManager/pushRequirements/node.js
var require_node16 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/PushManager/pushRequirements/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.checkPushRequirements = checkPushRequirements;
    var _node = _interopRequireDefault(require_node15());
    function checkPushRequirements(logger) {
      var esReference = (0, _node.default)();
      if (!esReference) {
        logger.warn("EventSource API is not available. Falling back to polling mode.");
        return false;
      }
      return true;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/backoff/index.js
var require_backoff = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/backoff/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var Backoff = /* @__PURE__ */ function() {
      function Backoff2(cb, baseMillis, maxMillis) {
        this.baseMillis = baseMillis || Backoff2.DEFAULT_BASE_MILLIS;
        this.maxMillis = maxMillis || Backoff2.DEFAULT_MAX_MILLIS;
        this.attempts = 0;
        this.cb = cb;
      }
      var _proto = Backoff2.prototype;
      _proto.scheduleCall = function scheduleCall() {
        var _this = this;
        var delayInMillis = Math.min(this.baseMillis * Math.pow(2, this.attempts), this.maxMillis);
        if (this.timeoutID)
          clearTimeout(this.timeoutID);
        this.timeoutID = setTimeout(function() {
          _this.cb();
        }, delayInMillis);
        this.attempts++;
        return delayInMillis;
      };
      _proto.reset = function reset() {
        this.attempts = 0;
        if (this.timeoutID) {
          clearTimeout(this.timeoutID);
          this.timeoutID = 0;
        }
      };
      return Backoff2;
    }();
    Backoff.DEFAULT_BASE_MILLIS = 1e3;
    Backoff.DEFAULT_MAX_MILLIS = 18e5;
    var _default = Backoff;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/SegmentUpdateWorker/node.js
var require_node17 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/SegmentUpdateWorker/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _backoff = _interopRequireDefault(require_backoff());
    var SegmentUpdateWorker = /* @__PURE__ */ function() {
      function SegmentUpdateWorker2(segmentsStorage, segmentsProducer) {
        this.segmentsStorage = segmentsStorage;
        this.segmentsProducer = segmentsProducer;
        this.maxChangeNumbers = {};
        this.put = this.put.bind(this);
        this.__handleSegmentUpdateCall = this.__handleSegmentUpdateCall.bind(this);
        this.backoff = new _backoff.default(this.__handleSegmentUpdateCall);
      }
      var _proto = SegmentUpdateWorker2.prototype;
      _proto.__handleSegmentUpdateCall = function __handleSegmentUpdateCall() {
        var _this = this;
        var segmentsToFetch = Object.keys(this.maxChangeNumbers).filter(function(segmentName) {
          return _this.maxChangeNumbers[segmentName] > _this.segmentsStorage.getChangeNumber(segmentName);
        });
        if (segmentsToFetch.length > 0) {
          this.handleNewEvent = false;
          var currentMaxChangeNumbers = segmentsToFetch.map(function(segmentToFetch) {
            return _this.maxChangeNumbers[segmentToFetch];
          });
          this.segmentsProducer.synchronizeSegment(segmentsToFetch, true).then(function(result) {
            if (result !== false) {
              segmentsToFetch.forEach(function(fetchedSegment, index) {
                if (_this.maxChangeNumbers[fetchedSegment] === currentMaxChangeNumbers[index])
                  _this.maxChangeNumbers[fetchedSegment] = -1;
              });
            } else {
              _this.backoff.scheduleCall();
            }
            if (_this.handleNewEvent) {
              _this.__handleSegmentUpdateCall();
            }
          });
        }
      };
      _proto.put = function put(changeNumber, segmentName) {
        var currentChangeNumber = this.segmentsStorage.getChangeNumber(segmentName);
        if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumbers[segmentName])
          return;
        this.maxChangeNumbers[segmentName] = changeNumber;
        this.handleNewEvent = true;
        this.backoff.reset();
        if (this.segmentsProducer.isSynchronizingSegments())
          return;
        this.__handleSegmentUpdateCall();
      };
      return SegmentUpdateWorker2;
    }();
    exports.default = SegmentUpdateWorker;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/SplitUpdateWorker/index.js
var require_SplitUpdateWorker = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/SplitUpdateWorker/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _backoff = _interopRequireDefault(require_backoff());
    var SplitUpdateWorker = /* @__PURE__ */ function() {
      function SplitUpdateWorker2(splitStorage, splitProducer, splitsEventEmitter) {
        this.splitStorage = splitStorage;
        this.splitProducer = splitProducer;
        this.maxChangeNumber = 0;
        this.splitsEventEmitter = splitsEventEmitter;
        this.put = this.put.bind(this);
        this.killSplit = this.killSplit.bind(this);
        this.__handleSplitUpdateCall = this.__handleSplitUpdateCall.bind(this);
        this.backoff = new _backoff.default(this.__handleSplitUpdateCall);
      }
      var _proto = SplitUpdateWorker2.prototype;
      _proto.__handleSplitUpdateCall = function __handleSplitUpdateCall() {
        var _this = this;
        if (this.maxChangeNumber > this.splitStorage.getChangeNumber()) {
          this.handleNewEvent = false;
          this.splitProducer.synchronizeSplits(true).then(function() {
            if (_this.handleNewEvent) {
              _this.__handleSplitUpdateCall();
            } else {
              if (_this.splitProducer.synchronizeSegment)
                _this.splitProducer.synchronizeSegment(void 0, false, true);
              _this.backoff.scheduleCall();
            }
          });
        }
      };
      _proto.put = function put(changeNumber) {
        var currentChangeNumber = this.splitStorage.getChangeNumber();
        if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber)
          return;
        this.maxChangeNumber = changeNumber;
        this.handleNewEvent = true;
        this.backoff.reset();
        if (this.splitProducer.isSynchronizingSplits())
          return;
        this.__handleSplitUpdateCall();
      };
      _proto.killSplit = function killSplit(changeNumber, splitName, defaultTreatment) {
        var _this2 = this;
        this.splitStorage.killLocally(splitName, defaultTreatment, changeNumber).then(function(updated2) {
          if (updated2)
            _this2.splitsEventEmitter.emit(_this2.splitsEventEmitter.SDK_SPLITS_ARRIVED, true);
          _this2.put(changeNumber);
        });
      };
      return SplitUpdateWorker2;
    }();
    exports.default = SplitUpdateWorker;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/SSEClient/index.js
var require_SSEClient = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/SSEClient/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _getEventSource = _interopRequireDefault(require_node15());
    var VERSION = "1.1";
    var CONTROL_CHANNEL_REGEX = /^control_/;
    function buildSSEHeaders(settings) {
      var headers = {
        SplitSDKClientKey: settings.core.authorizationKey.slice(-4),
        SplitSDKVersion: settings.version
      };
      var _settings$runtime = settings.runtime, ip = _settings$runtime.ip, hostname = _settings$runtime.hostname;
      if (ip)
        headers["SplitSDKMachineIP"] = ip;
      if (hostname)
        headers["SplitSDKMachineName"] = hostname;
      return headers;
    }
    var SSEClient = /* @__PURE__ */ function() {
      SSEClient2.getInstance = function getInstance(settings, useHeaders) {
        var EventSource2 = (0, _getEventSource.default)();
        if (EventSource2)
          return new SSEClient2(EventSource2, settings, useHeaders);
      };
      function SSEClient2(EventSource2, settings, useHeaders) {
        this.EventSource = EventSource2;
        this.streamingUrl = settings.url("/sse");
        this.useHeaders = useHeaders;
        this.headers = buildSSEHeaders(settings);
      }
      var _proto = SSEClient2.prototype;
      _proto.setEventHandler = function setEventHandler(handler) {
        this.handler = handler;
      };
      _proto.open = function open(authToken) {
        this.close();
        var channelsQueryParam = Object.keys(authToken.channels).map(function(channel) {
          var params = CONTROL_CHANNEL_REGEX.test(channel) ? "[?occupancy=metrics.publishers]" : "";
          return encodeURIComponent(params + channel);
        }).join(",");
        var url = this.streamingUrl + "?channels=" + channelsQueryParam + "&accessToken=" + authToken.token + "&v=" + VERSION + "&heartbeats=true";
        this.connection = new this.EventSource(this.useHeaders ? url : url + ("&SplitSDKVersion=" + this.headers.SplitSDKVersion + "&SplitSDKClientKey=" + this.headers.SplitSDKClientKey), this.useHeaders ? {
          headers: this.headers
        } : void 0);
        if (this.handler) {
          this.connection.onopen = this.handler.handleOpen;
          this.connection.onmessage = this.handler.handleMessage;
          this.connection.onerror = this.handler.handleError;
        }
      };
      _proto.close = function close() {
        if (this.connection)
          this.connection.close();
      };
      return SSEClient2;
    }();
    exports.default = SSEClient;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/constants.js
var require_constants3 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/constants.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.ControlTypes = exports.OCCUPANCY = exports.CONTROL = exports.SPLIT_UPDATE = exports.SPLIT_KILL = exports.SEGMENT_UPDATE = exports.MY_SEGMENTS_UPDATE_V2 = exports.MY_SEGMENTS_UPDATE = exports.PUSH_SUBSYSTEM_DOWN = exports.PUSH_SUBSYSTEM_UP = exports.PUSH_RETRYABLE_ERROR = exports.PUSH_NONRETRYABLE_ERROR = exports.SECONDS_BEFORE_EXPIRATION = void 0;
    var SECONDS_BEFORE_EXPIRATION = 600;
    exports.SECONDS_BEFORE_EXPIRATION = SECONDS_BEFORE_EXPIRATION;
    var PUSH_NONRETRYABLE_ERROR = "PUSH_NONRETRYABLE_ERROR";
    exports.PUSH_NONRETRYABLE_ERROR = PUSH_NONRETRYABLE_ERROR;
    var PUSH_RETRYABLE_ERROR = "PUSH_RETRYABLE_ERROR";
    exports.PUSH_RETRYABLE_ERROR = PUSH_RETRYABLE_ERROR;
    var PUSH_SUBSYSTEM_UP = "PUSH_SUBSYSTEM_UP";
    exports.PUSH_SUBSYSTEM_UP = PUSH_SUBSYSTEM_UP;
    var PUSH_SUBSYSTEM_DOWN = "PUSH_SUBSYSTEM_DOWN";
    exports.PUSH_SUBSYSTEM_DOWN = PUSH_SUBSYSTEM_DOWN;
    var MY_SEGMENTS_UPDATE = "MY_SEGMENTS_UPDATE";
    exports.MY_SEGMENTS_UPDATE = MY_SEGMENTS_UPDATE;
    var MY_SEGMENTS_UPDATE_V2 = "MY_SEGMENTS_UPDATE_V2";
    exports.MY_SEGMENTS_UPDATE_V2 = MY_SEGMENTS_UPDATE_V2;
    var SEGMENT_UPDATE = "SEGMENT_UPDATE";
    exports.SEGMENT_UPDATE = SEGMENT_UPDATE;
    var SPLIT_KILL = "SPLIT_KILL";
    exports.SPLIT_KILL = SPLIT_KILL;
    var SPLIT_UPDATE = "SPLIT_UPDATE";
    exports.SPLIT_UPDATE = SPLIT_UPDATE;
    var CONTROL = "CONTROL";
    exports.CONTROL = CONTROL;
    var OCCUPANCY = "OCCUPANCY";
    exports.OCCUPANCY = OCCUPANCY;
    var ControlTypes = {
      STREAMING_DISABLED: "STREAMING_DISABLED",
      STREAMING_PAUSED: "STREAMING_PAUSED",
      STREAMING_RESUMED: "STREAMING_RESUMED",
      STREAMING_RESET: "STREAMING_RESET"
    };
    exports.ControlTypes = ControlTypes;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/SSEHandler/NotificationParser.js
var require_NotificationParser = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/SSEHandler/NotificationParser.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.errorParser = errorParser;
    exports.messageParser = messageParser;
    var _constants = require_constants3();
    var _lang = require_lang();
    function errorParser(error2) {
      if ((0, _lang.isString)(error2.data))
        error2.parsedData = JSON.parse(error2.data);
      return error2;
    }
    function messageParser(message) {
      var messageData = JSON.parse(message.data);
      messageData.parsedData = JSON.parse(messageData.data);
      if (messageData.name && messageData.name === "[meta]occupancy")
        messageData.parsedData.type = _constants.OCCUPANCY;
      return messageData;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/SSEHandler/NotificationKeeper.js
var require_NotificationKeeper = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/SSEHandler/NotificationKeeper.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = notificationKeeperFactory;
    var _constants = require_constants3();
    var CONTROL_CHANNEL_REGEXS = [/control_pri$/, /control_sec$/];
    function notificationKeeperFactory(feedbackLoopEmitter) {
      var channels = CONTROL_CHANNEL_REGEXS.map(function(regex) {
        return {
          regex,
          hasPublishers: true,
          oTime: -1,
          cTime: -1
        };
      });
      var hasPublishers = true;
      var hasResumed = true;
      function getHasPublishers() {
        return channels.some(function(c) {
          return c.hasPublishers;
        });
      }
      return {
        handleOpen: function handleOpen() {
          feedbackLoopEmitter.emit(_constants.PUSH_SUBSYSTEM_UP);
        },
        isStreamingUp: function isStreamingUp() {
          return hasResumed && hasPublishers;
        },
        handleOccupancyEvent: function handleOccupancyEvent(publishers, channel, timestamp) {
          for (var i2 = 0; i2 < channels.length; i2++) {
            var c = channels[i2];
            if (c.regex.test(channel)) {
              if (timestamp > c.oTime) {
                c.oTime = timestamp;
                c.hasPublishers = publishers !== 0;
                var hasPublishersNow = getHasPublishers();
                if (hasResumed) {
                  if (!hasPublishersNow && hasPublishers) {
                    feedbackLoopEmitter.emit(_constants.PUSH_SUBSYSTEM_DOWN);
                  } else if (hasPublishersNow && !hasPublishers) {
                    feedbackLoopEmitter.emit(_constants.PUSH_SUBSYSTEM_UP);
                  }
                }
                hasPublishers = hasPublishersNow;
              }
              return;
            }
          }
        },
        handleControlEvent: function handleControlEvent(controlType, channel, timestamp) {
          if (controlType === _constants.ControlTypes.STREAMING_RESET) {
            feedbackLoopEmitter.emit(controlType);
            return;
          }
          for (var i2 = 0; i2 < channels.length; i2++) {
            var c = channels[i2];
            if (c.regex.test(channel)) {
              if (timestamp > c.cTime) {
                c.cTime = timestamp;
                if (controlType === _constants.ControlTypes.STREAMING_DISABLED) {
                  feedbackLoopEmitter.emit(_constants.PUSH_NONRETRYABLE_ERROR);
                } else if (hasPublishers) {
                  if (controlType === _constants.ControlTypes.STREAMING_PAUSED && hasResumed) {
                    feedbackLoopEmitter.emit(_constants.PUSH_SUBSYSTEM_DOWN);
                  } else if (controlType === _constants.ControlTypes.STREAMING_RESUMED && !hasResumed) {
                    feedbackLoopEmitter.emit(_constants.PUSH_SUBSYSTEM_UP);
                  }
                }
                hasResumed = controlType === _constants.ControlTypes.STREAMING_RESUMED;
              }
              return;
            }
          }
        }
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/SSEHandler/index.js
var require_SSEHandler = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/SSEHandler/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = SSEHandlerFactory;
    var _NotificationParser = require_NotificationParser();
    var _NotificationKeeper = _interopRequireDefault(require_NotificationKeeper());
    var _constants = require_constants3();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-sync:sse-handler");
    function isRetryableError(error2) {
      if (error2.parsedData && error2.parsedData.code) {
        var code = error2.parsedData.code;
        if (40140 <= code && code <= 40149)
          return true;
        if (4e4 <= code && code <= 49999)
          return false;
      }
      return true;
    }
    function SSEHandlerFactory(pushEmitter) {
      var notificationKeeper = (0, _NotificationKeeper.default)(pushEmitter);
      return {
        handleOpen: function handleOpen() {
          notificationKeeper.handleOpen();
        },
        handleError: function handleError(error2) {
          var errorWithParsedData = error2;
          try {
            errorWithParsedData = (0, _NotificationParser.errorParser)(error2);
          } catch (err) {
            log.warn("Error parsing SSE error notification: " + err);
          }
          var errorMessage = errorWithParsedData.parsedData && errorWithParsedData.parsedData.message;
          log.error("Fail to connect to streaming" + (errorMessage ? ', with error message: "' + errorMessage + '"' : ""));
          if (isRetryableError(errorWithParsedData)) {
            pushEmitter.emit(_constants.PUSH_RETRYABLE_ERROR);
          } else {
            pushEmitter.emit(_constants.PUSH_NONRETRYABLE_ERROR);
          }
        },
        handleMessage: function handleMessage(message) {
          var messageWithParsedData;
          try {
            messageWithParsedData = (0, _NotificationParser.messageParser)(message);
          } catch (err) {
            log.warn("Error parsing new SSE message notification: " + err);
            return;
          }
          var _messageWithParsedDat = messageWithParsedData, parsedData = _messageWithParsedDat.parsedData, data = _messageWithParsedDat.data, channel = _messageWithParsedDat.channel, timestamp = _messageWithParsedDat.timestamp;
          log.debug("New SSE message received, with data: " + data + ".");
          if (!notificationKeeper.isStreamingUp() && [_constants.OCCUPANCY, _constants.CONTROL].indexOf(parsedData.type) === -1)
            return;
          switch (parsedData.type) {
            case _constants.SPLIT_UPDATE:
              pushEmitter.emit(_constants.SPLIT_UPDATE, parsedData.changeNumber);
              break;
            case _constants.SEGMENT_UPDATE:
              pushEmitter.emit(_constants.SEGMENT_UPDATE, parsedData.changeNumber, parsedData.segmentName);
              break;
            case _constants.MY_SEGMENTS_UPDATE:
              pushEmitter.emit(_constants.MY_SEGMENTS_UPDATE, parsedData, channel);
              break;
            case _constants.MY_SEGMENTS_UPDATE_V2:
              pushEmitter.emit(_constants.MY_SEGMENTS_UPDATE_V2, parsedData);
              break;
            case _constants.SPLIT_KILL:
              pushEmitter.emit(_constants.SPLIT_KILL, parsedData.changeNumber, parsedData.splitName, parsedData.defaultTreatment);
              break;
            case _constants.OCCUPANCY:
              notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);
              break;
            case _constants.CONTROL:
              notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);
              break;
            default:
              break;
          }
        }
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/jwt/hashUserKey.js
var require_hashUserKey = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/jwt/hashUserKey.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.hashUserKey = hashUserKey;
    var _base = require_node14();
    var _murmur = _interopRequireDefault(require_murmur3());
    function hashUserKey(userKey) {
      return (0, _base.encodeToBase64)(_murmur.default.hash(userKey, 0).toString());
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/decompress/index.js
var require_decompress = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/decompress/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.algorithms = void 0;
    var algorithms = function iifeDecompress() {
      if ([typeof Uint8Array, typeof Uint16Array, typeof Uint32Array].some(function(v) {
        return v != "function";
      })) {
        return "global Uint8Array object is not available for gzip/zlib decompression";
      }
      var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
      var fleb = new u8([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        0,
        0,
        0
      ]);
      var fdeb = new u8([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        0,
        0
      ]);
      var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var freb = function freb2(eb, start) {
        var b = new u16(31);
        for (var i3 = 0; i3 < 31; ++i3) {
          b[i3] = start += 1 << eb[i3 - 1];
        }
        var r2 = new u32(b[30]);
        for (var i3 = 1; i3 < 30; ++i3) {
          for (var j = b[i3]; j < b[i3 + 1]; ++j) {
            r2[j] = j - b[i3] << 5 | i3;
          }
        }
        return [b, r2];
      };
      var _a4 = freb(fleb, 2), fl = _a4[0], revfl = _a4[1];
      fl[28] = 258, revfl[258] = 28;
      var _b = freb(fdeb, 0), fd = _b[0];
      var rev = new u16(32768);
      for (var i2 = 0; i2 < 32768; ++i2) {
        var x2 = (i2 & 43690) >>> 1 | (i2 & 21845) << 1;
        x2 = (x2 & 52428) >>> 2 | (x2 & 13107) << 2;
        x2 = (x2 & 61680) >>> 4 | (x2 & 3855) << 4;
        rev[i2] = ((x2 & 65280) >>> 8 | (x2 & 255) << 8) >>> 1;
      }
      var hMap = function hMap2(cd, mb, r2) {
        var s3 = cd.length;
        var i3 = 0;
        var l = new u16(mb);
        for (; i3 < s3; ++i3) {
          ++l[cd[i3] - 1];
        }
        var le = new u16(mb);
        for (i3 = 0; i3 < mb; ++i3) {
          le[i3] = le[i3 - 1] + l[i3 - 1] << 1;
        }
        var co;
        if (r2) {
          co = new u16(1 << mb);
          var rvb = 15 - mb;
          for (i3 = 0; i3 < s3; ++i3) {
            if (cd[i3]) {
              var sv = i3 << 4 | cd[i3];
              var r_1 = mb - cd[i3];
              var v = le[cd[i3] - 1]++ << r_1;
              for (var m2 = v | (1 << r_1) - 1; v <= m2; ++v) {
                co[rev[v] >>> rvb] = sv;
              }
            }
          }
        } else {
          co = new u16(s3);
          for (i3 = 0; i3 < s3; ++i3) {
            if (cd[i3]) {
              co[i3] = rev[le[cd[i3] - 1]++] >>> 15 - cd[i3];
            }
          }
        }
        return co;
      };
      var flt = new u8(288);
      for (var i2 = 0; i2 < 144; ++i2) {
        flt[i2] = 8;
      }
      for (var i2 = 144; i2 < 256; ++i2) {
        flt[i2] = 9;
      }
      for (var i2 = 256; i2 < 280; ++i2) {
        flt[i2] = 7;
      }
      for (var i2 = 280; i2 < 288; ++i2) {
        flt[i2] = 8;
      }
      var fdt = new u8(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        fdt[i2] = 5;
      }
      var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
      var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
      var max = function max2(a) {
        var m2 = a[0];
        for (var i3 = 1; i3 < a.length; ++i3) {
          if (a[i3] > m2)
            m2 = a[i3];
        }
        return m2;
      };
      var bits = function bits2(d, p, m2) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8) >> (p & 7) & m2;
      };
      var bits16 = function bits162(d, p) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
      };
      var shft = function shft2(p) {
        return (p + 7) / 8 | 0;
      };
      var slc = function slc2(v, s3, e2) {
        if (s3 == null || s3 < 0)
          s3 = 0;
        if (e2 == null || e2 > v.length)
          e2 = v.length;
        var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e2 - s3);
        n.set(v.subarray(s3, e2));
        return n;
      };
      var ec = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
      ];
      var err = function err2(ind, msg, nt) {
        var e2 = new Error(msg || ec[ind]);
        e2.code = ind;
        if (Error.captureStackTrace)
          Error.captureStackTrace(e2, err2);
        if (!nt)
          throw e2;
        return e2;
      };
      var inflt = function inflt2(dat, buf, st) {
        var sl = dat.length;
        if (!sl || st && st.f && !st.l)
          return buf || new u8(0);
        var noBuf = !buf || st;
        var noSt = !st || st.i;
        if (!st)
          st = {};
        if (!buf)
          buf = new u8(sl * 3);
        var cbuf = function cbuf2(l2) {
          var bl = buf.length;
          if (l2 > bl) {
            var nbuf = new u8(Math.max(bl * 2, l2));
            nbuf.set(buf);
            buf = nbuf;
          }
        };
        var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
        var tbts = sl * 8;
        do {
          if (!lm) {
            final = bits(dat, pos, 1);
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
              var s3 = shft(pos) + 4, l = dat[s3 - 4] | dat[s3 - 3] << 8, t2 = s3 + l;
              if (t2 > sl) {
                if (noSt)
                  err(0);
                break;
              }
              if (noBuf)
                cbuf(bt + l);
              buf.set(dat.subarray(s3, t2), bt);
              st.b = bt += l, st.p = pos = t2 * 8, st.f = final;
              continue;
            } else if (type == 1)
              lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
              var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
              var tl = hLit + bits(dat, pos + 5, 31) + 1;
              pos += 14;
              var ldt = new u8(tl);
              var clt = new u8(19);
              for (var i3 = 0; i3 < hcLen; ++i3) {
                clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
              }
              pos += hcLen * 3;
              var clb = max(clt), clbmsk = (1 << clb) - 1;
              var clm = hMap(clt, clb, 1);
              for (var i3 = 0; i3 < tl; ) {
                var r2 = clm[bits(dat, pos, clbmsk)];
                pos += r2 & 15;
                var s3 = r2 >>> 4;
                if (s3 < 16) {
                  ldt[i3++] = s3;
                } else {
                  var c = 0, n = 0;
                  if (s3 == 16)
                    n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i3 - 1];
                  else if (s3 == 17)
                    n = 3 + bits(dat, pos, 7), pos += 3;
                  else if (s3 == 18)
                    n = 11 + bits(dat, pos, 127), pos += 7;
                  while (n--) {
                    ldt[i3++] = c;
                  }
                }
              }
              var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
              lbt = max(lt);
              dbt = max(dt);
              lm = hMap(lt, lbt, 1);
              dm = hMap(dt, dbt, 1);
            } else
              err(1);
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
          }
          if (noBuf)
            cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var lpos = pos;
          for (; ; lpos = pos) {
            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
            pos += c & 15;
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (!c)
              err(2);
            if (sym < 256)
              buf[bt++] = sym;
            else if (sym == 256) {
              lpos = pos, lm = null;
              break;
            } else {
              var add = sym - 254;
              if (sym > 264) {
                var i3 = sym - 257, b = fleb[i3];
                add = bits(dat, pos, (1 << b) - 1) + fl[i3];
                pos += b;
              }
              var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
              if (!d)
                err(3);
              pos += d & 15;
              var dt = fd[dsym];
              if (dsym > 3) {
                var b = fdeb[dsym];
                dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
              }
              if (pos > tbts) {
                if (noSt)
                  err(0);
                break;
              }
              if (noBuf)
                cbuf(bt + 131072);
              var end = bt + add;
              for (; bt < end; bt += 4) {
                buf[bt] = buf[bt - dt];
                buf[bt + 1] = buf[bt + 1 - dt];
                buf[bt + 2] = buf[bt + 2 - dt];
                buf[bt + 3] = buf[bt + 3 - dt];
              }
              bt = end;
            }
          }
          st.l = lm, st.p = lpos, st.b = bt, st.f = final;
          if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
        } while (!final);
        return bt == buf.length ? buf : slc(buf, 0, bt);
      };
      var gzs = function gzs2(d) {
        if (d[0] != 31 || d[1] != 139 || d[2] != 8)
          err(6, "invalid gzip data");
        var flg = d[3];
        var st = 10;
        if (flg & 4)
          st += d[10] | (d[11] << 8) + 2;
        for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]) {
          ;
        }
        return st + (flg & 2);
      };
      var gzl = function gzl2(d) {
        var l = d.length;
        return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
      };
      var zlv = function zlv2(d) {
        if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
          err(6, "invalid zlib data");
        if (d[1] & 32)
          err(6, "invalid zlib data: preset dictionaries not supported");
      };
      return {
        gunzipSync: function gunzipSync(data, out) {
          return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
        },
        unzlibSync: function unzlibSync(data, out) {
          return inflt((zlv(data), data.subarray(2, -4)), out);
        }
      };
    }();
    exports.algorithms = algorithms;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/PushManager/mySegmentsV2utils.js
var require_mySegmentsV2utils = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/PushManager/mySegmentsV2utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseKeyList = parseKeyList;
    exports.parseBitmap = parseBitmap;
    exports.isInBitmap = isInBitmap;
    var _decompress = require_decompress();
    var _base = require_node14();
    var GZIP = 1;
    var ZLIB = 2;
    function Uint8ArrayToString(myUint8Arr) {
      return String.fromCharCode.apply(null, myUint8Arr);
    }
    function StringToUint8Array(myString) {
      var charCodes = myString.split("").map(function(e2) {
        return e2.charCodeAt();
      });
      return new Uint8Array(charCodes);
    }
    function decompress(data, compression) {
      var compressData = (0, _base.decodeFromBase64)(data);
      var binData = StringToUint8Array(compressData);
      if (typeof _decompress.algorithms === "string")
        throw new Error(_decompress.algorithms);
      if (compression === GZIP)
        return _decompress.algorithms.gunzipSync(binData);
      if (compression === ZLIB)
        return _decompress.algorithms.unzlibSync(binData);
      throw new Error("Invalid compression algorithm #" + compression);
    }
    function parseKeyList(data, compression) {
      var binKeyList = decompress(data, compression);
      var strKeyList = Uint8ArrayToString(binKeyList);
      return JSON.parse(strKeyList.replace(/\d+/g, '"$&"'));
    }
    function parseBitmap(data, compression) {
      return decompress(data, compression);
    }
    function isInBitmap(bitmap, hash64hex) {
      var index = parseInt(hash64hex.slice(8), 16) % (bitmap.length * 8);
      var internal = Math.floor(index / 8);
      var offset = index % 8;
      return (bitmap[internal] & 1 << offset) > 0;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3_128.js
var require_murmur3_128 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3_128.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.hash128 = hash128;
    var _common = require_common2();
    function _x64Add(m2, n) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m2[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m2[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m2[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m2[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m2, n) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m2[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m2[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m2[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m2[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m2[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m2[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m2[0] * n[3] + m2[1] * n[2] + m2[2] * n[1] + m2[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m2, n) {
      n %= 64;
      if (n === 32) {
        return [m2[1], m2[0]];
      } else if (n < 32) {
        return [m2[0] << n | m2[1] >>> 32 - n, m2[1] << n | m2[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m2[1] << n | m2[0] >>> 32 - n, m2[0] << n | m2[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m2, n) {
      n %= 64;
      if (n === 0) {
        return m2;
      } else if (n < 32) {
        return [m2[0] << n | m2[1] >>> 32 - n, m2[1] << n];
      } else {
        return [m2[1] << n - 32, 0];
      }
    }
    function _x64Xor(m2, n) {
      return [m2[0] ^ n[0], m2[1] ^ n[1]];
    }
    function _x64Fmix(h2) {
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [4283543511, 3981806797]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [3301882366, 444984403]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      return h2;
    }
    function hash128x64(key2, seed) {
      key2 = key2 || "";
      seed = seed || 0;
      var remainder = key2.length % 16;
      var bytes = key2.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i2 = 0; i2 < bytes; i2 = i2 + 16) {
        k1 = [key2.charCodeAt(i2 + 4) & 255 | (key2.charCodeAt(i2 + 5) & 255) << 8 | (key2.charCodeAt(i2 + 6) & 255) << 16 | (key2.charCodeAt(i2 + 7) & 255) << 24, key2.charCodeAt(i2) & 255 | (key2.charCodeAt(i2 + 1) & 255) << 8 | (key2.charCodeAt(i2 + 2) & 255) << 16 | (key2.charCodeAt(i2 + 3) & 255) << 24];
        k2 = [key2.charCodeAt(i2 + 12) & 255 | (key2.charCodeAt(i2 + 13) & 255) << 8 | (key2.charCodeAt(i2 + 14) & 255) << 16 | (key2.charCodeAt(i2 + 15) & 255) << 24, key2.charCodeAt(i2 + 8) & 255 | (key2.charCodeAt(i2 + 9) & 255) << 8 | (key2.charCodeAt(i2 + 10) & 255) << 16 | (key2.charCodeAt(i2 + 11) & 255) << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, key2.charCodeAt(i2 + 14)], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, key2.charCodeAt(i2 + 13)], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, key2.charCodeAt(i2 + 12)], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, key2.charCodeAt(i2 + 11)], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, key2.charCodeAt(i2 + 10)], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, key2.charCodeAt(i2 + 9)], 8));
        case 9:
          k2 = _x64Xor(k2, [0, key2.charCodeAt(i2 + 8)]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 7)], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 6)], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 5)], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 4)], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 3)], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 2)], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, key2.charCodeAt(i2 + 1)], 8));
        case 1:
          k1 = _x64Xor(k1, [0, key2.charCodeAt(i2)]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, key2.length]);
      h2 = _x64Xor(h2, [0, key2.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    }
    function hash128(str, seed) {
      return hash128x64((0, _common.UTF16ToUTF8)(str), seed >>> 0);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3_64.js
var require_murmur3_64 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/engine/murmur3/murmur3_64.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.hash64 = hash64;
    var _murmur3_ = require_murmur3_128();
    function hex2dec(s3) {
      var i2, j, digits = [0], carry;
      for (i2 = 0; i2 < s3.length; i2 += 1) {
        carry = parseInt(s3.charAt(i2), 16);
        for (j = digits.length - 1; j >= 0; j -= 1) {
          digits[j] = digits[j] * 16 + carry;
          carry = digits[j] / 10 | 0;
          digits[j] %= 10;
        }
        while (carry > 0) {
          digits.unshift(carry % 10);
          carry = carry / 10 | 0;
        }
      }
      return digits.join("");
    }
    function hash64(str) {
      var hex = (0, _murmur3_.hash128)(str).slice(0, 16);
      return {
        hex,
        dec: hex2dec(hex)
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/PushManager/index.js
var require_PushManager = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/PushManager/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = PushManagerFactory;
    var _events = _interopRequireDefault(require("events"));
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _AuthClient = _interopRequireDefault(require_AuthClient());
    var _pushRequirements = require_node16();
    var _SegmentUpdateWorker = _interopRequireDefault(require_node17());
    var _SplitUpdateWorker = _interopRequireDefault(require_SplitUpdateWorker());
    var _SSEClient = _interopRequireDefault(require_SSEClient());
    var _SSEHandler = _interopRequireDefault(require_SSEHandler());
    var _backoff = _interopRequireDefault(require_backoff());
    var _hashUserKey = require_hashUserKey();
    var _logger = _interopRequireDefault(require_logger());
    var _constants = require_constants3();
    var _mySegmentsV2utils = require_mySegmentsV2utils();
    var _lang = require_lang();
    var _Sets = require_Sets();
    var _murmur3_ = require_murmur3_64();
    var log = (0, _logger.default)("splitio-sync:push-manager");
    var BoundedFetchRequest = 1;
    var KeyList = 2;
    var SegmentRemoval = 3;
    function fallbackWarning(notificationType, e2) {
      return "Fetching MySegments due to an error processing " + notificationType + " notification: " + e2;
    }
    function PushManagerFactory(context, clientContexts) {
      if (!(0, _pushRequirements.checkPushRequirements)(log))
        return;
      var pushEmitter = new _events.default();
      var _context$get = context.get(context.constants.READINESS), splitsEventEmitter = _context$get.splits;
      var settings = context.get(context.constants.SETTINGS);
      var storage = context.get(context.constants.STORAGE);
      var sseClient = _SSEClient.default.getInstance(settings, clientContexts ? false : true);
      var sseHandler = (0, _SSEHandler.default)(pushEmitter);
      sseClient.setEventHandler(sseHandler);
      var userKeyHashes = {};
      var clients = {};
      var connectForNewClient = false;
      var disconnected;
      var connectPushRetryBackoff = new _backoff.default(connectPush, settings.scheduler.pushRetryBackoffBase);
      var timeoutIdTokenRefresh;
      var timeoutIdSseOpen;
      function scheduleTokenRefreshAndSse(authData) {
        if (timeoutIdTokenRefresh)
          clearTimeout(timeoutIdTokenRefresh);
        if (timeoutIdSseOpen)
          clearTimeout(timeoutIdSseOpen);
        var decodedToken = authData.decodedToken;
        var refreshTokenDelay = decodedToken.exp - decodedToken.iat - _constants.SECONDS_BEFORE_EXPIRATION;
        var connDelay = typeof authData.connDelay === "number" && authData.connDelay >= 0 ? authData.connDelay : 60;
        log.info("Refreshing streaming token in " + refreshTokenDelay + " seconds, and connecting streaming in " + connDelay + " seconds");
        timeoutIdTokenRefresh = setTimeout(connectPush, refreshTokenDelay * 1e3);
        timeoutIdSseOpen = setTimeout(function() {
          if (disconnected)
            return;
          sseClient.open(authData);
        }, connDelay * 1e3);
      }
      function connectPush() {
        if (disconnected)
          return;
        log.info((disconnected === void 0 ? "Connecting" : "Re-connecting") + " to push streaming.");
        disconnected = false;
        var userKeys = clientContexts ? Object.keys(clientContexts) : void 0;
        (0, _AuthClient.default)(settings, userKeys).then(function(authData) {
          if (disconnected)
            return;
          if (!authData.pushEnabled) {
            log.info("Streaming is not available. Switching to polling mode.");
            pushEmitter.emit(_constants.PUSH_NONRETRYABLE_ERROR);
            return;
          }
          if (userKeys && userKeys.length < Object.keys(clientContexts).length)
            return;
          scheduleTokenRefreshAndSse(authData);
        }).catch(function(error2) {
          if (disconnected)
            return;
          log.error("Failed to authenticate for streaming. Error: " + error2.message + ".");
          if (error2.statusCode >= 400 && error2.statusCode < 500) {
            pushEmitter.emit(_constants.PUSH_NONRETRYABLE_ERROR);
            return;
          }
          pushEmitter.emit(_constants.PUSH_RETRYABLE_ERROR);
        });
      }
      function disconnectPush() {
        if (disconnected)
          return;
        disconnected = true;
        sseClient.close();
        log.info("Disconnecting from push streaming.");
        if (timeoutIdTokenRefresh)
          clearTimeout(timeoutIdTokenRefresh);
        if (timeoutIdSseOpen)
          clearTimeout(timeoutIdSseOpen);
        connectPushRetryBackoff.reset();
        stopWorkers();
      }
      pushEmitter.on(_constants.PUSH_SUBSYSTEM_DOWN, stopWorkers);
      pushEmitter.on(_constants.PUSH_SUBSYSTEM_UP, function() {
        connectPushRetryBackoff.reset();
        stopWorkers();
      });
      pushEmitter.on(_constants.PUSH_NONRETRYABLE_ERROR, function handleNonRetryableError() {
        disconnectPush();
        pushEmitter.emit(_constants.PUSH_SUBSYSTEM_DOWN);
      });
      pushEmitter.on(_constants.PUSH_RETRYABLE_ERROR, function handleRetryableError() {
        sseClient.close();
        var delayInMillis = connectPushRetryBackoff.scheduleCall();
        log.info("Attempting to reconnect in " + delayInMillis / 1e3 + " seconds.");
        pushEmitter.emit(_constants.PUSH_SUBSYSTEM_DOWN);
      });
      pushEmitter.on(_constants.ControlTypes.STREAMING_RESET, function handleStreamingReset() {
        if (disconnected)
          return;
        if (timeoutIdTokenRefresh)
          clearTimeout(timeoutIdTokenRefresh);
        connectPush();
      });
      var producer = context.get(context.constants.PRODUCER);
      var splitUpdateWorker = new _SplitUpdateWorker.default(storage.splits, producer, splitsEventEmitter);
      var segmentUpdateWorker;
      function stopWorkers() {
        splitUpdateWorker.backoff.reset();
        if (segmentUpdateWorker)
          segmentUpdateWorker.backoff.reset();
        (0, _lang.forOwn)(clients, function(_ref) {
          var worker = _ref.worker;
          return worker.backoff.reset();
        });
      }
      pushEmitter.on(_constants.SPLIT_KILL, splitUpdateWorker.killSplit);
      pushEmitter.on(_constants.SPLIT_UPDATE, splitUpdateWorker.put);
      if (clientContexts) {
        pushEmitter.on(_constants.MY_SEGMENTS_UPDATE, function handleMySegmentsUpdate(parsedData, channel) {
          var userKeyHash = channel.split("_")[2];
          var userKey = userKeyHashes[userKeyHash];
          if (userKey && clientContexts[userKey]) {
            var mySegmentSync = clientContexts[userKey].get(context.constants.MY_SEGMENTS_CHANGE_WORKER, true);
            mySegmentSync && mySegmentSync.put(parsedData.changeNumber, parsedData.includesPayload ? parsedData.segmentList ? parsedData.segmentList : [] : void 0);
          }
        });
        pushEmitter.on(_constants.MY_SEGMENTS_UPDATE_V2, function handleMySegmentsUpdate(parsedData) {
          switch (parsedData.u) {
            case BoundedFetchRequest: {
              var bitmap;
              try {
                bitmap = (0, _mySegmentsV2utils.parseBitmap)(parsedData.d, parsedData.c);
              } catch (e2) {
                log.warn(fallbackWarning("BoundedFetchRequest", e2));
                break;
              }
              (0, _lang.forOwn)(clients, function(_ref2) {
                var hash64 = _ref2.hash64, worker = _ref2.worker;
                if ((0, _mySegmentsV2utils.isInBitmap)(bitmap, hash64.hex)) {
                  worker.put(parsedData.changeNumber);
                }
              });
              return;
            }
            case KeyList: {
              var keyList, added, removed;
              try {
                keyList = (0, _mySegmentsV2utils.parseKeyList)(parsedData.d, parsedData.c);
                added = new _Sets._Set(keyList.a);
                removed = new _Sets._Set(keyList.r);
              } catch (e2) {
                log.warn(fallbackWarning("KeyList", e2));
                break;
              }
              (0, _lang.forOwn)(clients, function(_ref3) {
                var hash64 = _ref3.hash64, worker = _ref3.worker;
                var add = added.has(hash64.dec) ? true : removed.has(hash64.dec) ? false : void 0;
                if (add !== void 0) {
                  worker.put(parsedData.changeNumber, {
                    name: parsedData.segmentName,
                    add
                  });
                }
              });
              return;
            }
            case SegmentRemoval:
              if (!parsedData.segmentName) {
                log.warn(fallbackWarning("SegmentRemoval", "No segment name was provided"));
                break;
              }
              (0, _lang.forOwn)(clients, function(_ref4) {
                var worker = _ref4.worker;
                worker.put(parsedData.changeNumber, {
                  name: parsedData.segmentName,
                  add: false
                });
              });
              return;
          }
          (0, _lang.forOwn)(clients, function(_ref5) {
            var worker = _ref5.worker;
            worker.put(parsedData.changeNumber);
          });
        });
      } else {
        segmentUpdateWorker = new _SegmentUpdateWorker.default(storage.segments, producer);
        pushEmitter.on(_constants.SEGMENT_UPDATE, segmentUpdateWorker.put);
      }
      return (0, _objectAssign.default)(Object.create(pushEmitter), {
        stop: disconnectPush,
        start: connectPush,
        startNewClient: function startNewClient(userKey, context2) {
          var hash2 = (0, _hashUserKey.hashUserKey)(userKey);
          var storage2 = context2.get(context2.constants.STORAGE);
          var producer2 = context2.get(context2.constants.PRODUCER);
          if (!userKeyHashes[hash2]) {
            userKeyHashes[hash2] = userKey;
            connectForNewClient = true;
          }
          var mySegmentSync = new _SegmentUpdateWorker.default(storage2.segments, producer2);
          clients[userKey] = {
            worker: mySegmentSync,
            hash64: (0, _murmur3_.hash64)(userKey)
          };
          context2.put(context2.constants.MY_SEGMENTS_CHANGE_WORKER, mySegmentSync);
          setTimeout(function checkForReconnect() {
            if (connectForNewClient) {
              connectForNewClient = false;
              connectPush();
            }
          }, 0);
        },
        removeClient: function removeClient(userKey) {
          var hash2 = (0, _hashUserKey.hashUserKey)(userKey);
          delete userKeyHashes[hash2];
          delete clients[userKey];
        }
      });
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/splitChanges/index.js
var require_splitChanges = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/splitChanges/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _transport = _interopRequireDefault(require_transport());
    var _default = _transport.default;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/splitChanges/get.js
var require_get = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/splitChanges/get.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    exports.__esModule = true;
    exports.default = GET;
    var _request = _interopRequireWildcard(require_request());
    function GET(settings, since, filterQueryString, noCache) {
      return (0, _request.default)(settings, "/splitChanges?since=" + since + (filterQueryString || ""), void 0, noCache ? _request.noCacheExtraHeader : void 0);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/fetcher/SplitChanges.js
var require_SplitChanges = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/fetcher/SplitChanges.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _timeout = _interopRequireDefault(require_timeout());
    var _timeTracker = _interopRequireDefault(require_timeTracker());
    var _Errors = require_Errors();
    var _splitChanges = _interopRequireDefault(require_splitChanges());
    var _get = _interopRequireDefault(require_get());
    function splitChangesFetcher(settings, since, startingUp, metricCollectors, isNode, noCache) {
      if (startingUp === void 0) {
        startingUp = false;
      }
      var filterQueryString = settings.sync.__splitFiltersValidation.queryString;
      var splitsPromise = (0, _splitChanges.default)((0, _get.default)(settings, since, filterQueryString, noCache));
      var collectMetrics = startingUp || isNode;
      splitsPromise = _timeTracker.default.start(_timeTracker.default.TaskNames.SPLITS_FETCH, collectMetrics ? metricCollectors : false, splitsPromise);
      if (startingUp) {
        splitsPromise = (0, _timeout.default)(settings.startup.requestTimeoutBeforeReady, splitsPromise);
      }
      return splitsPromise.then(function(resp) {
        return resp.json().catch(function(error2) {
          throw new _Errors.SplitError(error2.message);
        });
      });
    }
    var _default = splitChangesFetcher;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/engine/parser/segments.js
var require_segments = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/engine/parser/segments.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _Sets = require_Sets();
    var parseSegments = function parseSegments2(conditions) {
      var segments = new _Sets._Set();
      conditions.forEach(function(condition) {
        var matchers = condition.matcherGroup.matchers;
        matchers.forEach(function(matcher) {
          var matcherType = matcher.matcherType, userDefinedSegmentMatcherData = matcher.userDefinedSegmentMatcherData;
          if (matcherType === "IN_SEGMENT") {
            segments.add(userDefinedSegmentMatcherData.segmentName);
          }
        });
      });
      return segments;
    };
    var _default = parseSegments;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/updater/SplitChanges.js
var require_SplitChanges2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/updater/SplitChanges.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = SplitChangesUpdaterFactory;
    var _logger = _interopRequireDefault(require_logger());
    var _SplitChanges = _interopRequireDefault(require_SplitChanges());
    var _segments = _interopRequireDefault(require_segments());
    var _Errors = require_Errors();
    var _Sets = require_Sets();
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-producer:split-changes");
    function checkAllSegmentsExist(segmentsStorage) {
      return segmentsStorage.getRegisteredSegments().every(function(segmentName) {
        return segmentsStorage.getChangeNumber(segmentName) !== -1;
      });
    }
    function computeSplitsMutation(entries) {
      var computed = entries.reduce(function(accum, split2) {
        if (split2.status === "ACTIVE") {
          accum.added.push([split2.name, JSON.stringify(split2)]);
          (0, _segments.default)(split2.conditions).forEach(function(segmentName) {
            accum.segments.add(segmentName);
          });
        } else {
          accum.removed.push(split2.name);
        }
        return accum;
      }, {
        added: [],
        removed: [],
        segments: new _Sets._Set()
      });
      computed.segments = (0, _Sets.setToArray)(computed.segments);
      return computed;
    }
    function SplitChangesUpdaterFactory(context, isNode) {
      if (isNode === void 0) {
        isNode = false;
      }
      var _context$getAll = context.getAll(), settings = _context$getAll[context.constants.SETTINGS], readiness2 = _context$getAll[context.constants.READINESS], storage = _context$getAll[context.constants.STORAGE], metricCollectors = _context$getAll[context.constants.COLLECTORS];
      var splitsEventEmitter = readiness2.splits;
      var startingUp = true;
      var readyOnAlreadyExistentState = true;
      return function SplitChangesUpdater(retry, noCache) {
        if (retry === void 0) {
          retry = 0;
        }
        function splitChanges(since2) {
          log.debug("Spin up split update using since = " + since2);
          var fetcherPromise = (0, _SplitChanges.default)(settings, since2, startingUp, metricCollectors, isNode, noCache).then(function(splitChanges2) {
            startingUp = false;
            var mutation = computeSplitsMutation(splitChanges2.splits);
            log.debug("New splits " + mutation.added.length);
            log.debug("Removed splits " + mutation.removed.length);
            log.debug("Segment names collected " + mutation.segments);
            return Promise.all([
              storage.splits.setChangeNumber(splitChanges2.till),
              storage.splits.addSplits(mutation.added),
              storage.splits.removeSplits(mutation.removed),
              storage.segments.registerSegments(mutation.segments)
            ]).then(function() {
              if (readyOnAlreadyExistentState || since2 !== splitChanges2.till && (!isNode || checkAllSegmentsExist(storage.segments))) {
                readyOnAlreadyExistentState = false;
                splitsEventEmitter.emit(splitsEventEmitter.SDK_SPLITS_ARRIVED);
              }
            });
          }).catch(function(error2) {
            if (!(error2 instanceof _Errors.SplitError)) {
              setTimeout(function() {
                throw error2;
              }, 0);
              startingUp = false;
            }
            log.warn("Error while doing fetch of Splits. " + error2);
            if (startingUp && settings.startup.retriesOnFailureBeforeReady > retry) {
              retry += 1;
              log.info("Retrying download of splits #" + retry + ". Reason: " + error2);
              return SplitChangesUpdater(retry, noCache);
            } else {
              startingUp = false;
            }
            return false;
          });
          if (startingUp && storage.splits.checkCache()) {
            splitsEventEmitter.emit(splitsEventEmitter.SDK_SPLITS_CACHE_LOADED);
          }
          return fetcherPromise;
        }
        var since = storage.splits.getChangeNumber();
        var sincePromise = (0, _thenable.default)(since) ? since : Promise.resolve(since);
        return sincePromise.then(splitChanges);
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/segmentChanges/index.js
var require_segmentChanges = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/segmentChanges/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _transport = _interopRequireDefault(require_transport());
    var _default = _transport.default;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/segmentChanges/get.js
var require_get2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/segmentChanges/get.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    exports.__esModule = true;
    exports.default = GET;
    var _request = _interopRequireWildcard(require_request());
    function GET(settings, _ref, noCache) {
      var since = _ref.since, segmentName = _ref.segmentName;
      return (0, _request.default)(settings, "/segmentChanges/" + segmentName + "?since=" + since, void 0, noCache ? _request.noCacheExtraHeader : void 0);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/fetcher/SegmentChanges.js
var require_SegmentChanges = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/fetcher/SegmentChanges.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _segmentChanges = _interopRequireDefault(require_segmentChanges());
    var _get = _interopRequireDefault(require_get2());
    var _timeTracker = _interopRequireDefault(require_timeTracker());
    function greedyFetch(settings, lastSinceValue, segmentName, metricCollectors, noCache) {
      return _timeTracker.default.start(_timeTracker.default.TaskNames.SEGMENTS_FETCH, metricCollectors, (0, _segmentChanges.default)((0, _get.default)(settings, {
        since: lastSinceValue,
        segmentName
      }, noCache))).then(function(resp) {
        return resp.json();
      }).then(function(json) {
        var since = json.since, till = json.till;
        if (since === till) {
          return [json];
        } else {
          return Promise.all([json, greedyFetch(settings, till, segmentName, void 0, noCache)]).then(function(flatMe) {
            return [flatMe[0]].concat(flatMe[1]);
          });
        }
      }).catch(function(err) {
        if (err.statusCode === 403)
          throw err;
        return [];
      });
    }
    function segmentChangesFetcher(settings, segmentName, since, metricCollectors, noCache) {
      return greedyFetch(settings, since, segmentName, metricCollectors, noCache);
    }
    var _default = segmentChangesFetcher;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/updater/SegmentChanges.js
var require_SegmentChanges2 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/updater/SegmentChanges.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = SegmentChangesUpdaterFactory;
    var _logger = _interopRequireDefault(require_logger());
    var _SegmentChanges = _interopRequireDefault(require_SegmentChanges());
    var _lang = require_lang();
    var _Errors = require_Errors();
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-producer:segment-changes");
    var inputValidationLog = (0, _logger.default)("", {
      displayAllErrors: true
    });
    function SegmentChangesUpdaterFactory(context) {
      var _context$getAll = context.getAll(), settings = _context$getAll[context.constants.SETTINGS], readiness2 = _context$getAll[context.constants.READINESS], storage = _context$getAll[context.constants.STORAGE], metricCollectors = _context$getAll[context.constants.COLLECTORS];
      var segmentsEventEmitter = readiness2.segments;
      var segmentsStorage = storage.segments;
      var readyOnAlreadyExistentState = true;
      return function SegmentChangesUpdater(segmentNames, noCache, fetchOnlyNew) {
        log.debug("Started segments update");
        var updaters = [];
        function segmentsUpdater(segments2) {
          var sincePromises = [];
          var _loop = function _loop2(index2) {
            var segmentName = segments2[index2];
            var segmentUpdater = function segmentUpdater2(since2) {
              log.debug("Processing segment " + segmentName);
              updaters.push((0, _SegmentChanges.default)(settings, segmentName, since2, metricCollectors, noCache).then(function(changes) {
                var changeNumber = -1;
                var changePromises = [];
                changes.forEach(function(x2) {
                  var promises = [];
                  if (x2.added.length > 0) {
                    var result = segmentsStorage.addToSegment(segmentName, x2.added);
                    if ((0, _thenable.default)(result))
                      promises.push(result);
                  }
                  if (x2.removed.length > 0) {
                    var _result = segmentsStorage.removeFromSegment(segmentName, x2.removed);
                    if ((0, _thenable.default)(_result))
                      promises.push(_result);
                  }
                  if (x2.added.length > 0 || x2.removed.length > 0) {
                    var _result2 = segmentsStorage.setChangeNumber(segmentName, x2.till);
                    if ((0, _thenable.default)(_result2))
                      promises.push(_result2);
                    changeNumber = x2.till;
                  }
                  log.debug("Processed " + segmentName + " with till = " + x2.till + ". Added: " + x2.added.length + ". Removed: " + x2.removed.length);
                  if (promises.length > 0)
                    changePromises.push.apply(changePromises, promises);
                });
                return Promise.all(changePromises).then(function() {
                  return changeNumber;
                });
              }));
            };
            var since = segmentsStorage.getChangeNumber(segmentName);
            var sincePromise = (0, _thenable.default)(since) ? since.then(segmentUpdater) : segmentUpdater(since);
            sincePromises.push(sincePromise);
          };
          for (var index = 0; index < segments2.length; index++) {
            _loop(index);
          }
          return Promise.all(sincePromises).then(function() {
            return Promise.all(updaters).then(function(shouldUpdateFlags) {
              if ((0, _lang.findIndex)(shouldUpdateFlags, function(v) {
                return v !== -1;
              }) !== -1 || readyOnAlreadyExistentState) {
                readyOnAlreadyExistentState = false;
                segmentsEventEmitter.emit(segmentsEventEmitter.SDK_SEGMENTS_ARRIVED);
              }
              if (shouldUpdateFlags.indexOf(-1) !== -1)
                return false;
            }).catch(function(error2) {
              if (!(error2 instanceof _Errors.SplitError))
                setTimeout(function() {
                  throw error2;
                }, 0);
              if (error2.statusCode === 403) {
                context.put(context.constants.DESTROYED, true);
                inputValidationLog.error("Factory instantiation: you passed a Browser type authorizationKey, please grab an Api Key from the Split web console that is of type SDK.");
              }
              return false;
            });
          });
        }
        var segments = segmentNames ? segmentNames : segmentsStorage.getRegisteredSegments();
        if (fetchOnlyNew)
          segments = segments.filter(function(segmentName) {
            return segmentsStorage.getChangeNumber(segmentName) === -1;
          });
        return (0, _thenable.default)(segments) ? segments.then(segmentsUpdater) : segmentsUpdater(segments);
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/node.js
var require_node18 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _repeat = _interopRequireDefault(require_repeat());
    var _SplitChanges = _interopRequireDefault(require_SplitChanges2());
    var _SegmentChanges = _interopRequireDefault(require_SegmentChanges2());
    var log = (0, _logger.default)("splitio-producer:updater");
    var NodeUpdater = function NodeUpdater2(context) {
      var splitsUpdater = (0, _SplitChanges.default)(context, true);
      var segmentsUpdater = (0, _SegmentChanges.default)(context);
      var settings = context.get(context.constants.SETTINGS);
      var stopSplitsUpdate = false;
      var stopSegmentsUpdate = false;
      var splitFetchCompleted = false;
      var _isRunning = false;
      var _isSynchronizingSplits = false;
      var _isSynchronizingSegments = false;
      function synchronizeSplits(noCache) {
        _isSynchronizingSplits = true;
        return splitsUpdater(0, noCache).then(function(res) {
          splitFetchCompleted = true;
          _isSynchronizingSplits = false;
          return res;
        });
      }
      function synchronizeSegment(segmentNames, noCache, fetchOnlyNew) {
        _isSynchronizingSegments = true;
        return segmentsUpdater(segmentNames, noCache, fetchOnlyNew).then(function(res) {
          _isSynchronizingSegments = false;
          return res;
        });
      }
      return {
        start: function start() {
          log.info("Starting NODEJS updater");
          log.debug("Splits will be refreshed each " + settings.scheduler.featuresRefreshRate + " millis");
          log.debug("Segments will be refreshed each " + settings.scheduler.segmentsRefreshRate + " millis");
          var spinUpSegmentUpdater = function spinUpSegmentUpdater2() {
            if (stopSplitsUpdate && !stopSegmentsUpdate) {
              stopSegmentsUpdate = (0, _repeat.default)(function(scheduleSegmentsUpdate) {
                if (splitFetchCompleted) {
                  log.debug("Fetching segments");
                  synchronizeSegment().then(function() {
                    return scheduleSegmentsUpdate();
                  });
                } else {
                  scheduleSegmentsUpdate();
                }
              }, settings.scheduler.segmentsRefreshRate);
            }
          };
          stopSplitsUpdate = (0, _repeat.default)(function(scheduleSplitsUpdate) {
            log.debug("Fetching splits");
            synchronizeSplits().then(function() {
              spinUpSegmentUpdater();
              scheduleSplitsUpdate();
            });
          }, settings.scheduler.featuresRefreshRate);
          _isRunning = true;
        },
        stop: function stop() {
          log.info("Stopping NODEJS updater");
          stopSplitsUpdate && stopSplitsUpdate();
          stopSplitsUpdate = false;
          stopSegmentsUpdate && stopSegmentsUpdate();
          stopSegmentsUpdate = false;
          _isRunning = false;
        },
        isRunning: function isRunning() {
          return _isRunning;
        },
        isSynchronizingSplits: function isSynchronizingSplits() {
          return _isSynchronizingSplits;
        },
        synchronizeSplits,
        isSynchronizingSegments: function isSynchronizingSegments() {
          return _isSynchronizingSegments;
        },
        synchronizeSegment
      };
    };
    var _default = NodeUpdater;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/sync/node.js
var require_node19 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/sync/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = NodeSyncManagerFactory;
    var _PushManager = _interopRequireDefault(require_PushManager());
    var _producer = _interopRequireDefault(require_node18());
    var _logger = _interopRequireDefault(require_logger());
    var _constants = require_constants3();
    var log = (0, _logger.default)("splitio-sync:sync-manager");
    function NodeSyncManagerFactory(context) {
      var producer = (0, _producer.default)(context);
      var settings = context.get(context.constants.SETTINGS);
      context.put(context.constants.PRODUCER, producer);
      var pushManager = settings.streamingEnabled ? (0, _PushManager.default)(context) : void 0;
      function startPolling() {
        if (!producer.isRunning()) {
          log.info("Streaming not available. Starting periodic fetch of data.");
          producer.start();
        } else {
          log.info("Streaming couldn't connect. Continue periodic fetch of data.");
        }
      }
      function stopPollingAndSyncAll() {
        log.info("PUSH (re)connected. Syncing and stopping periodic fetch of data.");
        if (producer.isRunning())
          producer.stop();
        syncAll();
      }
      function syncAll() {
        producer.synchronizeSplits().then(function() {
          producer.synchronizeSegment();
        });
      }
      return {
        start: function start() {
          if (pushManager) {
            syncAll();
            pushManager.on(_constants.PUSH_SUBSYSTEM_UP, stopPollingAndSyncAll);
            pushManager.on(_constants.PUSH_SUBSYSTEM_DOWN, startPolling);
            setTimeout(pushManager.start);
          } else {
            producer.start();
          }
        },
        stop: function stop() {
          if (pushManager)
            pushManager.stop();
          if (producer.isRunning())
            producer.stop();
        }
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/listeners/node.js
var require_node20 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/listeners/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _thenable = _interopRequireDefault(require_thenable());
    var log = (0, _logger.default)("splitio-client:cleanup");
    var NodeSignalListener = /* @__PURE__ */ function() {
      function NodeSignalListener2() {
        this._sigtermHandler = this._sigtermHandler.bind(this);
      }
      var _proto = NodeSignalListener2.prototype;
      _proto.start = function start(handler) {
        this.handler = handler;
        log.debug("Registering cleanup handlers.");
        process.on("SIGTERM", this._sigtermHandler);
      };
      _proto.stop = function stop() {
        log.debug("Deregistering cleanup handlers.");
        process.removeListener("SIGTERM", this._sigtermHandler);
      };
      _proto._sigtermHandler = function _sigtermHandler() {
        var _this = this;
        var wrapUp = function wrapUp2() {
          _this.stop();
          process.kill(process.pid, "SIGTERM");
        };
        log.debug("Split SDK graceful shutdown after SIGTERM.");
        var handlerResult = null;
        try {
          handlerResult = this.handler();
        } catch (err) {
          log.error("Error with Split graceful shutdown: " + err);
        }
        if ((0, _thenable.default)(handlerResult)) {
          return handlerResult.then(wrapUp).catch(wrapUp);
        } else {
          wrapUp();
        }
      };
      return NodeSignalListener2;
    }();
    exports.default = NodeSignalListener;
  }
});

// node_modules/@splitsoftware/splitio/lib/factory/online.js
var require_online = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/factory/online.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _client = _interopRequireDefault(require_node11());
    var _metrics = _interopRequireDefault(require_metrics2());
    var _events = _interopRequireDefault(require_events2());
    var _sync = _interopRequireDefault(require_node19());
    var _listeners = _interopRequireDefault(require_node20());
    var _inputValidation = require_inputValidation();
    var _constants = require_constants();
    var syncManagers = {};
    function SplitFactoryOnline(context, readyTrackers, mainClientMetricCollectors) {
      var sharedInstance = !!mainClientMetricCollectors;
      var settings = context.get(context.constants.SETTINGS);
      var readiness2 = context.get(context.constants.READINESS);
      var storage = context.get(context.constants.STORAGE);
      var statusManager = context.get(context.constants.STATUS_MANAGER);
      var gate = readiness2.gate, splits = readiness2.splits, segments = readiness2.segments;
      var SDK_READY = gate.SDK_READY;
      var metrics = sharedInstance ? void 0 : (0, _metrics.default)(context);
      var events = sharedInstance ? void 0 : (0, _events.default)(context);
      var syncManager;
      switch (settings.mode) {
        case _constants.PRODUCER_MODE:
        case _constants.STANDALONE_MODE: {
          context.put(context.constants.COLLECTORS, metrics && metrics.collectors);
          if (sharedInstance) {
            syncManager = syncManagers[settings.core.authorizationKey].shared(context);
          } else {
            syncManager = (0, _sync.default)(context);
            syncManagers[settings.core.authorizationKey] = syncManager;
          }
          break;
        }
        case _constants.CONSUMER_MODE: {
          context.put(context.constants.READY_FROM_CACHE, true);
          break;
        }
      }
      var signalsListener = sharedInstance ? void 0 : new _listeners.default(context, syncManager);
      if (readyTrackers && syncManager && !sharedInstance) {
        var sdkReadyTracker = readyTrackers.sdkReadyTracker, splitsReadyTracker = readyTrackers.splitsReadyTracker, segmentsReadyTracker = readyTrackers.segmentsReadyTracker;
        sdkReadyTracker.setCollectorForTask(metrics.collectors);
        gate.once(SDK_READY, sdkReadyTracker);
        splits.once(splits.SDK_SPLITS_ARRIVED, splitsReadyTracker);
        segments.once(segments.SDK_SEGMENTS_ARRIVED, segmentsReadyTracker);
      }
      syncManager && syncManager.start();
      metrics && metrics.start();
      events && context.put(context.constants.EVENTS, events) && events.start();
      context.put(context.constants.COLLECTORS, mainClientMetricCollectors);
      var api = (0, _objectAssign.default)(Object.create(statusManager), (0, _client.default)(context), {
        destroy: function destroy() {
          syncManager && syncManager.stop();
          metrics && metrics.stop();
          events && events.stop();
          return Promise.all([metrics && metrics.flush(), events && events.flush()]).then(function() {
            readiness2.destroy();
            signalsListener && signalsListener.stop();
            storage.destroy && storage.destroy();
            context.put(context.constants.DESTROYED, true);
            if (!sharedInstance) {
              (0, _inputValidation.releaseApiKey)(settings.core.authorizationKey);
              delete syncManagers[settings.core.authorizationKey];
            }
          });
        }
      });
      !sharedInstance && signalsListener.start(api.destroy);
      return {
        api,
        metricCollectors: metrics && metrics.collectors
      };
    }
    var _default = SplitFactoryOnline;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/task.js
var require_task = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/task.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var _repeat = _interopRequireDefault(require_repeat());
    var _lang = require_lang();
    var log = (0, _logger.default)("splitio-producer:task");
    var TaskFactory = function TaskFactory2(updater, period) {
      var updaterName = (0, _lang.getFnName)(updater);
      var stopUpdater = false;
      return {
        start: function start() {
          if (!stopUpdater) {
            log.debug("Starting " + updaterName + " refreshing each " + period);
            stopUpdater = (0, _repeat.default)(function(reschedule) {
              log.debug("Running " + updaterName);
              updater().then(function() {
                return reschedule();
              });
            }, period);
          }
        },
        stop: function stop() {
          log.debug("Stopping " + updaterName);
          stopUpdater && stopUpdater();
          stopUpdater = false;
        },
        isRunning: function isRunning() {
          return stopUpdater ? true : false;
        }
      };
    };
    var _default = TaskFactory;
    exports.default = _default;
  }
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common3 = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/common.js"(exports, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key2, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key2 = sourceKeys[index];
          target[key2] = source[key2];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/exception.js"(exports, module2) {
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/mark.js"(exports, module2) {
    "use strict";
    var common = require_common3();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  }
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema.js"(exports, module2) {
    "use strict";
    var common = require_common3();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types2;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types2 = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types2 = common.toArray(types2);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types2.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types2
      });
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/str.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/map.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/null.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/int.js"(exports, module2) {
    "use strict";
    var common = require_common3();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base2, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base2 = 1;
        digits.forEach(function(d) {
          value += d * base2;
          base2 *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/float.js"(exports, module2) {
    "use strict";
    var common = require_common3();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base2, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base2 = 1;
        digits.forEach(function(d) {
          value += d * base2;
          base2 *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_json()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports, module2) {
    "use strict";
    var NodeBuffer;
    try {
      _require = require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set2 = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/set.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key2, object = data;
      for (key2 in object) {
        if (_hasOwnProperty.call(object, key2)) {
          if (object[key2] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set2()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports, module2) {
    "use strict";
    var esprima;
    try {
      _require = require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/loader.js"(exports, module2) {
    "use strict";
    var common = require_common3();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i2 = 0; i2 < 256; i2++) {
      simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
      simpleEscapeMap[i2] = simpleEscapeSequence(i2);
    }
    var i2;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key2, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key2 = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key2)) {
          destination[key2] = source[key2];
          overridableKeys[key2] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!state.anchorMap.hasOwnProperty(alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      var documents = loadDocuments(input, options), index, length;
      if (typeof iterator !== "function") {
        return documents;
      }
      for (index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load2(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, output, options) {
      if (typeof output === "function") {
        loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
      } else {
        return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
      }
    }
    function safeLoad(input, options) {
      return load2(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load2;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/dumper.js"(exports, module2) {
    "use strict";
    var common = require_common3();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isPlainSafe(c) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i2;
      var char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i2 = 0; i2 < string.length; i2++) {
          char = string.charCodeAt(i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char);
        }
      } else {
        for (i2 = 0; i2 < string.length; i2++) {
          char = string.charCodeAt(i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i2 = 0; i2 < string.length; i2++) {
        char = string.charCodeAt(i2);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i2 + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i2++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i2] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = state.condenseFlow ? '"' : "";
        if (index !== 0)
          pairBuffer += ", ";
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/lib/js-yaml.js"(exports, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/js-yaml/index.js"(exports, module2) {
    "use strict";
    var yaml = require_js_yaml();
    module2.exports = yaml;
  }
});

// node_modules/@splitsoftware/splitio/lib/services/splitChanges/offline/parseCondition.js
var require_parseCondition = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/splitChanges/offline/parseCondition.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = parseCondition;
    var _lang = require_lang();
    function parseCondition(data) {
      var treatment = data.treatment;
      if (data.keys) {
        return {
          conditionType: "WHITELIST",
          matcherGroup: {
            combiner: "AND",
            matchers: [{
              keySelector: null,
              matcherType: "WHITELIST",
              negate: false,
              whitelistMatcherData: {
                whitelist: (0, _lang.isString)(data.keys) ? [data.keys] : data.keys
              }
            }]
          },
          partitions: [{
            treatment,
            size: 100
          }],
          label: "whitelisted " + treatment
        };
      } else {
        return {
          conditionType: "ROLLOUT",
          matcherGroup: {
            combiner: "AND",
            matchers: [{
              keySelector: null,
              matcherType: "ALL_KEYS",
              negate: false
            }]
          },
          partitions: [{
            treatment,
            size: 100
          }],
          label: "default rule"
        };
      }
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/services/splitChanges/offline/node.js
var require_node21 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/services/splitChanges/offline/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = createGetSplitConfigForFile;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _jsYaml = _interopRequireDefault(require_js_yaml2());
    var _logger = _interopRequireDefault(require_logger());
    var _lang = require_lang();
    var _parseCondition = _interopRequireDefault(require_parseCondition());
    var log = (0, _logger.default)("splitio-offline:splits-fetcher");
    var DEFAULT_FILENAME = ".split";
    function configFilesPath(config) {
      if (config === void 0) {
        config = {};
      }
      var configFilePath = config.features;
      if (configFilePath === DEFAULT_FILENAME || !(0, _lang.isString)(configFilePath)) {
        var root = process.env.HOME;
        if (process.env.SPLIT_CONFIG_ROOT)
          root = process.env.SPLIT_CONFIG_ROOT;
        if (!root)
          throw new Error("Missing split mock configuration root.");
        configFilePath = _path.default.join(root, DEFAULT_FILENAME);
      }
      if (!((0, _lang.endsWith)(configFilePath, ".yaml", true) || (0, _lang.endsWith)(configFilePath, ".yml", true) || (0, _lang.endsWith)(configFilePath, ".split", true)))
        throw new Error('Invalid extension specified for Splits mock file. Accepted extensions are ".yml" and ".yaml". Your specified file is ' + configFilePath);
      if (!_fs.default.existsSync(configFilePath))
        throw new Error("Split configuration not found in " + configFilePath + " - Please review your Split file location.");
      return configFilePath;
    }
    function arrangeConditions(mocksData) {
      (0, _lang.forOwn)(mocksData, function(data) {
        var conditions = data.conditions;
        var firstRolloutCondition = (0, _lang.find)(conditions, function(cond) {
          return cond.conditionType === "ROLLOUT";
        });
        var treatments = (0, _lang.uniq)(data.treatments);
        var allTreatmentsCondition = firstRolloutCondition ? firstRolloutCondition : conditions[0];
        var fullyAllocatedTreatment = allTreatmentsCondition.partitions[0].treatment;
        treatments.forEach(function(treatment) {
          if (treatment !== fullyAllocatedTreatment) {
            allTreatmentsCondition.partitions.push({
              treatment,
              size: 0
            });
          }
        });
        delete data.treatments;
      });
    }
    function createGetSplitConfigForFile() {
      var previousMock = "NO_MOCK_LOADED";
      function readSplitConfigFile(filePath) {
        var SPLIT_POSITION = 0;
        var TREATMENT_POSITION = 1;
        var data;
        try {
          data = _fs.default.readFileSync(filePath, "utf-8");
        } catch (e2) {
          log.error(e2.message);
          return {};
        }
        if (data === previousMock)
          return false;
        previousMock = data;
        var splitObjects = data.split(/\r?\n/).reduce(function(accum, line, index) {
          var tuple = line.trim();
          if (tuple === "" || tuple.charAt(0) === "#") {
            log.debug("Ignoring empty line or comment at #" + index);
          } else {
            tuple = tuple.split(/\s+/);
            if (tuple.length !== 2) {
              log.debug("Ignoring line since it does not have exactly two columns #" + index);
            } else {
              var splitName = tuple[SPLIT_POSITION];
              var condition = (0, _parseCondition.default)({
                treatment: tuple[TREATMENT_POSITION]
              });
              accum[splitName] = {
                conditions: [condition],
                configurations: {},
                trafficTypeName: "localhost"
              };
            }
          }
          return accum;
        }, {});
        return splitObjects;
      }
      function readYAMLConfigFile(filePath) {
        var data = "";
        var yamldoc = null;
        try {
          data = _fs.default.readFileSync(filePath, "utf8");
          if (data === previousMock)
            return false;
          previousMock = data;
          yamldoc = _jsYaml.default.safeLoad(data);
        } catch (e2) {
          log.error(e2);
          return {};
        }
        var mocksData = yamldoc.reduce(function(accum, splitEntry) {
          var splitName = Object.keys(splitEntry)[0];
          if (!splitName || !(0, _lang.isString)(splitEntry[splitName].treatment))
            log.error("Ignoring entry on YAML since the format is incorrect.");
          var mockData = splitEntry[splitName];
          if (!accum[splitName]) {
            accum[splitName] = {
              configurations: {},
              conditions: [],
              treatments: [],
              trafficTypeName: "localhost"
            };
          }
          if (mockData.config)
            accum[splitName].configurations[mockData.treatment] = mockData.config;
          var condition = (0, _parseCondition.default)(mockData);
          accum[splitName].conditions[condition.conditionType === "ROLLOUT" ? "push" : "unshift"](condition);
          accum[splitName].treatments.push(mockData.treatment);
          return accum;
        }, {});
        arrangeConditions(mocksData);
        return mocksData;
      }
      return function getSplitConfigForFile(settings) {
        var filePath = configFilesPath(settings);
        var mockData = null;
        if ((0, _lang.endsWith)(filePath, ".split")) {
          log.warn(".split mocks will be deprecated soon in favor of YAML files, which provide more targeting power. Take a look in our documentation.");
          mockData = readSplitConfigFile(filePath);
        } else {
          mockData = readYAMLConfigFile(filePath);
        }
        return mockData;
      };
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/updater/SplitChangesFromObject.js
var require_SplitChangesFromObject = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/updater/SplitChangesFromObject.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _constants = require_constants();
    var _lang = require_lang();
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("splitio-producer:offline");
    function FromObjectUpdaterFactory(Fetcher, context) {
      var _context$getAll = context.getAll(), settings = _context$getAll[context.constants.SETTINGS], readiness2 = _context$getAll[context.constants.READINESS], storage = _context$getAll[context.constants.STORAGE];
      var startingUp = true;
      return function ObjectUpdater() {
        var splits = [];
        var loadError = null;
        var splitsMock = {};
        try {
          splitsMock = Fetcher(settings);
        } catch (err) {
          loadError = err;
          log.error("There was an issue loading the mock Splits data, no changes will be applied to the current cache. " + err);
        }
        if (!loadError && splitsMock) {
          log.debug("Splits data: ");
          log.debug(JSON.stringify(splitsMock));
          (0, _lang.forOwn)(splitsMock, function(val, name) {
            splits.push([name, JSON.stringify({
              name,
              status: "ACTIVE",
              killed: false,
              trafficAllocation: 100,
              defaultTreatment: "control",
              conditions: val.conditions || [],
              configurations: val.configurations,
              trafficTypeName: val.trafficTypeName
            })]);
          });
          return Promise.all([
            storage.splits.flush(),
            storage.splits.addSplits(splits)
          ]).then(function() {
            readiness2.splits.emit(readiness2.splits.SDK_SPLITS_ARRIVED);
            if (startingUp) {
              startingUp = false;
              if (settings.storage.__originalType === _constants.STORAGE_LOCALSTORAGE)
                readiness2.splits.emit(readiness2.splits.SDK_SPLITS_CACHE_LOADED);
              readiness2.segments.emit(readiness2.segments.SDK_SEGMENTS_ARRIVED);
            }
          });
        } else {
          return Promise.resolve();
        }
      };
    }
    var _default = FromObjectUpdaterFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/updater/SplitChangesFromFileSystem.js
var require_SplitChangesFromFileSystem = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/updater/SplitChangesFromFileSystem.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = createSplitChangesFromObject;
    var _offline = _interopRequireDefault(require_node21());
    var _SplitChangesFromObject = _interopRequireDefault(require_SplitChangesFromObject());
    function createSplitChangesFromObject(context) {
      var fetcher = (0, _offline.default)();
      return (0, _SplitChangesFromObject.default)(fetcher, context);
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/producer/offline/node.js
var require_node22 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/producer/offline/node.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _task = _interopRequireDefault(require_task());
    var _SplitChangesFromFileSystem = _interopRequireDefault(require_SplitChangesFromFileSystem());
    var OfflineFileSystemProducer = function OfflineFileSystemProducer2(context) {
      var settings = context.get(context.constants.SETTINGS);
      var updater = (0, _SplitChangesFromFileSystem.default)(context);
      var updaterTask = (0, _task.default)(updater, settings.scheduler.offlineRefreshRate);
      return updaterTask;
    };
    var _default = OfflineFileSystemProducer;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/factory/offline.js
var require_offline = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/factory/offline.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _client = _interopRequireDefault(require_node11());
    var _offline = _interopRequireDefault(require_node22());
    var _inputValidation = require_inputValidation();
    function SplitFactoryOffline(context, sharedTrackers) {
      var sharedInstance = !sharedTrackers;
      var readiness2 = context.get(context.constants.READINESS);
      var storage = context.get(context.constants.STORAGE);
      var statusManager = context.get(context.constants.STATUS_MANAGER);
      if (sharedInstance)
        setTimeout(function() {
          readiness2.splits.on(readiness2.splits.SDK_SPLITS_ARRIVED, function() {
            readiness2.gate.emit(readiness2.gate.SDK_UPDATE);
          });
          readiness2.gate.emit(readiness2.gate.SDK_READY);
        }, 0);
      var producer = sharedInstance ? void 0 : (0, _offline.default)(context);
      producer && producer.start();
      var api = (0, _objectAssign.default)(Object.create(statusManager), (0, _client.default)(context), {
        destroy: function destroy() {
          producer && producer.stop();
          readiness2.destroy();
          storage.destroy && storage.destroy();
          context.put(context.constants.DESTROYED, true);
          !sharedInstance && (0, _inputValidation.releaseApiKey)();
          return Promise.resolve();
        }
      });
      return {
        api,
        metricCollectors: false
      };
    }
    var _default = SplitFactoryOffline;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/utils/promise/wrapper.js
var require_wrapper = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/utils/promise/wrapper.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = promiseWrapper;
    function promiseWrapper(customPromise, defaultOnRejected) {
      var hasOnFulfilled = false;
      var hasOnRejected = false;
      function chain(promise) {
        var newPromise = new Promise(function(res, rej) {
          return promise.then(res, function(value) {
            if (hasOnRejected) {
              rej(value);
            } else {
              defaultOnRejected(value);
            }
          });
        });
        var originalThen = newPromise.then;
        Object.defineProperty(newPromise, "then", {
          value: function value(onfulfilled, onrejected) {
            var result2 = originalThen.call(newPromise, onfulfilled, onrejected);
            if (typeof onfulfilled === "function")
              hasOnFulfilled = true;
            if (typeof onrejected === "function") {
              hasOnRejected = true;
              return result2;
            } else {
              return chain(result2);
            }
          }
        });
        return newPromise;
      }
      var result = chain(customPromise);
      result.hasOnFulfilled = function() {
        return hasOnFulfilled;
      };
      return result;
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/readiness/statusManager.js
var require_statusManager = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/readiness/statusManager.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = callbackHandlerContext;
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var _wrapper = _interopRequireDefault(require_wrapper());
    var _logger = _interopRequireDefault(require_logger());
    var log = (0, _logger.default)("");
    var NEW_LISTENER_EVENT = "newListener";
    var REMOVE_LISTENER_EVENT = "removeListener";
    function defaultOnRejected(err) {
      log.error(err);
    }
    function callbackHandlerContext(context, internalReadyCbCount) {
      if (internalReadyCbCount === void 0) {
        internalReadyCbCount = 0;
      }
      var gate = context.get(context.constants.READINESS).gate;
      var readyCbCount = 0;
      var isReady = false;
      var hasTimedout = false;
      var SDK_READY = gate.SDK_READY, SDK_READY_FROM_CACHE = gate.SDK_READY_FROM_CACHE, SDK_UPDATE = gate.SDK_UPDATE, SDK_READY_TIMED_OUT = gate.SDK_READY_TIMED_OUT;
      gate.on(REMOVE_LISTENER_EVENT, function(event) {
        if (event === SDK_READY)
          readyCbCount--;
      });
      gate.on(NEW_LISTENER_EVENT, function(event) {
        if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {
          if (isReady) {
            log.error("A listener was added for " + (event === SDK_READY ? "SDK_READY" : "SDK_READY_TIMED_OUT") + " on the SDK, which has already fired and won't be emitted again. The callback won't be executed.");
          } else if (event === SDK_READY) {
            readyCbCount++;
          }
        }
      });
      var readyPromise = generateReadyPromise();
      gate.once(SDK_READY_FROM_CACHE, function() {
        log.info("Split SDK is ready from cache.");
        context.put(context.constants.READY_FROM_CACHE, true);
      });
      function generateReadyPromise() {
        var promise = (0, _wrapper.default)(new Promise(function(resolve2, reject) {
          gate.once(SDK_READY, function() {
            log.info("Split SDK is ready.");
            if (readyCbCount === internalReadyCbCount && !promise.hasOnFulfilled())
              log.warn("No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.");
            context.put(context.constants.READY, true);
            isReady = true;
            resolve2();
          });
          gate.once(SDK_READY_TIMED_OUT, function(error2) {
            context.put(context.constants.HAS_TIMEDOUT, true);
            hasTimedout = true;
            reject(error2);
          });
        }), defaultOnRejected);
        return promise;
      }
      return (0, _objectAssign.default)(Object.create(gate), {
        Event: {
          SDK_READY,
          SDK_READY_FROM_CACHE,
          SDK_UPDATE,
          SDK_READY_TIMED_OUT
        },
        ready: function ready() {
          if (hasTimedout) {
            if (!isReady) {
              return (0, _wrapper.default)(Promise.reject("Split SDK has emitted SDK_READY_TIMED_OUT event."), defaultOnRejected);
            } else {
              return Promise.resolve();
            }
          }
          return readyPromise;
        },
        __context: context
      });
    }
  }
});

// node_modules/@splitsoftware/splitio/lib/integrations/node.js
var require_node23 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/integrations/node.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var integrationsManagerFactory = function integrationsManagerFactory2() {
    };
    var _default = integrationsManagerFactory;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/impressions/counter.js
var require_counter = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/impressions/counter.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _time = require_time();
    var _objectAssign = _interopRequireDefault(require_object_assign());
    var ImpressionCounter = /* @__PURE__ */ function() {
      function ImpressionCounter2() {
        this.cache = {};
      }
      var _proto = ImpressionCounter2.prototype;
      _proto._makeKey = function _makeKey(featureName, timeFrame) {
        return featureName + "::" + (0, _time.truncateTimeFrame)(timeFrame);
      };
      _proto.inc = function inc(featureName, timeFrame, amount) {
        var key2 = this._makeKey(featureName, timeFrame);
        var currentAmount = this.cache[key2];
        this.cache[key2] = currentAmount ? currentAmount + amount : amount;
      };
      _proto.popAll = function popAll() {
        var res = {};
        (0, _objectAssign.default)(res, this.cache);
        this.cache = {};
        return res;
      };
      _proto.size = function size() {
        return Object.keys(this.cache).length;
      };
      return ImpressionCounter2;
    }();
    var _default = ImpressionCounter;
    exports.default = _default;
  }
});

// node_modules/@splitsoftware/splitio/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@splitsoftware/splitio/lib/index.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard();
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.SplitFactory = SplitFactory2;
    var _manager = _interopRequireDefault(require_manager());
    var _storage = _interopRequireDefault(require_node3());
    var _readiness2 = _interopRequireDefault(require_readiness());
    var _settings = _interopRequireDefault(require_settings());
    var _context = _interopRequireDefault(require_context());
    var _parser = _interopRequireDefault(require_parser2());
    var _logger = _interopRequireWildcard(require_logger());
    var _timeTracker = _interopRequireDefault(require_timeTracker());
    var _online = _interopRequireDefault(require_online());
    var _offline = _interopRequireDefault(require_offline());
    var _statusManager = _interopRequireDefault(require_statusManager());
    var _constants = require_constants();
    var _inputValidation = require_inputValidation();
    var _integrations = _interopRequireDefault(require_node23());
    var _counter = _interopRequireDefault(require_counter());
    var log = (0, _logger.default)("splitio");
    var buildInstanceId = function buildInstanceId2(key2, trafficType) {
      return (key2.matchingKey ? key2.matchingKey : key2) + "-" + (key2.bucketingKey ? key2.bucketingKey : key2) + "-" + (trafficType !== void 0 ? trafficType : "");
    };
    function SplitFactory2(config) {
      var clientInstances = {};
      var readyLatencyTrackers = {
        splitsReadyTracker: _timeTracker.default.start(_timeTracker.default.TaskNames.SPLITS_READY),
        segmentsReadyTracker: _timeTracker.default.start(_timeTracker.default.TaskNames.SEGMENTS_READY),
        sdkReadyTracker: _timeTracker.default.start(_timeTracker.default.TaskNames.SDK_READY)
      };
      var context = new _context.default();
      var settings = (0, _settings.default)(config);
      context.put(context.constants.SETTINGS, settings);
      (0, _inputValidation.validateApiKey)(settings.core.authorizationKey);
      var gateFactory = (0, _readiness2.default)();
      var readiness2 = gateFactory(settings.startup.readyTimeout);
      context.put(context.constants.READINESS, readiness2);
      var statusManager = (0, _statusManager.default)(context);
      context.put(context.constants.STATUS_MANAGER, statusManager);
      var storage = (0, _storage.default)(context);
      context.put(context.constants.STORAGE, storage);
      var impressionsCounter = new _counter.default();
      context.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter);
      var integrationsManager = (0, _integrations.default)(context);
      context.put(context.constants.INTEGRATIONS_MANAGER, integrationsManager);
      var splitFactory = settings.mode === _constants.LOCALHOST_MODE ? _offline.default : _online.default;
      var _splitFactory = splitFactory(context, readyLatencyTrackers), mainClientInstance = _splitFactory.api, mainClientMetricCollectors = _splitFactory.metricCollectors;
      var managerInstance = (0, _manager.default)(storage.splits, context);
      var parsedDefaultKey = (0, _parser.default)(settings.core.key);
      var defaultInstanceId = buildInstanceId(parsedDefaultKey, settings.core.trafficType);
      clientInstances[defaultInstanceId] = mainClientInstance;
      log.info("New Split SDK instance created.");
      return {
        client: function client(key2, trafficType) {
          if (key2 === void 0) {
            log.debug("Retrieving default SDK client.");
            return mainClientInstance;
          }
          if (typeof storage.shared != "function") {
            throw new Error("Shared Client not supported by the storage mechanism. Create isolated instances instead.");
          }
          var validKey = (0, _inputValidation.validateKey)(key2, "Shared Client instantiation");
          if (validKey === false) {
            throw new Error("Shared Client needs a valid key.");
          }
          var validTrafficType;
          if (trafficType !== void 0) {
            validTrafficType = (0, _inputValidation.validateTrafficType)(trafficType, "Shared Client instantiation");
            if (validTrafficType === false) {
              throw new Error("Shared Client needs a valid traffic type or no traffic type at all.");
            }
          }
          var instanceId = buildInstanceId(validKey, validTrafficType);
          if (!clientInstances[instanceId]) {
            var sharedSettings = settings.overrideKeyAndTT(validKey, validTrafficType);
            var sharedContext = new _context.default();
            var _readiness = gateFactory(sharedSettings.startup.readyTimeout);
            sharedContext.put(context.constants.READY_FROM_CACHE, context.get(context.constants.READY_FROM_CACHE, true));
            sharedContext.put(context.constants.READINESS, _readiness);
            sharedContext.put(context.constants.STATUS_MANAGER, (0, _statusManager.default)(sharedContext, -1));
            sharedContext.put(context.constants.SETTINGS, sharedSettings);
            sharedContext.put(context.constants.STORAGE, storage.shared(sharedSettings));
            sharedContext.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter);
            clientInstances[instanceId] = splitFactory(sharedContext, false, mainClientMetricCollectors).api;
            log.info("New shared client instance created.");
          } else {
            log.debug("Retrieving existing SDK client.");
          }
          return clientInstances[instanceId];
        },
        manager: function manager() {
          log.info("Manager instance retrieved.");
          return managerInstance;
        },
        Logger: _logger.API,
        settings
      };
    }
  }
});

// node_modules/@supabase/supabase-js/dist/main/lib/version.js
var require_version = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "1.30.7";
  }
});

// node_modules/@supabase/supabase-js/dist/main/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STORAGE_KEY = exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `supabase-js/${version_1.version}` };
    exports.STORAGE_KEY = "supabase.auth.token";
  }
});

// node_modules/@supabase/supabase-js/dist/main/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.stripTrailingSlash = exports.uuid = void 0;
    function uuid() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r2 = Math.random() * 16 | 0, v = c == "x" ? r2 : r2 & 3 | 8;
        return v.toString(16);
      });
    }
    exports.uuid = uuid;
    function stripTrailingSlash(url) {
      return url.replace(/\/$/, "");
    }
    exports.stripTrailingSlash = stripTrailingSlash;
    var isBrowser = () => typeof window !== "undefined";
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/fetch.js
var require_fetch = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/fetch.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.remove = exports.put = exports.post = exports.get = void 0;
    var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
    var handleError = (error2, reject) => {
      if (typeof error2.json !== "function") {
        return reject(error2);
      }
      error2.json().then((err) => {
        return reject({
          message: _getErrorMessage(err),
          status: (error2 === null || error2 === void 0 ? void 0 : error2.status) || 500
        });
      });
    };
    var _getRequestParams = (method, options, body) => {
      const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
      if (method === "GET") {
        return params;
      }
      params.headers = Object.assign({ "Content-Type": "text/plain;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
      params.body = JSON.stringify(body);
      return params;
    };
    function _handleRequest(fetcher, method, url, options, body) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve2, reject) => {
          fetcher(url, _getRequestParams(method, options, body)).then((result) => {
            if (!result.ok)
              throw result;
            if (options === null || options === void 0 ? void 0 : options.noResolveJson)
              return resolve2;
            return result.json();
          }).then((data) => resolve2(data)).catch((error2) => handleError(error2, reject));
        });
      });
    }
    function get2(fetcher, url, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "GET", url, options);
      });
    }
    exports.get = get2;
    function post(fetcher, url, body, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "POST", url, options, body);
      });
    }
    exports.post = post;
    function put(fetcher, url, body, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "PUT", url, options, body);
      });
    }
    exports.put = put;
    function remove(fetcher, url, body, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "DELETE", url, options, body);
      });
    }
    exports.remove = remove;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/version.js
var require_version2 = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "1.22.3";
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/constants.js
var require_constants5 = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.COOKIE_OPTIONS = exports.STORAGE_KEY = exports.EXPIRY_MARGIN = exports.DEFAULT_HEADERS = exports.AUDIENCE = exports.GOTRUE_URL = void 0;
    var version_1 = require_version2();
    exports.GOTRUE_URL = "http://localhost:9999";
    exports.AUDIENCE = "";
    exports.DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version_1.version}` };
    exports.EXPIRY_MARGIN = 60 * 1e3;
    exports.STORAGE_KEY = "supabase.auth.token";
    exports.COOKIE_OPTIONS = {
      name: "sb",
      lifetime: 60 * 60 * 8,
      domain: "",
      path: "/",
      sameSite: "lax"
    };
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/cookies.js
var require_cookies = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteCookie = exports.setCookie = exports.setCookies = exports.getCookieString = void 0;
    function serialize(name, val, options) {
      const opt = options || {};
      const enc = encodeURIComponent;
      const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      const value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      let str = name + "=" + value;
      if (opt.maxAge != null) {
        const maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function isSecureEnvironment(req) {
      if (!req || !req.headers || !req.headers.host) {
        throw new Error('The "host" request header is not available');
      }
      const host = req.headers.host.indexOf(":") > -1 && req.headers.host.split(":")[0] || req.headers.host;
      if (["localhost", "127.0.0.1"].indexOf(host) > -1 || host.endsWith(".local")) {
        return false;
      }
      return true;
    }
    function serializeCookie(cookie, secure) {
      var _a4, _b, _c;
      return serialize(cookie.name, cookie.value, {
        maxAge: cookie.maxAge,
        expires: new Date(Date.now() + cookie.maxAge * 1e3),
        httpOnly: true,
        secure,
        path: (_a4 = cookie.path) !== null && _a4 !== void 0 ? _a4 : "/",
        domain: (_b = cookie.domain) !== null && _b !== void 0 ? _b : "",
        sameSite: (_c = cookie.sameSite) !== null && _c !== void 0 ? _c : "lax"
      });
    }
    function getCookieString(req, res, cookies) {
      const strCookies = cookies.map((c) => serializeCookie(c, isSecureEnvironment(req)));
      const previousCookies = res.getHeader("Set-Cookie");
      if (previousCookies) {
        if (previousCookies instanceof Array) {
          Array.prototype.push.apply(strCookies, previousCookies);
        } else if (typeof previousCookies === "string") {
          strCookies.push(previousCookies);
        }
      }
      return strCookies;
    }
    exports.getCookieString = getCookieString;
    function setCookies(req, res, cookies) {
      res.setHeader("Set-Cookie", getCookieString(req, res, cookies));
    }
    exports.setCookies = setCookies;
    function setCookie(req, res, cookie) {
      setCookies(req, res, [cookie]);
    }
    exports.setCookie = setCookie;
    function deleteCookie(req, res, name) {
      setCookie(req, res, {
        name,
        value: "",
        maxAge: -1
      });
    }
    exports.deleteCookie = deleteCookie;
  }
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/node-ponyfill.js"(exports, module2) {
    var nodeFetch = require_lib3();
    var realFetch = nodeFetch.default || nodeFetch;
    var fetch3 = function(url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    fetch3.ponyfill = true;
    module2.exports = exports = fetch3;
    exports.fetch = fetch3;
    exports.Headers = nodeFetch.Headers;
    exports.Request = nodeFetch.Request;
    exports.Response = nodeFetch.Response;
    exports.default = fetch3;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/helpers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveFetch = exports.getParameterByName = exports.isBrowser = exports.uuid = exports.expiresAt = void 0;
    var cross_fetch_1 = __importDefault(require_node_ponyfill());
    function expiresAt(expiresIn) {
      const timeNow = Math.round(Date.now() / 1e3);
      return timeNow + expiresIn;
    }
    exports.expiresAt = expiresAt;
    function uuid() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        const r2 = Math.random() * 16 | 0, v = c == "x" ? r2 : r2 & 3 | 8;
        return v.toString(16);
      });
    }
    exports.uuid = uuid;
    var isBrowser = () => typeof window !== "undefined";
    exports.isBrowser = isBrowser;
    function getParameterByName(name, url) {
      var _a4;
      if (!url)
        url = ((_a4 = window === null || window === void 0 ? void 0 : window.location) === null || _a4 === void 0 ? void 0 : _a4.href) || "";
      name = name.replace(/[\[\]]/g, "\\$&");
      const regex = new RegExp("[?&#]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
      if (!results)
        return null;
      if (!results[2])
        return "";
      return decodeURIComponent(results[2].replace(/\+/g, " "));
    }
    exports.getParameterByName = getParameterByName;
    var resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = cross_fetch_1.default;
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    exports.resolveFetch = resolveFetch;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/GoTrueApi.js
var require_GoTrueApi = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/GoTrueApi.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fetch_1 = require_fetch();
    var constants_1 = require_constants5();
    var cookies_1 = require_cookies();
    var helpers_1 = require_helpers2();
    var GoTrueApi = class {
      constructor({ url = "", headers = {}, cookieOptions, fetch: fetch3 }) {
        this.url = url;
        this.headers = headers;
        this.cookieOptions = Object.assign(Object.assign({}, constants_1.COOKIE_OPTIONS), cookieOptions);
        this.fetch = (0, helpers_1.resolveFetch)(fetch3);
      }
      _createRequestHeaders(jwt) {
        const headers = Object.assign({}, this.headers);
        headers["Authorization"] = `Bearer ${jwt}`;
        return headers;
      }
      cookieName() {
        var _a4;
        return (_a4 = this.cookieOptions.name) !== null && _a4 !== void 0 ? _a4 : "";
      }
      getUrlForProvider(provider, options) {
        const urlParams = [`provider=${encodeURIComponent(provider)}`];
        if (options === null || options === void 0 ? void 0 : options.redirectTo) {
          urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
        }
        if (options === null || options === void 0 ? void 0 : options.scopes) {
          urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
        }
        return `${this.url}/authorize?${urlParams.join("&")}`;
      }
      signUpWithEmail(email, password, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            let queryString = "";
            if (options.redirectTo) {
              queryString = "?redirect_to=" + encodeURIComponent(options.redirectTo);
            }
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/signup${queryString}`, {
              email,
              password,
              data: options.data,
              gotrue_meta_security: { hcaptcha_token: options.captchaToken }
            }, { headers });
            const session = Object.assign({}, data);
            if (session.expires_in)
              session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      signInWithEmail(email, password, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            let queryString = "?grant_type=password";
            if (options.redirectTo) {
              queryString += "&redirect_to=" + encodeURIComponent(options.redirectTo);
            }
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/token${queryString}`, { email, password }, { headers });
            const session = Object.assign({}, data);
            if (session.expires_in)
              session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      signUpWithPhone(phone, password, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/signup`, {
              phone,
              password,
              data: options.data,
              gotrue_meta_security: { hcaptcha_token: options.captchaToken }
            }, { headers });
            const session = Object.assign({}, data);
            if (session.expires_in)
              session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      signInWithPhone(phone, password) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            const queryString = "?grant_type=password";
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/token${queryString}`, { phone, password }, { headers });
            const session = Object.assign({}, data);
            if (session.expires_in)
              session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      signInWithOpenIDConnect({ id_token, nonce, client_id, issuer, provider }) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            const queryString = "?grant_type=id_token";
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/token${queryString}`, { id_token, nonce, client_id, issuer, provider }, { headers });
            const session = Object.assign({}, data);
            if (session.expires_in)
              session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      sendMagicLinkEmail(email, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            let queryString = "";
            if (options.redirectTo) {
              queryString += "?redirect_to=" + encodeURIComponent(options.redirectTo);
            }
            const shouldCreateUser = options.shouldCreateUser ? options.shouldCreateUser : true;
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/otp${queryString}`, {
              email,
              create_user: shouldCreateUser,
              gotrue_meta_security: { hcaptcha_token: options.captchaToken }
            }, { headers });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      sendMobileOTP(phone, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const shouldCreateUser = options.shouldCreateUser ? options.shouldCreateUser : true;
            const headers = Object.assign({}, this.headers);
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/otp`, {
              phone,
              create_user: shouldCreateUser,
              gotrue_meta_security: { hcaptcha_token: options.captchaToken }
            }, { headers });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      signOut(jwt) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            yield (0, fetch_1.post)(this.fetch, `${this.url}/logout`, {}, { headers: this._createRequestHeaders(jwt), noResolveJson: true });
            return { error: null };
          } catch (e2) {
            return { error: e2 };
          }
        });
      }
      verifyMobileOTP(phone, token, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/verify`, { phone, token, type: "sms", redirect_to: options.redirectTo }, { headers });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      inviteUserByEmail(email, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            let queryString = "";
            if (options.redirectTo) {
              queryString += "?redirect_to=" + encodeURIComponent(options.redirectTo);
            }
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/invite${queryString}`, { email, data: options.data }, { headers });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      resetPasswordForEmail(email, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const headers = Object.assign({}, this.headers);
            let queryString = "";
            if (options.redirectTo) {
              queryString += "?redirect_to=" + encodeURIComponent(options.redirectTo);
            }
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/recover${queryString}`, { email, gotrue_meta_security: { hcaptcha_token: options.captchaToken } }, { headers });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      refreshAccessToken(refreshToken) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/token?grant_type=refresh_token`, { refresh_token: refreshToken }, { headers: this.headers });
            const session = Object.assign({}, data);
            if (session.expires_in)
              session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      setAuthCookie(req, res) {
        if (req.method !== "POST") {
          res.setHeader("Allow", "POST");
          res.status(405).end("Method Not Allowed");
        }
        const { event, session } = req.body;
        if (!event)
          throw new Error("Auth event missing!");
        if (event === "SIGNED_IN") {
          if (!session)
            throw new Error("Auth session missing!");
          (0, cookies_1.setCookies)(req, res, [
            { key: "access-token", value: session.access_token },
            { key: "refresh-token", value: session.refresh_token }
          ].map((token) => {
            var _a4;
            return {
              name: `${this.cookieName()}-${token.key}`,
              value: token.value,
              domain: this.cookieOptions.domain,
              maxAge: (_a4 = this.cookieOptions.lifetime) !== null && _a4 !== void 0 ? _a4 : 0,
              path: this.cookieOptions.path,
              sameSite: this.cookieOptions.sameSite
            };
          }));
        }
        if (event === "SIGNED_OUT") {
          (0, cookies_1.setCookies)(req, res, ["access-token", "refresh-token"].map((key2) => ({
            name: `${this.cookieName()}-${key2}`,
            value: "",
            maxAge: -1
          })));
        }
        res.status(200).json({});
      }
      deleteAuthCookie(req, res, { redirectTo = "/" }) {
        (0, cookies_1.setCookies)(req, res, ["access-token", "refresh-token"].map((key2) => ({
          name: `${this.cookieName()}-${key2}`,
          value: "",
          maxAge: -1
        })));
        return res.redirect(307, redirectTo);
      }
      getAuthCookieString(req, res) {
        if (req.method !== "POST") {
          res.setHeader("Allow", "POST");
          res.status(405).end("Method Not Allowed");
        }
        const { event, session } = req.body;
        if (!event)
          throw new Error("Auth event missing!");
        if (event === "SIGNED_IN") {
          if (!session)
            throw new Error("Auth session missing!");
          return (0, cookies_1.getCookieString)(req, res, [
            { key: "access-token", value: session.access_token },
            { key: "refresh-token", value: session.refresh_token }
          ].map((token) => {
            var _a4;
            return {
              name: `${this.cookieName()}-${token.key}`,
              value: token.value,
              domain: this.cookieOptions.domain,
              maxAge: (_a4 = this.cookieOptions.lifetime) !== null && _a4 !== void 0 ? _a4 : 0,
              path: this.cookieOptions.path,
              sameSite: this.cookieOptions.sameSite
            };
          }));
        }
        if (event === "SIGNED_OUT") {
          return (0, cookies_1.getCookieString)(req, res, ["access-token", "refresh-token"].map((key2) => ({
            name: `${this.cookieName()}-${key2}`,
            value: "",
            maxAge: -1
          })));
        }
        return res.getHeader("Set-Cookie");
      }
      generateLink(type, email, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/admin/generate_link`, {
              type,
              email,
              password: options.password,
              data: options.data,
              redirect_to: options.redirectTo
            }, { headers: this.headers });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      createUser(attributes) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/admin/users`, attributes, {
              headers: this.headers
            });
            return { user: data, data, error: null };
          } catch (e2) {
            return { user: null, data: null, error: e2 };
          }
        });
      }
      listUsers() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.get)(this.fetch, `${this.url}/admin/users`, {
              headers: this.headers
            });
            return { data: data.users, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      getUserById(uid) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.get)(this.fetch, `${this.url}/admin/users/${uid}`, {
              headers: this.headers
            });
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      getUserByCookie(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!req.cookies) {
              throw new Error("Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!");
            }
            const access_token = req.cookies[`${this.cookieName()}-access-token`];
            const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];
            if (!access_token) {
              throw new Error("No cookie found!");
            }
            const { user, error: getUserError } = yield this.getUser(access_token);
            if (getUserError) {
              if (!refresh_token)
                throw new Error("No refresh_token cookie found!");
              if (!res)
                throw new Error("You need to pass the res object to automatically refresh the session!");
              const { data, error: error2 } = yield this.refreshAccessToken(refresh_token);
              if (error2) {
                throw error2;
              } else if (data) {
                (0, cookies_1.setCookies)(req, res, [
                  { key: "access-token", value: data.access_token },
                  { key: "refresh-token", value: data.refresh_token }
                ].map((token) => {
                  var _a4;
                  return {
                    name: `${this.cookieName()}-${token.key}`,
                    value: token.value,
                    domain: this.cookieOptions.domain,
                    maxAge: (_a4 = this.cookieOptions.lifetime) !== null && _a4 !== void 0 ? _a4 : 0,
                    path: this.cookieOptions.path,
                    sameSite: this.cookieOptions.sameSite
                  };
                }));
                return { token: data.access_token, user: data.user, data: data.user, error: null };
              }
            }
            return { token: access_token, user, data: user, error: null };
          } catch (e2) {
            return { token: null, user: null, data: null, error: e2 };
          }
        });
      }
      updateUserById(uid, attributes) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            this;
            const data = yield (0, fetch_1.put)(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {
              headers: this.headers
            });
            return { user: data, data, error: null };
          } catch (e2) {
            return { user: null, data: null, error: e2 };
          }
        });
      }
      deleteUser(uid) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.remove)(this.fetch, `${this.url}/admin/users/${uid}`, {}, {
              headers: this.headers
            });
            return { user: data, data, error: null };
          } catch (e2) {
            return { user: null, data: null, error: e2 };
          }
        });
      }
      getUser(jwt) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.get)(this.fetch, `${this.url}/user`, {
              headers: this._createRequestHeaders(jwt)
            });
            return { user: data, data, error: null };
          } catch (e2) {
            return { user: null, data: null, error: e2 };
          }
        });
      }
      updateUser(jwt, attributes) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield (0, fetch_1.put)(this.fetch, `${this.url}/user`, attributes, {
              headers: this._createRequestHeaders(jwt)
            });
            return { user: data, data, error: null };
          } catch (e2) {
            return { user: null, data: null, error: e2 };
          }
        });
      }
    };
    exports.default = GoTrueApi;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/polyfills.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polyfillGlobalThis = void 0;
    function polyfillGlobalThis() {
      if (typeof globalThis === "object")
        return;
      try {
        Object.defineProperty(Object.prototype, "__magic__", {
          get: function() {
            return this;
          },
          configurable: true
        });
        __magic__.globalThis = __magic__;
        delete Object.prototype.__magic__;
      } catch (e2) {
        if (typeof self !== "undefined") {
          self.globalThis = self;
        }
      }
    }
    exports.polyfillGlobalThis = polyfillGlobalThis;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/GoTrueClient.js
var require_GoTrueClient = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/GoTrueClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GoTrueApi_1 = __importDefault(require_GoTrueApi());
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants5();
    var polyfills_1 = require_polyfills();
    (0, polyfills_1.polyfillGlobalThis)();
    var DEFAULT_OPTIONS = {
      url: constants_1.GOTRUE_URL,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      multiTab: true,
      headers: constants_1.DEFAULT_HEADERS
    };
    var GoTrueClient = class {
      constructor(options) {
        this.stateChangeEmitters = /* @__PURE__ */ new Map();
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.currentUser = null;
        this.currentSession = null;
        this.autoRefreshToken = settings.autoRefreshToken;
        this.persistSession = settings.persistSession;
        this.multiTab = settings.multiTab;
        this.localStorage = settings.localStorage || globalThis.localStorage;
        this.api = new GoTrueApi_1.default({
          url: settings.url,
          headers: settings.headers,
          cookieOptions: settings.cookieOptions,
          fetch: settings.fetch
        });
        this._recoverSession();
        this._recoverAndRefresh();
        this._listenForMultiTabEvents();
        if (settings.detectSessionInUrl && (0, helpers_1.isBrowser)() && !!(0, helpers_1.getParameterByName)("access_token")) {
          this.getSessionFromUrl({ storeSession: true }).then(({ error: error2 }) => {
            if (error2) {
              console.error("Error getting session from URL.", error2);
            }
          });
        }
      }
      signUp({ email, password, phone }, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            this._removeSession();
            const { data, error: error2 } = phone && password ? yield this.api.signUpWithPhone(phone, password, {
              data: options.data,
              captchaToken: options.captchaToken
            }) : yield this.api.signUpWithEmail(email, password, {
              redirectTo: options.redirectTo,
              data: options.data,
              captchaToken: options.captchaToken
            });
            if (error2) {
              throw error2;
            }
            if (!data) {
              throw "An error occurred on sign up.";
            }
            let session = null;
            let user = null;
            if (data.access_token) {
              session = data;
              user = session.user;
              this._saveSession(session);
              this._notifyAllSubscribers("SIGNED_IN");
            }
            if (data.id) {
              user = data;
            }
            return { user, session, error: null };
          } catch (e2) {
            return { user: null, session: null, error: e2 };
          }
        });
      }
      signIn({ email, phone, password, refreshToken, provider, oidc }, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            this._removeSession();
            if (email && !password) {
              const { error: error2 } = yield this.api.sendMagicLinkEmail(email, {
                redirectTo: options.redirectTo,
                shouldCreateUser: options.shouldCreateUser,
                captchaToken: options.captchaToken
              });
              return { user: null, session: null, error: error2 };
            }
            if (email && password) {
              return this._handleEmailSignIn(email, password, {
                redirectTo: options.redirectTo
              });
            }
            if (phone && !password) {
              const { error: error2 } = yield this.api.sendMobileOTP(phone, {
                shouldCreateUser: options.shouldCreateUser,
                captchaToken: options.captchaToken
              });
              return { user: null, session: null, error: error2 };
            }
            if (phone && password) {
              return this._handlePhoneSignIn(phone, password);
            }
            if (refreshToken) {
              const { error: error2 } = yield this._callRefreshToken(refreshToken);
              if (error2)
                throw error2;
              return {
                user: this.currentUser,
                session: this.currentSession,
                error: null
              };
            }
            if (provider) {
              return this._handleProviderSignIn(provider, {
                redirectTo: options.redirectTo,
                scopes: options.scopes
              });
            }
            if (oidc) {
              return this._handleOpenIDConnectSignIn(oidc);
            }
            throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);
          } catch (e2) {
            return { user: null, session: null, error: e2 };
          }
        });
      }
      verifyOTP({ phone, token }, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            this._removeSession();
            const { data, error: error2 } = yield this.api.verifyMobileOTP(phone, token, options);
            if (error2) {
              throw error2;
            }
            if (!data) {
              throw "An error occurred on token verification.";
            }
            let session = null;
            let user = null;
            if (data.access_token) {
              session = data;
              user = session.user;
              this._saveSession(session);
              this._notifyAllSubscribers("SIGNED_IN");
            }
            if (data.id) {
              user = data;
            }
            return { user, session, error: null };
          } catch (e2) {
            return { user: null, session: null, error: e2 };
          }
        });
      }
      user() {
        return this.currentUser;
      }
      session() {
        return this.currentSession;
      }
      refreshSession() {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!((_a4 = this.currentSession) === null || _a4 === void 0 ? void 0 : _a4.access_token))
              throw new Error("Not logged in.");
            const { error: error2 } = yield this._callRefreshToken();
            if (error2)
              throw error2;
            return { data: this.currentSession, user: this.currentUser, error: null };
          } catch (e2) {
            return { data: null, user: null, error: e2 };
          }
        });
      }
      update(attributes) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!((_a4 = this.currentSession) === null || _a4 === void 0 ? void 0 : _a4.access_token))
              throw new Error("Not logged in.");
            const { user, error: error2 } = yield this.api.updateUser(this.currentSession.access_token, attributes);
            if (error2)
              throw error2;
            if (!user)
              throw Error("Invalid user data.");
            const session = Object.assign(Object.assign({}, this.currentSession), { user });
            this._saveSession(session);
            this._notifyAllSubscribers("USER_UPDATED");
            return { data: user, user, error: null };
          } catch (e2) {
            return { data: null, user: null, error: e2 };
          }
        });
      }
      setSession(refresh_token) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!refresh_token) {
              throw new Error("No current session.");
            }
            const { data, error: error2 } = yield this.api.refreshAccessToken(refresh_token);
            if (error2) {
              return { session: null, error: error2 };
            }
            this._saveSession(data);
            this._notifyAllSubscribers("SIGNED_IN");
            return { session: data, error: null };
          } catch (e2) {
            return { error: e2, session: null };
          }
        });
      }
      setAuth(access_token) {
        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: "bearer", user: null });
        return this.currentSession;
      }
      getSessionFromUrl(options) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!(0, helpers_1.isBrowser)())
              throw new Error("No browser detected.");
            const error_description = (0, helpers_1.getParameterByName)("error_description");
            if (error_description)
              throw new Error(error_description);
            const provider_token = (0, helpers_1.getParameterByName)("provider_token");
            const access_token = (0, helpers_1.getParameterByName)("access_token");
            if (!access_token)
              throw new Error("No access_token detected.");
            const expires_in = (0, helpers_1.getParameterByName)("expires_in");
            if (!expires_in)
              throw new Error("No expires_in detected.");
            const refresh_token = (0, helpers_1.getParameterByName)("refresh_token");
            if (!refresh_token)
              throw new Error("No refresh_token detected.");
            const token_type = (0, helpers_1.getParameterByName)("token_type");
            if (!token_type)
              throw new Error("No token_type detected.");
            const timeNow = Math.round(Date.now() / 1e3);
            const expires_at = timeNow + parseInt(expires_in);
            const { user, error: error2 } = yield this.api.getUser(access_token);
            if (error2)
              throw error2;
            const session = {
              provider_token,
              access_token,
              expires_in: parseInt(expires_in),
              expires_at,
              refresh_token,
              token_type,
              user
            };
            if (options === null || options === void 0 ? void 0 : options.storeSession) {
              this._saveSession(session);
              const recoveryMode = (0, helpers_1.getParameterByName)("type");
              this._notifyAllSubscribers("SIGNED_IN");
              if (recoveryMode === "recovery") {
                this._notifyAllSubscribers("PASSWORD_RECOVERY");
              }
            }
            window.location.hash = "";
            return { data: session, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      signOut() {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const accessToken = (_a4 = this.currentSession) === null || _a4 === void 0 ? void 0 : _a4.access_token;
          this._removeSession();
          this._notifyAllSubscribers("SIGNED_OUT");
          if (accessToken) {
            const { error: error2 } = yield this.api.signOut(accessToken);
            if (error2)
              return { error: error2 };
          }
          return { error: null };
        });
      }
      onAuthStateChange(callback) {
        try {
          const id = (0, helpers_1.uuid)();
          const subscription = {
            id,
            callback,
            unsubscribe: () => {
              this.stateChangeEmitters.delete(id);
            }
          };
          this.stateChangeEmitters.set(id, subscription);
          return { data: subscription, error: null };
        } catch (e2) {
          return { data: null, error: e2 };
        }
      }
      _handleEmailSignIn(email, password, options = {}) {
        var _a4, _b;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const { data, error: error2 } = yield this.api.signInWithEmail(email, password, {
              redirectTo: options.redirectTo
            });
            if (error2 || !data)
              return { data: null, user: null, session: null, error: error2 };
            if (((_a4 = data === null || data === void 0 ? void 0 : data.user) === null || _a4 === void 0 ? void 0 : _a4.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {
              this._saveSession(data);
              this._notifyAllSubscribers("SIGNED_IN");
            }
            return { data, user: data.user, session: data, error: null };
          } catch (e2) {
            return { data: null, user: null, session: null, error: e2 };
          }
        });
      }
      _handlePhoneSignIn(phone, password) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const { data, error: error2 } = yield this.api.signInWithPhone(phone, password);
            if (error2 || !data)
              return { data: null, user: null, session: null, error: error2 };
            if ((_a4 = data === null || data === void 0 ? void 0 : data.user) === null || _a4 === void 0 ? void 0 : _a4.phone_confirmed_at) {
              this._saveSession(data);
              this._notifyAllSubscribers("SIGNED_IN");
            }
            return { data, user: data.user, session: data, error: null };
          } catch (e2) {
            return { data: null, user: null, session: null, error: e2 };
          }
        });
      }
      _handleProviderSignIn(provider, options = {}) {
        const url = this.api.getUrlForProvider(provider, {
          redirectTo: options.redirectTo,
          scopes: options.scopes
        });
        try {
          if ((0, helpers_1.isBrowser)()) {
            window.location.href = url;
          }
          return { provider, url, data: null, session: null, user: null, error: null };
        } catch (e2) {
          if (url)
            return { provider, url, data: null, session: null, user: null, error: null };
          return { data: null, user: null, session: null, error: e2 };
        }
      }
      _handleOpenIDConnectSignIn({ id_token, nonce, client_id, issuer, provider }) {
        return __awaiter(this, void 0, void 0, function* () {
          if (id_token && nonce && (client_id && issuer || provider)) {
            try {
              const { data, error: error2 } = yield this.api.signInWithOpenIDConnect({
                id_token,
                nonce,
                client_id,
                issuer,
                provider
              });
              if (error2 || !data)
                return { user: null, session: null, error: error2 };
              this._saveSession(data);
              this._notifyAllSubscribers("SIGNED_IN");
              return { user: data.user, session: data, error: null };
            } catch (e2) {
              return { user: null, session: null, error: e2 };
            }
          }
          throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);
        });
      }
      _recoverSession() {
        var _a4;
        try {
          const json = (0, helpers_1.isBrowser)() && ((_a4 = this.localStorage) === null || _a4 === void 0 ? void 0 : _a4.getItem(constants_1.STORAGE_KEY));
          if (!json || typeof json !== "string") {
            return null;
          }
          const data = JSON.parse(json);
          const { currentSession, expiresAt } = data;
          const timeNow = Math.round(Date.now() / 1e3);
          if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {
            this._saveSession(currentSession);
            this._notifyAllSubscribers("SIGNED_IN");
          }
        } catch (error2) {
          console.log("error", error2);
        }
      }
      _recoverAndRefresh() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const json = (0, helpers_1.isBrowser)() && (yield this.localStorage.getItem(constants_1.STORAGE_KEY));
            if (!json) {
              return null;
            }
            const data = JSON.parse(json);
            const { currentSession, expiresAt } = data;
            const timeNow = Math.round(Date.now() / 1e3);
            if (expiresAt < timeNow) {
              if (this.autoRefreshToken && currentSession.refresh_token) {
                const { error: error2 } = yield this._callRefreshToken(currentSession.refresh_token);
                if (error2) {
                  console.log(error2.message);
                  yield this._removeSession();
                }
              } else {
                this._removeSession();
              }
            } else if (!currentSession || !currentSession.user) {
              console.log("Current session is missing data.");
              this._removeSession();
            } else {
              this._saveSession(currentSession);
              this._notifyAllSubscribers("SIGNED_IN");
            }
          } catch (err) {
            console.error(err);
            return null;
          }
        });
      }
      _callRefreshToken(refresh_token) {
        var _a4;
        if (refresh_token === void 0) {
          refresh_token = (_a4 = this.currentSession) === null || _a4 === void 0 ? void 0 : _a4.refresh_token;
        }
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!refresh_token) {
              throw new Error("No current session.");
            }
            const { data, error: error2 } = yield this.api.refreshAccessToken(refresh_token);
            if (error2)
              throw error2;
            if (!data)
              throw Error("Invalid session data.");
            this._saveSession(data);
            this._notifyAllSubscribers("TOKEN_REFRESHED");
            this._notifyAllSubscribers("SIGNED_IN");
            return { data, error: null };
          } catch (e2) {
            return { data: null, error: e2 };
          }
        });
      }
      _notifyAllSubscribers(event) {
        this.stateChangeEmitters.forEach((x2) => x2.callback(event, this.currentSession));
      }
      _saveSession(session) {
        this.currentSession = session;
        this.currentUser = session.user;
        const expiresAt = session.expires_at;
        if (expiresAt) {
          const timeNow = Math.round(Date.now() / 1e3);
          const expiresIn = expiresAt - timeNow;
          const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;
          this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1e3);
        }
        if (this.persistSession && session.expires_at) {
          this._persistSession(this.currentSession);
        }
      }
      _persistSession(currentSession) {
        const data = { currentSession, expiresAt: currentSession.expires_at };
        (0, helpers_1.isBrowser)() && this.localStorage.setItem(constants_1.STORAGE_KEY, JSON.stringify(data));
      }
      _removeSession() {
        return __awaiter(this, void 0, void 0, function* () {
          this.currentSession = null;
          this.currentUser = null;
          if (this.refreshTokenTimer)
            clearTimeout(this.refreshTokenTimer);
          (0, helpers_1.isBrowser)() && (yield this.localStorage.removeItem(constants_1.STORAGE_KEY));
        });
      }
      _startAutoRefreshToken(value) {
        if (this.refreshTokenTimer)
          clearTimeout(this.refreshTokenTimer);
        if (value <= 0 || !this.autoRefreshToken)
          return;
        this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);
        if (typeof this.refreshTokenTimer.unref === "function")
          this.refreshTokenTimer.unref();
      }
      _listenForMultiTabEvents() {
        if (!this.multiTab || !(0, helpers_1.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
          return false;
        }
        try {
          window === null || window === void 0 ? void 0 : window.addEventListener("storage", (e2) => {
            var _a4;
            if (e2.key === constants_1.STORAGE_KEY) {
              const newSession = JSON.parse(String(e2.newValue));
              if ((_a4 = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a4 === void 0 ? void 0 : _a4.access_token) {
                this._recoverAndRefresh();
                this._notifyAllSubscribers("SIGNED_IN");
              } else {
                this._removeSession();
                this._notifyAllSubscribers("SIGNED_OUT");
              }
            }
          });
        } catch (error2) {
          console.error("_listenForMultiTabEvents", error2);
        }
      }
    };
    exports.default = GoTrueClient;
  }
});

// node_modules/@supabase/gotrue-js/dist/main/lib/types.js
var require_types2 = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@supabase/gotrue-js/dist/main/index.js
var require_main = __commonJS({
  "node_modules/@supabase/gotrue-js/dist/main/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoTrueClient = exports.GoTrueApi = void 0;
    var GoTrueApi_1 = __importDefault(require_GoTrueApi());
    exports.GoTrueApi = GoTrueApi_1.default;
    var GoTrueClient_1 = __importDefault(require_GoTrueClient());
    exports.GoTrueClient = GoTrueClient_1.default;
    __exportStar(require_types2(), exports);
  }
});

// node_modules/@supabase/supabase-js/dist/main/lib/SupabaseAuthClient.js
var require_SupabaseAuthClient = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/lib/SupabaseAuthClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupabaseAuthClient = void 0;
    var gotrue_js_1 = require_main();
    var SupabaseAuthClient = class extends gotrue_js_1.GoTrueClient {
      constructor(options) {
        super(options);
      }
    };
    exports.SupabaseAuthClient = SupabaseAuthClient;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/types.js
var require_types3 = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/types.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostgrestBuilder = void 0;
    var cross_fetch_1 = __importDefault(require_node_ponyfill());
    var PostgrestBuilder = class {
      constructor(builder) {
        this.shouldThrowOnError = false;
        Object.assign(this, builder);
        let _fetch;
        if (builder.fetch) {
          _fetch = builder.fetch;
        } else if (typeof fetch === "undefined") {
          _fetch = cross_fetch_1.default;
        } else {
          _fetch = fetch;
        }
        this.fetch = (...args) => _fetch(...args);
      }
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      then(onfulfilled, onrejected) {
        if (typeof this.schema === "undefined") {
        } else if (["GET", "HEAD"].includes(this.method)) {
          this.headers["Accept-Profile"] = this.schema;
        } else {
          this.headers["Content-Profile"] = this.schema;
        }
        if (this.method !== "GET" && this.method !== "HEAD") {
          this.headers["Content-Type"] = "application/json";
        }
        let res = this.fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then((res2) => __awaiter(this, void 0, void 0, function* () {
          var _a4, _b, _c;
          let error2 = null;
          let data = null;
          let count = null;
          if (res2.ok) {
            const isReturnMinimal = (_a4 = this.headers["Prefer"]) === null || _a4 === void 0 ? void 0 : _a4.split(",").includes("return=minimal");
            if (this.method !== "HEAD" && !isReturnMinimal) {
              const text = yield res2.text();
              if (!text) {
              } else if (this.headers["Accept"] === "text/csv") {
                data = text;
              } else {
                data = JSON.parse(text);
              }
            }
            const countHeader = (_b = this.headers["Prefer"]) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
            const contentRange = (_c = res2.headers.get("content-range")) === null || _c === void 0 ? void 0 : _c.split("/");
            if (countHeader && contentRange && contentRange.length > 1) {
              count = parseInt(contentRange[1]);
            }
          } else {
            const body = yield res2.text();
            try {
              error2 = JSON.parse(body);
            } catch (_d2) {
              error2 = {
                message: body
              };
            }
            if (error2 && this.shouldThrowOnError) {
              throw error2;
            }
          }
          const postgrestResponse = {
            error: error2,
            data,
            count,
            status: res2.status,
            statusText: res2.statusText,
            body: data
          };
          return postgrestResponse;
        }));
        if (!this.shouldThrowOnError) {
          res = res.catch((fetchError) => ({
            error: {
              message: `FetchError: ${fetchError.message}`,
              details: "",
              hint: "",
              code: fetchError.code || ""
            },
            data: null,
            body: null,
            count: null,
            status: 400,
            statusText: "Bad Request"
          }));
        }
        return res.then(onfulfilled, onrejected);
      }
    };
    exports.PostgrestBuilder = PostgrestBuilder;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestTransformBuilder.js
var require_PostgrestTransformBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestTransformBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types3();
    var PostgrestTransformBuilder = class extends types_1.PostgrestBuilder {
      select(columns = "*") {
        let quoted2 = false;
        const cleanedColumns = columns.split("").map((c) => {
          if (/\s/.test(c) && !quoted2) {
            return "";
          }
          if (c === '"') {
            quoted2 = !quoted2;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        return this;
      }
      order(column, { ascending = true, nullsFirst = false, foreignTable } = {}) {
        const key2 = typeof foreignTable === "undefined" ? "order" : `${foreignTable}.order`;
        const existingOrder = this.url.searchParams.get(key2);
        this.url.searchParams.set(key2, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}.${nullsFirst ? "nullsfirst" : "nullslast"}`);
        return this;
      }
      limit(count, { foreignTable } = {}) {
        const key2 = typeof foreignTable === "undefined" ? "limit" : `${foreignTable}.limit`;
        this.url.searchParams.set(key2, `${count}`);
        return this;
      }
      range(from, to, { foreignTable } = {}) {
        const keyOffset = typeof foreignTable === "undefined" ? "offset" : `${foreignTable}.offset`;
        const keyLimit = typeof foreignTable === "undefined" ? "limit" : `${foreignTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      single() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        return this;
      }
      maybeSingle() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        const _this = new PostgrestTransformBuilder(this);
        _this.then = (onfulfilled, onrejected) => this.then((res) => {
          var _a4, _b;
          if ((_b = (_a4 = res.error) === null || _a4 === void 0 ? void 0 : _a4.details) === null || _b === void 0 ? void 0 : _b.includes("Results contain 0 rows")) {
            return onfulfilled({
              error: null,
              data: null,
              count: res.count,
              status: 200,
              statusText: "OK",
              body: null
            });
          }
          return onfulfilled(res);
        }, onrejected);
        return _this;
      }
      csv() {
        this.headers["Accept"] = "text/csv";
        return this;
      }
    };
    exports.default = PostgrestTransformBuilder;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestFilterBuilder.js
var require_PostgrestFilterBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestFilterBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    var PostgrestFilterBuilder = class extends PostgrestTransformBuilder_1.default {
      constructor() {
        super(...arguments);
        this.cs = this.contains;
        this.cd = this.containedBy;
        this.sl = this.rangeLt;
        this.sr = this.rangeGt;
        this.nxl = this.rangeGte;
        this.nxr = this.rangeLte;
        this.adj = this.rangeAdjacent;
        this.ov = this.overlaps;
      }
      not(column, operator, value) {
        this.url.searchParams.append(`${column}`, `not.${operator}.${value}`);
        return this;
      }
      or(filters, { foreignTable } = {}) {
        const key2 = typeof foreignTable === "undefined" ? "or" : `${foreignTable}.or`;
        this.url.searchParams.append(key2, `(${filters})`);
        return this;
      }
      eq(column, value) {
        this.url.searchParams.append(`${column}`, `eq.${value}`);
        return this;
      }
      neq(column, value) {
        this.url.searchParams.append(`${column}`, `neq.${value}`);
        return this;
      }
      gt(column, value) {
        this.url.searchParams.append(`${column}`, `gt.${value}`);
        return this;
      }
      gte(column, value) {
        this.url.searchParams.append(`${column}`, `gte.${value}`);
        return this;
      }
      lt(column, value) {
        this.url.searchParams.append(`${column}`, `lt.${value}`);
        return this;
      }
      lte(column, value) {
        this.url.searchParams.append(`${column}`, `lte.${value}`);
        return this;
      }
      like(column, pattern) {
        this.url.searchParams.append(`${column}`, `like.${pattern}`);
        return this;
      }
      ilike(column, pattern) {
        this.url.searchParams.append(`${column}`, `ilike.${pattern}`);
        return this;
      }
      is(column, value) {
        this.url.searchParams.append(`${column}`, `is.${value}`);
        return this;
      }
      in(column, values) {
        const cleanedValues = values.map((s3) => {
          if (typeof s3 === "string" && new RegExp("[,()]").test(s3))
            return `"${s3}"`;
          else
            return `${s3}`;
        }).join(",");
        this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`);
        return this;
      }
      contains(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(`${column}`, `cs.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(`${column}`, `cs.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`);
        }
        return this;
      }
      containedBy(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(`${column}`, `cd.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(`${column}`, `cd.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`);
        }
        return this;
      }
      rangeLt(column, range) {
        this.url.searchParams.append(`${column}`, `sl.${range}`);
        return this;
      }
      rangeGt(column, range) {
        this.url.searchParams.append(`${column}`, `sr.${range}`);
        return this;
      }
      rangeGte(column, range) {
        this.url.searchParams.append(`${column}`, `nxl.${range}`);
        return this;
      }
      rangeLte(column, range) {
        this.url.searchParams.append(`${column}`, `nxr.${range}`);
        return this;
      }
      rangeAdjacent(column, range) {
        this.url.searchParams.append(`${column}`, `adj.${range}`);
        return this;
      }
      overlaps(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(`${column}`, `ov.${value}`);
        } else {
          this.url.searchParams.append(`${column}`, `ov.{${value.join(",")}}`);
        }
        return this;
      }
      textSearch(column, query, { config, type = null } = {}) {
        let typePart = "";
        if (type === "plain") {
          typePart = "pl";
        } else if (type === "phrase") {
          typePart = "ph";
        } else if (type === "websearch") {
          typePart = "w";
        }
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      fts(column, query, { config } = {}) {
        const configPart = typeof config === "undefined" ? "" : `(${config})`;
        this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`);
        return this;
      }
      plfts(column, query, { config } = {}) {
        const configPart = typeof config === "undefined" ? "" : `(${config})`;
        this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`);
        return this;
      }
      phfts(column, query, { config } = {}) {
        const configPart = typeof config === "undefined" ? "" : `(${config})`;
        this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`);
        return this;
      }
      wfts(column, query, { config } = {}) {
        const configPart = typeof config === "undefined" ? "" : `(${config})`;
        this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`);
        return this;
      }
      filter(column, operator, value) {
        this.url.searchParams.append(`${column}`, `${operator}.${value}`);
        return this;
      }
      match(query) {
        Object.keys(query).forEach((key2) => {
          this.url.searchParams.append(`${key2}`, `eq.${query[key2]}`);
        });
        return this;
      }
    };
    exports.default = PostgrestFilterBuilder;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestQueryBuilder.js
var require_PostgrestQueryBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestQueryBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types3();
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var PostgrestQueryBuilder = class extends types_1.PostgrestBuilder {
      constructor(url, { headers = {}, schema, fetch: fetch3 } = {}) {
        super({ fetch: fetch3 });
        this.url = new URL(url);
        this.headers = Object.assign({}, headers);
        this.schema = schema;
      }
      select(columns = "*", { head = false, count = null } = {}) {
        this.method = "GET";
        let quoted2 = false;
        const cleanedColumns = columns.split("").map((c) => {
          if (/\s/.test(c) && !quoted2) {
            return "";
          }
          if (c === '"') {
            quoted2 = !quoted2;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) {
          this.headers["Prefer"] = `count=${count}`;
        }
        if (head) {
          this.method = "HEAD";
        }
        return new PostgrestFilterBuilder_1.default(this);
      }
      insert(values, { upsert = false, onConflict, returning = "representation", count = null } = {}) {
        this.method = "POST";
        const prefersHeaders = [`return=${returning}`];
        if (upsert)
          prefersHeaders.push("resolution=merge-duplicates");
        if (upsert && onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        this.body = values;
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x2) => acc.concat(Object.keys(x2)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default(this);
      }
      upsert(values, { onConflict, returning = "representation", count = null, ignoreDuplicates = false } = {}) {
        this.method = "POST";
        const prefersHeaders = [
          `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`,
          `return=${returning}`
        ];
        if (onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        this.body = values;
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default(this);
      }
      update(values, { returning = "representation", count = null } = {}) {
        this.method = "PATCH";
        const prefersHeaders = [`return=${returning}`];
        this.body = values;
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default(this);
      }
      delete({ returning = "representation", count = null } = {}) {
        this.method = "DELETE";
        const prefersHeaders = [`return=${returning}`];
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default(this);
      }
    };
    exports.default = PostgrestQueryBuilder;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestRpcBuilder.js
var require_PostgrestRpcBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/PostgrestRpcBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types3();
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var PostgrestRpcBuilder = class extends types_1.PostgrestBuilder {
      constructor(url, { headers = {}, schema, fetch: fetch3 } = {}) {
        super({ fetch: fetch3 });
        this.url = new URL(url);
        this.headers = Object.assign({}, headers);
        this.schema = schema;
      }
      rpc(params, { head = false, count = null } = {}) {
        if (head) {
          this.method = "HEAD";
          if (params) {
            Object.entries(params).forEach(([name, value]) => {
              this.url.searchParams.append(name, value);
            });
          }
        } else {
          this.method = "POST";
          this.body = params;
        }
        if (count) {
          if (this.headers["Prefer"] !== void 0)
            this.headers["Prefer"] += `,count=${count}`;
          else
            this.headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default(this);
      }
    };
    exports.default = PostgrestRpcBuilder;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/version.js
var require_version3 = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.36.2";
  }
});

// node_modules/@supabase/postgrest-js/dist/main/lib/constants.js
var require_constants6 = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version3();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${version_1.version}` };
  }
});

// node_modules/@supabase/postgrest-js/dist/main/PostgrestClient.js
var require_PostgrestClient = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/PostgrestClient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    var PostgrestRpcBuilder_1 = __importDefault(require_PostgrestRpcBuilder());
    var constants_1 = require_constants6();
    var PostgrestClient = class {
      constructor(url, { headers = {}, schema, fetch: fetch3 } = {}) {
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.schema = schema;
        this.fetch = fetch3;
      }
      auth(token) {
        this.headers["Authorization"] = `Bearer ${token}`;
        return this;
      }
      from(table) {
        const url = `${this.url}/${table}`;
        return new PostgrestQueryBuilder_1.default(url, {
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch
        });
      }
      rpc(fn, params, { head = false, count = null } = {}) {
        const url = `${this.url}/rpc/${fn}`;
        return new PostgrestRpcBuilder_1.default(url, {
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch
        }).rpc(params, { head, count });
      }
    };
    exports.default = PostgrestClient;
  }
});

// node_modules/@supabase/postgrest-js/dist/main/index.js
var require_main2 = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/main/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestBuilder = exports.PostgrestClient = void 0;
    var PostgrestClient_1 = __importDefault(require_PostgrestClient());
    exports.PostgrestClient = PostgrestClient_1.default;
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
    var types_1 = require_types3();
    Object.defineProperty(exports, "PostgrestBuilder", { enumerable: true, get: function() {
      return types_1.PostgrestBuilder;
    } });
  }
});

// node_modules/@supabase/realtime-js/dist/main/lib/transformers.js
var require_transformers = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/lib/transformers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;
    var PostgresTypes;
    (function(PostgresTypes2) {
      PostgresTypes2["abstime"] = "abstime";
      PostgresTypes2["bool"] = "bool";
      PostgresTypes2["date"] = "date";
      PostgresTypes2["daterange"] = "daterange";
      PostgresTypes2["float4"] = "float4";
      PostgresTypes2["float8"] = "float8";
      PostgresTypes2["int2"] = "int2";
      PostgresTypes2["int4"] = "int4";
      PostgresTypes2["int4range"] = "int4range";
      PostgresTypes2["int8"] = "int8";
      PostgresTypes2["int8range"] = "int8range";
      PostgresTypes2["json"] = "json";
      PostgresTypes2["jsonb"] = "jsonb";
      PostgresTypes2["money"] = "money";
      PostgresTypes2["numeric"] = "numeric";
      PostgresTypes2["oid"] = "oid";
      PostgresTypes2["reltime"] = "reltime";
      PostgresTypes2["text"] = "text";
      PostgresTypes2["time"] = "time";
      PostgresTypes2["timestamp"] = "timestamp";
      PostgresTypes2["timestamptz"] = "timestamptz";
      PostgresTypes2["timetz"] = "timetz";
      PostgresTypes2["tsrange"] = "tsrange";
      PostgresTypes2["tstzrange"] = "tstzrange";
    })(PostgresTypes = exports.PostgresTypes || (exports.PostgresTypes = {}));
    exports.convertChangeData = (columns, record, options = {}) => {
      var _a4;
      const skipTypes = (_a4 = options.skipTypes) !== null && _a4 !== void 0 ? _a4 : [];
      return Object.keys(record).reduce((acc, rec_key) => {
        acc[rec_key] = exports.convertColumn(rec_key, columns, record, skipTypes);
        return acc;
      }, {});
    };
    exports.convertColumn = (columnName, columns, record, skipTypes) => {
      const column = columns.find((x2) => x2.name === columnName);
      const colType = column === null || column === void 0 ? void 0 : column.type;
      const value = record[columnName];
      if (colType && !skipTypes.includes(colType)) {
        return exports.convertCell(colType, value);
      }
      return noop4(value);
    };
    exports.convertCell = (type, value) => {
      if (type.charAt(0) === "_") {
        const dataType = type.slice(1, type.length);
        return exports.toArray(value, dataType);
      }
      switch (type) {
        case PostgresTypes.bool:
          return exports.toBoolean(value);
        case PostgresTypes.float4:
        case PostgresTypes.float8:
        case PostgresTypes.int2:
        case PostgresTypes.int4:
        case PostgresTypes.int8:
        case PostgresTypes.numeric:
        case PostgresTypes.oid:
          return exports.toNumber(value);
        case PostgresTypes.json:
        case PostgresTypes.jsonb:
          return exports.toJson(value);
        case PostgresTypes.timestamp:
          return exports.toTimestampString(value);
        case PostgresTypes.abstime:
        case PostgresTypes.date:
        case PostgresTypes.daterange:
        case PostgresTypes.int4range:
        case PostgresTypes.int8range:
        case PostgresTypes.money:
        case PostgresTypes.reltime:
        case PostgresTypes.text:
        case PostgresTypes.time:
        case PostgresTypes.timestamptz:
        case PostgresTypes.timetz:
        case PostgresTypes.tsrange:
        case PostgresTypes.tstzrange:
          return noop4(value);
        default:
          return noop4(value);
      }
    };
    var noop4 = (value) => {
      return value;
    };
    exports.toBoolean = (value) => {
      switch (value) {
        case "t":
          return true;
        case "f":
          return false;
        default:
          return value;
      }
    };
    exports.toNumber = (value) => {
      if (typeof value === "string") {
        const parsedValue = parseFloat(value);
        if (!Number.isNaN(parsedValue)) {
          return parsedValue;
        }
      }
      return value;
    };
    exports.toJson = (value) => {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch (error2) {
          console.log(`JSON parse error: ${error2}`);
          return value;
        }
      }
      return value;
    };
    exports.toArray = (value, type) => {
      if (typeof value !== "string") {
        return value;
      }
      const lastIdx = value.length - 1;
      const closeBrace = value[lastIdx];
      const openBrace = value[0];
      if (openBrace === "{" && closeBrace === "}") {
        let arr;
        const valTrim = value.slice(1, lastIdx);
        try {
          arr = JSON.parse("[" + valTrim + "]");
        } catch (_) {
          arr = valTrim ? valTrim.split(",") : [];
        }
        return arr.map((val) => exports.convertCell(type, val));
      }
      return value;
    };
    exports.toTimestampString = (value) => {
      if (typeof value === "string") {
        return value.replace(" ", "T");
      }
      return value;
    };
  }
});

// node_modules/@supabase/realtime-js/dist/main/lib/version.js
var require_version4 = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "1.3.6";
  }
});

// node_modules/@supabase/realtime-js/dist/main/lib/constants.js
var require_constants7 = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRANSPORTS = exports.CHANNEL_EVENTS = exports.CHANNEL_STATES = exports.SOCKET_STATES = exports.WS_CLOSE_NORMAL = exports.DEFAULT_TIMEOUT = exports.VSN = exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version4();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `realtime-js/${version_1.version}` };
    exports.VSN = "1.0.0";
    exports.DEFAULT_TIMEOUT = 1e4;
    exports.WS_CLOSE_NORMAL = 1e3;
    var SOCKET_STATES;
    (function(SOCKET_STATES2) {
      SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
      SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
      SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
      SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
    })(SOCKET_STATES = exports.SOCKET_STATES || (exports.SOCKET_STATES = {}));
    var CHANNEL_STATES;
    (function(CHANNEL_STATES2) {
      CHANNEL_STATES2["closed"] = "closed";
      CHANNEL_STATES2["errored"] = "errored";
      CHANNEL_STATES2["joined"] = "joined";
      CHANNEL_STATES2["joining"] = "joining";
      CHANNEL_STATES2["leaving"] = "leaving";
    })(CHANNEL_STATES = exports.CHANNEL_STATES || (exports.CHANNEL_STATES = {}));
    var CHANNEL_EVENTS;
    (function(CHANNEL_EVENTS2) {
      CHANNEL_EVENTS2["close"] = "phx_close";
      CHANNEL_EVENTS2["error"] = "phx_error";
      CHANNEL_EVENTS2["join"] = "phx_join";
      CHANNEL_EVENTS2["reply"] = "phx_reply";
      CHANNEL_EVENTS2["leave"] = "phx_leave";
      CHANNEL_EVENTS2["access_token"] = "access_token";
    })(CHANNEL_EVENTS = exports.CHANNEL_EVENTS || (exports.CHANNEL_EVENTS = {}));
    var TRANSPORTS;
    (function(TRANSPORTS2) {
      TRANSPORTS2["websocket"] = "websocket";
    })(TRANSPORTS = exports.TRANSPORTS || (exports.TRANSPORTS = {}));
  }
});

// node_modules/@supabase/realtime-js/dist/main/lib/timer.js
var require_timer2 = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/lib/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Timer = class {
      constructor(callback, timerCalc) {
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = void 0;
        this.tries = 0;
        this.callback = callback;
        this.timerCalc = timerCalc;
      }
      reset() {
        this.tries = 0;
        clearTimeout(this.timer);
      }
      scheduleTimeout() {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.tries = this.tries + 1;
          this.callback();
        }, this.timerCalc(this.tries + 1));
      }
    };
    exports.default = Timer;
  }
});

// node_modules/@supabase/realtime-js/dist/main/lib/push.js
var require_push = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/lib/push.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants7();
    var Push = class {
      constructor(channel, event, payload = {}, timeout = constants_1.DEFAULT_TIMEOUT) {
        this.channel = channel;
        this.event = event;
        this.payload = payload;
        this.timeout = timeout;
        this.sent = false;
        this.timeoutTimer = void 0;
        this.ref = "";
        this.receivedResp = null;
        this.recHooks = [];
        this.refEvent = null;
      }
      resend(timeout) {
        this.timeout = timeout;
        this._cancelRefEvent();
        this.ref = "";
        this.refEvent = null;
        this.receivedResp = null;
        this.sent = false;
        this.send();
      }
      send() {
        if (this._hasReceived("timeout")) {
          return;
        }
        this.startTimeout();
        this.sent = true;
        this.channel.socket.push({
          topic: this.channel.topic,
          event: this.event,
          payload: this.payload,
          ref: this.ref
        });
      }
      updatePayload(payload) {
        this.payload = Object.assign(Object.assign({}, this.payload), payload);
      }
      receive(status, callback) {
        var _a4;
        if (this._hasReceived(status)) {
          callback((_a4 = this.receivedResp) === null || _a4 === void 0 ? void 0 : _a4.response);
        }
        this.recHooks.push({ status, callback });
        return this;
      }
      startTimeout() {
        if (this.timeoutTimer) {
          return;
        }
        this.ref = this.channel.socket.makeRef();
        this.refEvent = this.channel.replyEventName(this.ref);
        this.channel.on(this.refEvent, (payload) => {
          this._cancelRefEvent();
          this._cancelTimeout();
          this.receivedResp = payload;
          this._matchReceive(payload);
        });
        this.timeoutTimer = setTimeout(() => {
          this.trigger("timeout", {});
        }, this.timeout);
      }
      trigger(status, response) {
        if (this.refEvent)
          this.channel.trigger(this.refEvent, { status, response });
      }
      destroy() {
        this._cancelRefEvent();
        this._cancelTimeout();
      }
      _cancelRefEvent() {
        if (!this.refEvent) {
          return;
        }
        this.channel.off(this.refEvent);
      }
      _cancelTimeout() {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = void 0;
      }
      _matchReceive({ status, response }) {
        this.recHooks.filter((h2) => h2.status === status).forEach((h2) => h2.callback(response));
      }
      _hasReceived(status) {
        return this.receivedResp && this.receivedResp.status === status;
      }
    };
    exports.default = Push;
  }
});

// node_modules/@supabase/realtime-js/dist/main/RealtimeSubscription.js
var require_RealtimeSubscription = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/RealtimeSubscription.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants7();
    var push_1 = __importDefault(require_push());
    var timer_1 = __importDefault(require_timer2());
    var RealtimeSubscription = class {
      constructor(topic, params = {}, socket) {
        this.topic = topic;
        this.params = params;
        this.socket = socket;
        this.bindings = [];
        this.state = constants_1.CHANNEL_STATES.closed;
        this.joinedOnce = false;
        this.pushBuffer = [];
        this.timeout = this.socket.timeout;
        this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);
        this.rejoinTimer = new timer_1.default(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);
        this.joinPush.receive("ok", () => {
          this.state = constants_1.CHANNEL_STATES.joined;
          this.rejoinTimer.reset();
          this.pushBuffer.forEach((pushEvent) => pushEvent.send());
          this.pushBuffer = [];
        });
        this.onClose(() => {
          this.rejoinTimer.reset();
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
          this.state = constants_1.CHANNEL_STATES.closed;
          this.socket.remove(this);
        });
        this.onError((reason) => {
          if (this.isLeaving() || this.isClosed()) {
            return;
          }
          this.socket.log("channel", `error ${this.topic}`, reason);
          this.state = constants_1.CHANNEL_STATES.errored;
          this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive("timeout", () => {
          if (!this.isJoining()) {
            return;
          }
          this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
          this.state = constants_1.CHANNEL_STATES.errored;
          this.rejoinTimer.scheduleTimeout();
        });
        this.on(constants_1.CHANNEL_EVENTS.reply, (payload, ref) => {
          this.trigger(this.replyEventName(ref), payload);
        });
      }
      rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout();
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }
      subscribe(timeout = this.timeout) {
        if (this.joinedOnce) {
          throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
        } else {
          this.joinedOnce = true;
          this.rejoin(timeout);
          return this.joinPush;
        }
      }
      onClose(callback) {
        this.on(constants_1.CHANNEL_EVENTS.close, callback);
      }
      onError(callback) {
        this.on(constants_1.CHANNEL_EVENTS.error, (reason) => callback(reason));
      }
      on(event, callback) {
        this.bindings.push({ event, callback });
      }
      off(event) {
        this.bindings = this.bindings.filter((bind) => bind.event !== event);
      }
      canPush() {
        return this.socket.isConnected() && this.isJoined();
      }
      push(event, payload, timeout = this.timeout) {
        if (!this.joinedOnce) {
          throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        }
        let pushEvent = new push_1.default(this, event, payload, timeout);
        if (this.canPush()) {
          pushEvent.send();
        } else {
          pushEvent.startTimeout();
          this.pushBuffer.push(pushEvent);
        }
        return pushEvent;
      }
      updateJoinPayload(payload) {
        this.joinPush.updatePayload(payload);
      }
      unsubscribe(timeout = this.timeout) {
        this.state = constants_1.CHANNEL_STATES.leaving;
        let onClose = () => {
          this.socket.log("channel", `leave ${this.topic}`);
          this.trigger(constants_1.CHANNEL_EVENTS.close, "leave", this.joinRef());
        };
        this.joinPush.destroy();
        let leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
        leavePush.send();
        if (!this.canPush()) {
          leavePush.trigger("ok", {});
        }
        return leavePush;
      }
      onMessage(event, payload, ref) {
        return payload;
      }
      isMember(topic) {
        return this.topic === topic;
      }
      joinRef() {
        return this.joinPush.ref;
      }
      rejoin(timeout = this.timeout) {
        if (this.isLeaving()) {
          return;
        }
        this.socket.leaveOpenTopic(this.topic);
        this.state = constants_1.CHANNEL_STATES.joining;
        this.joinPush.resend(timeout);
      }
      trigger(event, payload, ref) {
        let { close, error: error2, leave, join } = constants_1.CHANNEL_EVENTS;
        let events = [close, error2, leave, join];
        if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {
          return;
        }
        let handledPayload = this.onMessage(event, payload, ref);
        if (payload && !handledPayload) {
          throw "channel onMessage callbacks must return the payload, modified or unmodified";
        }
        this.bindings.filter((bind) => {
          if (bind.event === "*") {
            return event === (payload === null || payload === void 0 ? void 0 : payload.type);
          } else {
            return bind.event === event;
          }
        }).map((bind) => bind.callback(handledPayload, ref));
      }
      replyEventName(ref) {
        return `chan_reply_${ref}`;
      }
      isClosed() {
        return this.state === constants_1.CHANNEL_STATES.closed;
      }
      isErrored() {
        return this.state === constants_1.CHANNEL_STATES.errored;
      }
      isJoined() {
        return this.state === constants_1.CHANNEL_STATES.joined;
      }
      isJoining() {
        return this.state === constants_1.CHANNEL_STATES.joining;
      }
      isLeaving() {
        return this.state === constants_1.CHANNEL_STATES.leaving;
      }
    };
    exports.default = RealtimeSubscription;
  }
});

// node_modules/websocket/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/websocket/node_modules/ms/index.js"(exports, module2) {
    var s3 = 1e3;
    var m2 = s3 * 60;
    var h2 = m2 * 60;
    var d = h2 * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (ms >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (ms >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h2, "hour") || plural(ms, m2, "minute") || plural(ms, s3, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/websocket/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "node_modules/websocket/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i2;
      for (i2 in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return exports.colors[Math.abs(hash2) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format2];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split2.length;
      for (var i2 = 0; i2 < len; i2++) {
        if (!split2[i2])
          continue;
        namespaces = split2[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i2, len;
      for (i2 = 0, len = exports.skips.length; i2 < len; i2++) {
        if (exports.skips[i2].test(name)) {
          return false;
        }
      }
      for (i2 = 0, len = exports.names.length; i2 < len; i2++) {
        if (exports.names[i2].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/websocket/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/websocket/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug2();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e2) {
      }
    }
    function load2() {
      var r2;
      try {
        r2 = exports.storage.debug;
      } catch (e2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    exports.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e2) {
      }
    }
  }
});

// node_modules/websocket/node_modules/debug/src/node.js
var require_node24 = __commonJS({
  "node_modules/websocket/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports = module2.exports = require_debug2();
    exports.init = init3;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key2) {
      return /^debug_/i.test(key2);
    }).reduce(function(obj, key2) {
      var prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init3(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
      }
    }
    exports.enable(load2());
  }
});

// node_modules/websocket/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/websocket/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node24();
    }
  }
});

// node_modules/websocket/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/websocket/lib/utils.js"(exports) {
    var noop4 = exports.noop = function() {
    };
    exports.extend = function extend(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    };
    exports.eventEmitterListenerCount = require("events").EventEmitter.listenerCount || function(emitter, type) {
      return emitter.listeners(type).length;
    };
    exports.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {
      return new Buffer(size);
    };
    exports.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };
    exports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
      var logFunction = require_src2()(identifier);
      if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug = logger.log.bind(logger);
        debug.printOutput = logger.printOutput.bind(logger);
        debug.enabled = logFunction.enabled;
        return debug;
      }
      logFunction.printOutput = noop4;
      return logFunction;
    };
    function BufferingLogger(identifier, uniqueID, logFunction) {
      this.logFunction = logFunction;
      this.identifier = identifier;
      this.uniqueID = uniqueID;
      this.buffer = [];
    }
    BufferingLogger.prototype.log = function() {
      this.buffer.push([new Date(), Array.prototype.slice.call(arguments)]);
      return this;
    };
    BufferingLogger.prototype.clear = function() {
      this.buffer = [];
      return this;
    };
    BufferingLogger.prototype.printOutput = function(logFunction) {
      if (!logFunction) {
        logFunction = this.logFunction;
      }
      var uniqueID = this.uniqueID;
      this.buffer.forEach(function(entry6) {
        var date = entry6[0].toLocaleString();
        var args = entry6[1].slice();
        var formatString = args[0];
        if (formatString !== void 0 && formatString !== null) {
          formatString = "%s - %s - " + formatString.toString();
          args.splice(0, 1, formatString, date, uniqueID);
          logFunction.apply(global, args);
        }
      });
    };
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : "node";
    var arch = os.arch();
    var platform = os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load2;
    function load2(dir) {
      return runtimeRequire(load2.path(dir));
    }
    load2.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve2(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve2(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve2(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var tag = arr[i2];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load2.parseTags = parseTags;
    load2.matchTags = matchTags;
    load2.compareTags = compareTags;
    load2.parseTuple = parseTuple;
    load2.matchTuple = matchTuple;
    load2.compareTuples = compareTuples;
  }
});

// node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "node_modules/bufferutil/fallback.js"(exports, module2) {
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i2 = 0; i2 < length; i2++) {
        output[offset + i2] = source[i2] ^ mask2[i2 & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i2 = 0; i2 < length; i2++) {
        buffer[i2] ^= mask2[i2 & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "node_modules/bufferutil/index.js"(exports, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e2) {
      module2.exports = require_fallback();
    }
  }
});

// node_modules/websocket/lib/WebSocketFrame.js
var require_WebSocketFrame = __commonJS({
  "node_modules/websocket/lib/WebSocketFrame.js"(exports, module2) {
    var bufferUtil = require_bufferutil();
    var bufferAllocUnsafe = require_utils4().bufferAllocUnsafe;
    var DECODE_HEADER = 1;
    var WAITING_FOR_16_BIT_LENGTH = 2;
    var WAITING_FOR_64_BIT_LENGTH = 3;
    var WAITING_FOR_MASK_KEY = 4;
    var WAITING_FOR_PAYLOAD = 5;
    var COMPLETE = 6;
    function WebSocketFrame(maskBytes, frameHeader, config) {
      this.maskBytes = maskBytes;
      this.frameHeader = frameHeader;
      this.config = config;
      this.maxReceivedFrameSize = config.maxReceivedFrameSize;
      this.protocolError = false;
      this.frameTooLarge = false;
      this.invalidCloseFrameLength = false;
      this.parseState = DECODE_HEADER;
      this.closeStatus = -1;
    }
    WebSocketFrame.prototype.addData = function(bufferList) {
      if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 0, 0, 2);
          bufferList.advance(2);
          var firstByte = this.frameHeader[0];
          var secondByte = this.frameHeader[1];
          this.fin = Boolean(firstByte & 128);
          this.rsv1 = Boolean(firstByte & 64);
          this.rsv2 = Boolean(firstByte & 32);
          this.rsv3 = Boolean(firstByte & 16);
          this.mask = Boolean(secondByte & 128);
          this.opcode = firstByte & 15;
          this.length = secondByte & 127;
          if (this.opcode >= 8) {
            if (this.length > 125) {
              this.protocolError = true;
              this.dropReason = "Illegal control frame longer than 125 bytes.";
              return true;
            }
            if (!this.fin) {
              this.protocolError = true;
              this.dropReason = "Control frames must not be fragmented.";
              return true;
            }
          }
          if (this.length === 126) {
            this.parseState = WAITING_FOR_16_BIT_LENGTH;
          } else if (this.length === 127) {
            this.parseState = WAITING_FOR_64_BIT_LENGTH;
          } else {
            this.parseState = WAITING_FOR_MASK_KEY;
          }
        }
      }
      if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 2, 0, 2);
          bufferList.advance(2);
          this.length = this.frameHeader.readUInt16BE(2);
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
          bufferList.joinInto(this.frameHeader, 2, 0, 8);
          bufferList.advance(8);
          var lengthPair = [
            this.frameHeader.readUInt32BE(2),
            this.frameHeader.readUInt32BE(2 + 4)
          ];
          if (lengthPair[0] !== 0) {
            this.protocolError = true;
            this.dropReason = "Unsupported 64-bit length frame received";
            return true;
          }
          this.length = lengthPair[1];
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      }
      if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
          if (bufferList.length >= 4) {
            bufferList.joinInto(this.maskBytes, 0, 0, 4);
            bufferList.advance(4);
            this.parseState = WAITING_FOR_PAYLOAD;
          }
        } else {
          this.parseState = WAITING_FOR_PAYLOAD;
        }
      }
      if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
          this.frameTooLarge = true;
          this.dropReason = "Frame size of " + this.length.toString(10) + " bytes exceeds maximum accepted frame size";
          return true;
        }
        if (this.length === 0) {
          this.binaryPayload = bufferAllocUnsafe(0);
          this.parseState = COMPLETE;
          return true;
        }
        if (bufferList.length >= this.length) {
          this.binaryPayload = bufferList.take(this.length);
          bufferList.advance(this.length);
          if (this.mask) {
            bufferUtil.unmask(this.binaryPayload, this.maskBytes);
          }
          if (this.opcode === 8) {
            if (this.length === 1) {
              this.binaryPayload = bufferAllocUnsafe(0);
              this.invalidCloseFrameLength = true;
            }
            if (this.length >= 2) {
              this.closeStatus = this.binaryPayload.readUInt16BE(0);
              this.binaryPayload = this.binaryPayload.slice(2);
            }
          }
          this.parseState = COMPLETE;
          return true;
        }
      }
      return false;
    };
    WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
      if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
      }
      return false;
    };
    WebSocketFrame.prototype.toBuffer = function(nullMask) {
      var maskKey;
      var headerLength = 2;
      var data;
      var outputPos;
      var firstByte = 0;
      var secondByte = 0;
      if (this.fin) {
        firstByte |= 128;
      }
      if (this.rsv1) {
        firstByte |= 64;
      }
      if (this.rsv2) {
        firstByte |= 32;
      }
      if (this.rsv3) {
        firstByte |= 16;
      }
      if (this.mask) {
        secondByte |= 128;
      }
      firstByte |= this.opcode & 15;
      if (this.opcode === 8) {
        this.length = 2;
        if (this.binaryPayload) {
          this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
          this.binaryPayload.copy(data, 2);
        }
      } else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
      } else {
        this.length = 0;
      }
      if (this.length <= 125) {
        secondByte |= this.length & 127;
      } else if (this.length > 125 && this.length <= 65535) {
        secondByte |= 126;
        headerLength += 2;
      } else if (this.length > 65535) {
        secondByte |= 127;
        headerLength += 8;
      }
      var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));
      output[0] = firstByte;
      output[1] = secondByte;
      outputPos = 2;
      if (this.length > 125 && this.length <= 65535) {
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
      } else if (this.length > 65535) {
        output.writeUInt32BE(0, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
      }
      if (this.mask) {
        maskKey = nullMask ? 0 : Math.random() * 4294967295 >>> 0;
        this.maskBytes.writeUInt32BE(maskKey, 0);
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;
        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
      } else if (data) {
        data.copy(output, outputPos);
      }
      return output;
    };
    WebSocketFrame.prototype.toString = function() {
      return "Opcode: " + this.opcode + ", fin: " + this.fin + ", length: " + this.length + ", hasPayload: " + Boolean(this.binaryPayload) + ", masked: " + this.mask;
    };
    module2.exports = WebSocketFrame;
  }
});

// node_modules/websocket/vendor/FastBufferList.js
var require_FastBufferList = __commonJS({
  "node_modules/websocket/vendor/FastBufferList.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    var EventEmitter = require("events").EventEmitter;
    var bufferAllocUnsafe = require_utils4().bufferAllocUnsafe;
    module2.exports = BufferList;
    module2.exports.BufferList = BufferList;
    function BufferList(opts) {
      if (!(this instanceof BufferList))
        return new BufferList(opts);
      EventEmitter.call(this);
      var self2 = this;
      if (typeof opts == "undefined")
        opts = {};
      self2.encoding = opts.encoding;
      var head = { next: null, buffer: null };
      var last = { next: null, buffer: null };
      var length = 0;
      self2.__defineGetter__("length", function() {
        return length;
      });
      var offset = 0;
      self2.write = function(buf) {
        if (!head.buffer) {
          head.buffer = buf;
          last = head;
        } else {
          last.next = { next: null, buffer: buf };
          last = last.next;
        }
        length += buf.length;
        self2.emit("write", buf);
        return true;
      };
      self2.end = function(buf) {
        if (Buffer2.isBuffer(buf))
          self2.write(buf);
      };
      self2.push = function() {
        var args = [].concat.apply([], arguments);
        args.forEach(self2.write);
        return self2;
      };
      self2.forEach = function(fn) {
        if (!head.buffer)
          return bufferAllocUnsafe(0);
        if (head.buffer.length - offset <= 0)
          return self2;
        var firstBuf = head.buffer.slice(offset);
        var b = { buffer: firstBuf, next: head.next };
        while (b && b.buffer) {
          var r2 = fn(b.buffer);
          if (r2)
            break;
          b = b.next;
        }
        return self2;
      };
      self2.join = function(start, end) {
        if (!head.buffer)
          return bufferAllocUnsafe(0);
        if (start == void 0)
          start = 0;
        if (end == void 0)
          end = self2.length;
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self2.forEach(function(buffer) {
          if (start < ix + buffer.length && ix < end) {
            buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));
          }
          ix += buffer.length;
          if (ix > end)
            return true;
        });
        return big;
      };
      self2.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer)
          return new bufferAllocUnsafe(0);
        if (sourceStart == void 0)
          sourceStart = 0;
        if (sourceEnd == void 0)
          sourceEnd = self2.length;
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
          throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self2.forEach(function(buffer) {
          if (sourceStart < ix + buffer.length && ix < sourceEnd) {
            buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));
          }
          ix += buffer.length;
          if (ix > sourceEnd)
            return true;
        });
        return big;
      };
      self2.advance = function(n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
          offset -= head.buffer.length;
          head = head.next ? head.next : { buffer: null, next: null };
        }
        if (head.buffer === null)
          last = { next: null, buffer: null };
        self2.emit("advance", n);
        return self2;
      };
      self2.take = function(n, encoding) {
        if (n == void 0)
          n = self2.length;
        else if (typeof n !== "number") {
          encoding = n;
          n = self2.length;
        }
        var b = head;
        if (!encoding)
          encoding = self2.encoding;
        if (encoding) {
          var acc = "";
          self2.forEach(function(buffer) {
            if (n <= 0)
              return true;
            acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));
            n -= buffer.length;
          });
          return acc;
        } else {
          return self2.join(0, n);
        }
      };
      self2.toString = function() {
        return self2.take("binary");
      };
    }
    require("util").inherits(BufferList, EventEmitter);
  }
});

// node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "node_modules/utf-8-validate/fallback.js"(exports, module2) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "node_modules/utf-8-validate/index.js"(exports, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e2) {
      module2.exports = require_fallback2();
    }
  }
});

// node_modules/websocket/lib/WebSocketConnection.js
var require_WebSocketConnection = __commonJS({
  "node_modules/websocket/lib/WebSocketConnection.js"(exports, module2) {
    var util = require("util");
    var utils = require_utils4();
    var EventEmitter = require("events").EventEmitter;
    var WebSocketFrame = require_WebSocketFrame();
    var BufferList = require_FastBufferList();
    var isValidUTF8 = require_utf_8_validate();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var bufferFromString = utils.bufferFromString;
    var STATE_OPEN = "open";
    var STATE_PEER_REQUESTED_CLOSE = "peer_requested_close";
    var STATE_ENDING = "ending";
    var STATE_CLOSED = "closed";
    var setImmediateImpl = "setImmediate" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);
    var idCounter = 0;
    function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
      this._debug = utils.BufferingLogger("websocket:connection", ++idCounter);
      this._debug("constructor");
      if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
      }
      EventEmitter.call(this);
      this._pingListenerCount = 0;
      this.on("newListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount++;
        }
      }).on("removeListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount--;
        }
      });
      this.config = config;
      this.socket = socket;
      this.protocol = protocol;
      this.extensions = extensions;
      this.remoteAddress = socket.remoteAddress;
      this.closeReasonCode = -1;
      this.closeDescription = null;
      this.closeEventEmitted = false;
      this.maskOutgoingPackets = maskOutgoingPackets;
      this.maskBytes = bufferAllocUnsafe(4);
      this.frameHeader = bufferAllocUnsafe(10);
      this.bufferList = new BufferList();
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      this.fragmentationSize = 0;
      this.frameQueue = [];
      this.connected = true;
      this.state = STATE_OPEN;
      this.waitingForCloseResponse = false;
      this.receivedEnd = false;
      this.closeTimeout = this.config.closeTimeout;
      this.assembleFragments = this.config.assembleFragments;
      this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;
      this.outputBufferFull = false;
      this.inputPaused = false;
      this.receivedDataHandler = this.processReceivedData.bind(this);
      this._closeTimerHandler = this.handleCloseTimer.bind(this);
      this.socket.setNoDelay(this.config.disableNagleAlgorithm);
      this.socket.setTimeout(0);
      if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof this.config.keepaliveInterval !== "number") {
          throw new Error("keepaliveInterval must be specified and numeric if keepalive is true.");
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();
        if (this.config.dropConnectionOnKeepaliveTimeout) {
          if (typeof this.config.keepaliveGracePeriod !== "number") {
            throw new Error("keepaliveGracePeriod  must be specified and numeric if dropConnectionOnKeepaliveTimeout is true.");
          }
          this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
      } else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!("setKeepAlive" in this.socket)) {
          throw new Error("Unable to use native keepalive: unsupported by this version of Node.");
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
      }
      this.socket.removeAllListeners("error");
    }
    WebSocketConnection.CLOSE_REASON_NORMAL = 1e3;
    WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
    WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
    WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
    WebSocketConnection.CLOSE_REASON_RESERVED = 1004;
    WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005;
    WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006;
    WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
    WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
    WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
    WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
    WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
    WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015;
    WebSocketConnection.CLOSE_DESCRIPTIONS = {
      1e3: "Normal connection closure",
      1001: "Remote peer is going away",
      1002: "Protocol error",
      1003: "Unprocessable input",
      1004: "Reserved",
      1005: "Reason not provided",
      1006: "Abnormal closure, no further detail available",
      1007: "Invalid data received",
      1008: "Policy violation",
      1009: "Message too big",
      1010: "Extension requested by client is required",
      1011: "Internal Server Error",
      1015: "TLS Handshake Failed"
    };
    function validateCloseReason(code) {
      if (code < 1e3) {
        return false;
      }
      if (code >= 1e3 && code <= 2999) {
        return [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
      }
      if (code >= 3e3 && code <= 3999) {
        return true;
      }
      if (code >= 4e3 && code <= 4999) {
        return true;
      }
      if (code >= 5e3) {
        return false;
      }
    }
    util.inherits(WebSocketConnection, EventEmitter);
    WebSocketConnection.prototype._addSocketEventListeners = function() {
      this.socket.on("error", this.handleSocketError.bind(this));
      this.socket.on("end", this.handleSocketEnd.bind(this));
      this.socket.on("close", this.handleSocketClose.bind(this));
      this.socket.on("drain", this.handleSocketDrain.bind(this));
      this.socket.on("pause", this.handleSocketPause.bind(this));
      this.socket.on("resume", this.handleSocketResume.bind(this));
      this.socket.on("data", this.handleSocketData.bind(this));
    };
    WebSocketConnection.prototype.setKeepaliveTimer = function() {
      this._debug("setKeepaliveTimer");
      if (!this.config.keepalive || this.config.useNativeKeepalive) {
        return;
      }
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
    };
    WebSocketConnection.prototype.clearKeepaliveTimer = function() {
      if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleKeepaliveTimer = function() {
      this._debug("handleKeepaliveTimer");
      this._keepaliveTimeoutID = null;
      this.ping();
      if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
      } else {
        this.setKeepaliveTimer();
      }
    };
    WebSocketConnection.prototype.setGracePeriodTimer = function() {
      this._debug("setGracePeriodTimer");
      this.clearGracePeriodTimer();
      this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
    };
    WebSocketConnection.prototype.clearGracePeriodTimer = function() {
      if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleGracePeriodTimer = function() {
      this._debug("handleGracePeriodTimer");
      this._gracePeriodTimeoutID = null;
      this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, "Peer not responding.", true);
    };
    WebSocketConnection.prototype.handleSocketData = function(data) {
      this._debug("handleSocketData");
      this.setKeepaliveTimer();
      this.bufferList.write(data);
      this.processReceivedData();
    };
    WebSocketConnection.prototype.processReceivedData = function() {
      this._debug("processReceivedData");
      if (!this.connected) {
        return;
      }
      if (this.inputPaused) {
        return;
      }
      var frame = this.currentFrame;
      if (!frame.addData(this.bufferList)) {
        this._debug("-- insufficient data for frame");
        return;
      }
      var self2 = this;
      if (frame.protocolError) {
        this._debug("-- protocol error");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
      } else if (frame.frameTooLarge) {
        this._debug("-- frame too large");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
      }
      if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug("-- illegal rsv flag");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unsupported usage of rsv bits without negotiated extension.");
        });
        return;
      }
      if (!this.assembleFragments) {
        this._debug("-- emitting frame");
        process.nextTick(function() {
          self2.emit("frame", frame);
        });
      }
      process.nextTick(function() {
        self2.processFrame(frame);
      });
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
      }
    };
    WebSocketConnection.prototype.handleSocketError = function(error2) {
      this._debug("handleSocketError: %j", error2);
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'error' after 'close'");
        return;
      }
      this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
      this.closeDescription = "Socket Error: " + error2.syscall + " " + error2.code;
      this.connected = false;
      this.state = STATE_CLOSED;
      this.fragmentationSize = 0;
      if (utils.eventEmitterListenerCount(this, "error") > 0) {
        this.emit("error", error2);
      }
      this.socket.destroy();
      this._debug.printOutput();
    };
    WebSocketConnection.prototype.handleSocketEnd = function() {
      this._debug("handleSocketEnd: received socket end.  state = %s", this.state);
      this.receivedEnd = true;
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'end' after 'close'");
        return;
      }
      if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {
        this._debug("  --- UNEXPECTED socket end.");
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.handleSocketClose = function(hadError) {
      this._debug("handleSocketClose: received socket close");
      this.socketHadError = hadError;
      this.connected = false;
      this.state = STATE_CLOSED;
      if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = "Connection dropped by remote peer.";
      }
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("-- Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
    };
    WebSocketConnection.prototype.handleSocketDrain = function() {
      this._debug("handleSocketDrain: socket drain event");
      this.outputBufferFull = false;
      this.emit("drain");
    };
    WebSocketConnection.prototype.handleSocketPause = function() {
      this._debug("handleSocketPause: socket pause event");
      this.inputPaused = true;
      this.emit("pause");
    };
    WebSocketConnection.prototype.handleSocketResume = function() {
      this._debug("handleSocketResume: socket resume event");
      this.inputPaused = false;
      this.emit("resume");
      this.processReceivedData();
    };
    WebSocketConnection.prototype.pause = function() {
      this._debug("pause: pause requested");
      this.socket.pause();
    };
    WebSocketConnection.prototype.resume = function() {
      this._debug("resume: resume requested");
      this.socket.resume();
    };
    WebSocketConnection.prototype.close = function(reasonCode, description) {
      if (this.connected) {
        this._debug("close: Initating clean WebSocket close sequence.");
        if (typeof reasonCode !== "number") {
          reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
          throw new Error("Close code " + reasonCode + " is not valid.");
        }
        if (typeof description !== "string") {
          description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
      }
    };
    WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
      this._debug("drop");
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
      }
      if (typeof description !== "string") {
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
      }
      this._debug("Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s", skipCloseFrame, reasonCode, description);
      this.closeReasonCode = reasonCode;
      this.closeDescription = description;
      this.frameQueue = [];
      this.fragmentationSize = 0;
      if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
      }
      this.connected = false;
      this.state = STATE_CLOSED;
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
      this._debug("Drop: destroying socket");
      this.socket.destroy();
    };
    WebSocketConnection.prototype.setCloseTimer = function() {
      this._debug("setCloseTimer");
      this.clearCloseTimer();
      this._debug("Setting close timer");
      this.waitingForCloseResponse = true;
      this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
    };
    WebSocketConnection.prototype.clearCloseTimer = function() {
      this._debug("clearCloseTimer");
      if (this.closeTimer) {
        this._debug("Clearing close timer");
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
      }
    };
    WebSocketConnection.prototype.handleCloseTimer = function() {
      this._debug("handleCloseTimer");
      this.closeTimer = null;
      if (this.waitingForCloseResponse) {
        this._debug("Close response not received from client.  Forcing socket end.");
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.processFrame = function(frame) {
      this._debug("processFrame");
      this._debug(" -- frame: %s", frame);
      if (this.frameQueue.length !== 0 && (frame.opcode > 0 && frame.opcode < 8)) {
        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Illegal frame opcode 0x" + frame.opcode.toString(16) + " received in middle of fragmented message.");
        return;
      }
      switch (frame.opcode) {
        case 2:
          this._debug("-- Binary Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "binary",
                binaryData: frame.binaryPayload
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 1:
          this._debug("-- Text Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              if (!isValidUTF8(frame.binaryPayload)) {
                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, "Invalid UTF-8 Data Received");
                return;
              }
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "utf8",
                utf8Data: frame.binaryPayload.toString("utf8")
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 0:
          this._debug("-- Continuation Frame");
          if (this.assembleFragments) {
            if (this.frameQueue.length === 0) {
              this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unexpected Continuation Frame");
              return;
            }
            this.fragmentationSize += frame.length;
            if (this.fragmentationSize > this.maxReceivedMessageSize) {
              this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, "Maximum message size exceeded.");
              return;
            }
            this.frameQueue.push(frame);
            if (frame.fin) {
              var bytesCopied = 0;
              var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
              var opcode = this.frameQueue[0].opcode;
              this.frameQueue.forEach(function(currentFrame) {
                currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                bytesCopied += currentFrame.binaryPayload.length;
              });
              this.frameQueue = [];
              this.fragmentationSize = 0;
              switch (opcode) {
                case 2:
                  this.emit("message", {
                    type: "binary",
                    binaryData: binaryPayload
                  });
                  break;
                case 1:
                  if (!isValidUTF8(binaryPayload)) {
                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, "Invalid UTF-8 Data Received");
                    return;
                  }
                  this.emit("message", {
                    type: "utf8",
                    utf8Data: binaryPayload.toString("utf8")
                  });
                  break;
                default:
                  this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unexpected first opcode in fragmentation sequence: 0x" + opcode.toString(16));
                  return;
              }
            }
          }
          break;
        case 9:
          this._debug("-- Ping Frame");
          if (this._pingListenerCount > 0) {
            var cancelled = false;
            var cancel = function() {
              cancelled = true;
            };
            this.emit("ping", cancel, frame.binaryPayload);
            if (!cancelled) {
              this.pong(frame.binaryPayload);
            }
          } else {
            this.pong(frame.binaryPayload);
          }
          break;
        case 10:
          this._debug("-- Pong Frame");
          this.emit("pong", frame.binaryPayload);
          break;
        case 8:
          this._debug("-- Close Frame");
          if (this.waitingForCloseResponse) {
            this._debug("---- Got close response from peer.  Completing closing handshake.");
            this.clearCloseTimer();
            this.waitingForCloseResponse = false;
            this.state = STATE_CLOSED;
            this.socket.end();
            return;
          }
          this._debug("---- Closing handshake initiated by peer.");
          this.state = STATE_PEER_REQUESTED_CLOSE;
          var respondCloseReasonCode;
          if (frame.invalidCloseFrameLength) {
            this.closeReasonCode = 1005;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
          } else {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          }
          if (frame.binaryPayload.length > 1) {
            if (!isValidUTF8(frame.binaryPayload)) {
              this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, "Invalid UTF-8 Data Received");
              return;
            }
            this.closeDescription = frame.binaryPayload.toString("utf8");
          } else {
            this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
          }
          this._debug("------ Remote peer %s - code: %d - %s - close frame payload length: %d", this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);
          this._debug("------ responding to remote peer's close request.");
          this.sendCloseFrame(respondCloseReasonCode, null);
          this.connected = false;
          break;
        default:
          this._debug("-- Unrecognized Opcode %d", frame.opcode);
          this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unrecognized Opcode: 0x" + frame.opcode.toString(16));
          break;
      }
    };
    WebSocketConnection.prototype.send = function(data, cb) {
      this._debug("send");
      if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
      } else if (typeof data["toString"] === "function") {
        this.sendUTF(data, cb);
      } else {
        throw new Error("Data provided must either be a Node Buffer or implement toString()");
      }
    };
    WebSocketConnection.prototype.sendUTF = function(data, cb) {
      data = bufferFromString(data.toString(), "utf8");
      this._debug("sendUTF: %d bytes", data.length);
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 1;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.sendBytes = function(data, cb) {
      this._debug("sendBytes");
      if (!Buffer.isBuffer(data)) {
        throw new Error("You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()");
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 2;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.ping = function(data) {
      this._debug("ping");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 9;
      frame.fin = true;
      if (data) {
        if (!Buffer.isBuffer(data)) {
          data = bufferFromString(data.toString(), "utf8");
        }
        if (data.length > 125) {
          this._debug("WebSocket: Data for ping is longer than 125 bytes.  Truncating.");
          data = data.slice(0, 124);
        }
        frame.binaryPayload = data;
      }
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.pong = function(binaryPayload) {
      this._debug("pong");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 10;
      if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug("WebSocket: Data for pong is longer than 125 bytes.  Truncating.");
        binaryPayload = binaryPayload.slice(0, 124);
      }
      frame.binaryPayload = binaryPayload;
      frame.fin = true;
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
      this._debug("fragmentAndSend");
      if (frame.opcode > 7) {
        throw new Error("You cannot fragment control frames.");
      }
      var threshold = this.config.fragmentationThreshold;
      var length = frame.binaryPayload.length;
      if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
      }
      var numFragments = Math.ceil(length / threshold);
      var sentFragments = 0;
      var sentCallback = function fragmentSentCallback(err) {
        if (err) {
          if (typeof cb === "function") {
            cb(err);
            cb = null;
          }
          return;
        }
        ++sentFragments;
        if (sentFragments === numFragments && typeof cb === "function") {
          cb();
        }
      };
      for (var i2 = 1; i2 <= numFragments; i2++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        currentFrame.opcode = i2 === 1 ? frame.opcode : 0;
        currentFrame.fin = i2 === numFragments;
        var currentLength = i2 === numFragments ? length - threshold * (i2 - 1) : threshold;
        var sliceStart = threshold * (i2 - 1);
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        this.sendFrame(currentFrame, sentCallback);
      }
    };
    WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
      }
      this._debug("sendCloseFrame state: %s, reasonCode: %d, description: %s", this.state, reasonCode, description);
      if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {
        return;
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.fin = true;
      frame.opcode = 8;
      frame.closeStatus = reasonCode;
      if (typeof description === "string") {
        frame.binaryPayload = bufferFromString(description, "utf8");
      }
      this.sendFrame(frame, cb);
      this.socket.end();
    };
    WebSocketConnection.prototype.sendFrame = function(frame, cb) {
      this._debug("sendFrame");
      frame.mask = this.maskOutgoingPackets;
      var flushed = this.socket.write(frame.toBuffer(), cb);
      this.outputBufferFull = !flushed;
      return flushed;
    };
    module2.exports = WebSocketConnection;
    function instrumentSocketForDebugging(connection, socket) {
      if (!connection._debug.enabled) {
        return;
      }
      var originalSocketEmit = socket.emit;
      socket.emit = function(event) {
        connection._debug("||| Socket Event  '%s'", event);
        originalSocketEmit.apply(this, arguments);
      };
      for (var key2 in socket) {
        if (typeof socket[key2] !== "function") {
          continue;
        }
        if (["emit"].indexOf(key2) !== -1) {
          continue;
        }
        (function(key3) {
          var original = socket[key3];
          if (key3 === "on") {
            socket[key3] = function proxyMethod__EventEmitter__On() {
              connection._debug("||| Socket method called:  %s (%s)", key3, arguments[0]);
              return original.apply(this, arguments);
            };
            return;
          }
          socket[key3] = function proxyMethod() {
            connection._debug("||| Socket method called:  %s", key3);
            return original.apply(this, arguments);
          };
        })(key2);
      }
    }
  }
});

// node_modules/websocket/lib/WebSocketRequest.js
var require_WebSocketRequest = __commonJS({
  "node_modules/websocket/lib/WebSocketRequest.js"(exports, module2) {
    var crypto2 = require("crypto");
    var util = require("util");
    var url = require("url");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketConnection = require_WebSocketConnection();
    var headerValueSplitRegExp = /,\s*/;
    var headerParamSplitRegExp = /;\s*/;
    var headerSanitizeRegExp = /[\r\n]/g;
    var xForwardedForSeparatorRegExp = /,\s*/;
    var separators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var controlChars = [String.fromCharCode(127)];
    for (i2 = 0; i2 < 31; i2++) {
      controlChars.push(String.fromCharCode(i2));
    }
    var i2;
    var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
    var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
    var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
    var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;
    var cookieSeparatorRegEx = /[;,] */;
    var httpStatusDescriptions = {
      100: "Continue",
      101: "Switching Protocols",
      200: "OK",
      201: "Created",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      406: "Not Acceptable",
      407: "Proxy Authorization Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Long",
      414: "Request-URI Too Long",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      426: "Upgrade Required",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported"
    };
    function WebSocketRequest(socket, httpRequest, serverConfig) {
      EventEmitter.call(this);
      this.socket = socket;
      this.httpRequest = httpRequest;
      this.resource = httpRequest.url;
      this.remoteAddress = socket.remoteAddress;
      this.remoteAddresses = [this.remoteAddress];
      this.serverConfig = serverConfig;
      this._socketIsClosing = false;
      this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
      this.socket.on("end", this._socketCloseHandler);
      this.socket.on("close", this._socketCloseHandler);
      this._resolved = false;
    }
    util.inherits(WebSocketRequest, EventEmitter);
    WebSocketRequest.prototype.readHandshake = function() {
      var self2 = this;
      var request = this.httpRequest;
      this.resourceURL = url.parse(this.resource, true);
      this.host = request.headers["host"];
      if (!this.host) {
        throw new Error("Client must provide a Host header.");
      }
      this.key = request.headers["sec-websocket-key"];
      if (!this.key) {
        throw new Error("Client must provide a value for Sec-WebSocket-Key.");
      }
      this.webSocketVersion = parseInt(request.headers["sec-websocket-version"], 10);
      if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error("Client must provide a value for Sec-WebSocket-Version.");
      }
      switch (this.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          var e2 = new Error("Unsupported websocket client version: " + this.webSocketVersion + "Only versions 8 and 13 are supported.");
          e2.httpCode = 426;
          e2.headers = {
            "Sec-WebSocket-Version": "13"
          };
          throw e2;
      }
      if (this.webSocketVersion === 13) {
        this.origin = request.headers["origin"];
      } else if (this.webSocketVersion === 8) {
        this.origin = request.headers["sec-websocket-origin"];
      }
      var protocolString = request.headers["sec-websocket-protocol"];
      this.protocolFullCaseMap = {};
      this.requestedProtocols = [];
      if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
          var lcProtocol = protocol.toLocaleLowerCase();
          self2.requestedProtocols.push(lcProtocol);
          self2.protocolFullCaseMap[lcProtocol] = protocol;
        });
      }
      if (!this.serverConfig.ignoreXForwardedFor && request.headers["x-forwarded-for"]) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers["x-forwarded-for"].split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
      }
      if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers["sec-websocket-extensions"];
        this.requestedExtensions = this.parseExtensions(extensionsString);
      } else {
        this.requestedExtensions = [];
      }
      if (this.serverConfig.parseCookies) {
        var cookieString = request.headers["cookie"];
        this.cookies = this.parseCookies(cookieString);
      } else {
        this.cookies = [];
      }
    };
    WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
      if (!extensionsString || extensionsString.length === 0) {
        return [];
      }
      var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
      extensions.forEach(function(extension, index, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index2, array2) {
          var arr = rawParam.split("=");
          var obj2 = {
            name: arr[0],
            value: arr[1]
          };
          array2.splice(index2, 1, obj2);
        });
        var obj = {
          name: extensionName,
          params: extensionParams
        };
        array.splice(index, 1, obj);
      });
      return extensions;
    };
    WebSocketRequest.prototype.parseCookies = function(str) {
      if (!str || typeof str !== "string") {
        return [];
      }
      var cookies = [];
      var pairs = str.split(cookieSeparatorRegEx);
      pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf("=");
        if (eq_idx === -1) {
          cookies.push({
            name: pair,
            value: null
          });
          return;
        }
        var key2 = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] === '"') {
          val = val.slice(1, -1);
        }
        cookies.push({
          name: key2,
          value: decodeURIComponent(val)
        });
      });
      return cookies;
    };
    WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
      this._verifyResolution();
      var protocolFullCase;
      if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof protocolFullCase === "undefined") {
          protocolFullCase = acceptedProtocol;
        }
      } else {
        protocolFullCase = acceptedProtocol;
      }
      this.protocolFullCaseMap = null;
      var sha1 = crypto2.createHash("sha1");
      sha1.update(this.key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var acceptKey = sha1.digest("base64");
      var response = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: " + acceptKey + "\r\n";
      if (protocolFullCase) {
        for (var i3 = 0; i3 < protocolFullCase.length; i3++) {
          var charCode = protocolFullCase.charCodeAt(i3);
          var character = protocolFullCase.charAt(i3);
          if (charCode < 33 || charCode > 126 || separators.indexOf(character) !== -1) {
            this.reject(500);
            throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
          }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
          this.reject(500);
          throw new Error("Specified protocol was not requested by the client.");
        }
        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, "");
        response += "Sec-WebSocket-Protocol: " + protocolFullCase + "\r\n";
      }
      this.requestedProtocols = null;
      if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, "");
        if (this.webSocketVersion === 13) {
          response += "Origin: " + allowedOrigin + "\r\n";
        } else if (this.webSocketVersion === 8) {
          response += "Sec-WebSocket-Origin: " + allowedOrigin + "\r\n";
        }
      }
      if (cookies) {
        if (!Array.isArray(cookies)) {
          this.reject(500);
          throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
          if (!cookie.name || !cookie.value) {
            this.reject(500);
            throw new Error('Each cookie to set must at least provide a "name" and "value"');
          }
          cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, "");
          cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, "");
          if (seenCookies[cookie.name]) {
            this.reject(500);
            throw new Error("You may not specify the same cookie name twice.");
          }
          seenCookies[cookie.name] = true;
          var invalidChar = cookie.name.match(cookieNameValidateRegEx);
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie name");
          }
          if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
            invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
          } else {
            invalidChar = cookie.value.match(cookieValueValidateRegEx);
          }
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie value");
          }
          var cookieParts = [cookie.name + "=" + cookie.value];
          if (cookie.path) {
            invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie path");
            }
            cookieParts.push("Path=" + cookie.path);
          }
          if (cookie.domain) {
            if (typeof cookie.domain !== "string") {
              this.reject(500);
              throw new Error("Domain must be specified and must be a string.");
            }
            invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie domain");
            }
            cookieParts.push("Domain=" + cookie.domain.toLowerCase());
          }
          if (cookie.expires) {
            if (!(cookie.expires instanceof Date)) {
              this.reject(500);
              throw new Error('Value supplied for cookie "expires" must be a vaild date object');
            }
            cookieParts.push("Expires=" + cookie.expires.toGMTString());
          }
          if (cookie.maxage) {
            var maxage = cookie.maxage;
            if (typeof maxage === "string") {
              maxage = parseInt(maxage, 10);
            }
            if (isNaN(maxage) || maxage <= 0) {
              this.reject(500);
              throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
            }
            maxage = Math.round(maxage);
            cookieParts.push("Max-Age=" + maxage.toString(10));
          }
          if (cookie.secure) {
            if (typeof cookie.secure !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "secure" must be of type boolean');
            }
            cookieParts.push("Secure");
          }
          if (cookie.httponly) {
            if (typeof cookie.httponly !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "httponly" must be of type boolean');
            }
            cookieParts.push("HttpOnly");
          }
          response += "Set-Cookie: " + cookieParts.join(";") + "\r\n";
        }.bind(this));
      }
      this._resolved = true;
      this.emit("requestResolved", this);
      response += "\r\n";
      var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
      connection.webSocketVersion = this.webSocketVersion;
      connection.remoteAddress = this.remoteAddress;
      connection.remoteAddresses = this.remoteAddresses;
      var self2 = this;
      if (this._socketIsClosing) {
        cleanupFailedConnection(connection);
      } else {
        this.socket.write(response, "ascii", function(error2) {
          if (error2) {
            cleanupFailedConnection(connection);
            return;
          }
          self2._removeSocketCloseListeners();
          connection._addSocketEventListeners();
        });
      }
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
      this._verifyResolution();
      this._resolved = true;
      this.emit("requestResolved", this);
      if (typeof status !== "number") {
        status = 403;
      }
      var response = "HTTP/1.1 " + status + " " + httpStatusDescriptions[status] + "\r\nConnection: close\r\n";
      if (reason) {
        reason = reason.replace(headerSanitizeRegExp, "");
        response += "X-WebSocket-Reject-Reason: " + reason + "\r\n";
      }
      if (extraHeaders) {
        for (var key2 in extraHeaders) {
          var sanitizedValue = extraHeaders[key2].toString().replace(headerSanitizeRegExp, "");
          var sanitizedKey = key2.replace(headerSanitizeRegExp, "");
          response += sanitizedKey + ": " + sanitizedValue + "\r\n";
        }
      }
      response += "\r\n";
      this.socket.end(response, "ascii");
      this.emit("requestRejected", this);
    };
    WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
      this._socketIsClosing = true;
      this._removeSocketCloseListeners();
    };
    WebSocketRequest.prototype._removeSocketCloseListeners = function() {
      this.socket.removeListener("end", this._socketCloseHandler);
      this.socket.removeListener("close", this._socketCloseHandler);
    };
    WebSocketRequest.prototype._verifyResolution = function() {
      if (this._resolved) {
        throw new Error("WebSocketRequest may only be accepted or rejected one time.");
      }
    };
    function cleanupFailedConnection(connection) {
      process.nextTick(function() {
        connection.drop(1006, "TCP connection lost before handshake completed.", true);
      });
    }
    module2.exports = WebSocketRequest;
  }
});

// node_modules/websocket/lib/WebSocketServer.js
var require_WebSocketServer = __commonJS({
  "node_modules/websocket/lib/WebSocketServer.js"(exports, module2) {
    var extend = require_utils4().extend;
    var utils = require_utils4();
    var util = require("util");
    var debug = require_src2()("websocket:server");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketRequest = require_WebSocketRequest();
    var WebSocketServer = function WebSocketServer2(config) {
      EventEmitter.call(this);
      this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
      };
      this.connections = [];
      this.pendingRequests = [];
      if (config) {
        this.mount(config);
      }
    };
    util.inherits(WebSocketServer, EventEmitter);
    WebSocketServer.prototype.mount = function(config) {
      this.config = {
        httpServer: null,
        maxReceivedFrameSize: 65536,
        maxReceivedMessageSize: 1048576,
        fragmentOutgoingMessages: true,
        fragmentationThreshold: 16384,
        keepalive: true,
        keepaliveInterval: 2e4,
        dropConnectionOnKeepaliveTimeout: true,
        keepaliveGracePeriod: 1e4,
        useNativeKeepalive: false,
        assembleFragments: true,
        autoAcceptConnections: false,
        ignoreXForwardedFor: false,
        parseCookies: true,
        parseExtensions: true,
        disableNagleAlgorithm: true,
        closeTimeout: 5e3
      };
      extend(this.config, config);
      if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
          this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
          httpServer.on("upgrade", upgradeHandler);
        });
      } else {
        throw new Error("You must specify an httpServer on which to mount the WebSocket server.");
      }
    };
    WebSocketServer.prototype.unmount = function() {
      var upgradeHandler = this._handlers.upgrade;
      this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener("upgrade", upgradeHandler);
      });
    };
    WebSocketServer.prototype.closeAllConnections = function() {
      this.connections.forEach(function(connection) {
        connection.close();
      });
      this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503);
        });
      });
    };
    WebSocketServer.prototype.broadcast = function(data) {
      if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
      } else if (typeof data.toString === "function") {
        this.broadcastUTF(data);
      }
    };
    WebSocketServer.prototype.broadcastUTF = function(utfData) {
      this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
      });
    };
    WebSocketServer.prototype.broadcastBytes = function(binaryData) {
      this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
      });
    };
    WebSocketServer.prototype.shutDown = function() {
      this.unmount();
      this.closeAllConnections();
    };
    WebSocketServer.prototype.handleUpgrade = function(request, socket) {
      var self2 = this;
      var wsRequest = new WebSocketRequest(socket, request, this.config);
      try {
        wsRequest.readHandshake();
      } catch (e2) {
        wsRequest.reject(e2.httpCode ? e2.httpCode : 400, e2.message, e2.headers);
        debug("Invalid handshake: %s", e2.message);
        this.emit("upgradeError", e2);
        return;
      }
      this.pendingRequests.push(wsRequest);
      wsRequest.once("requestAccepted", this._handlers.requestAccepted);
      wsRequest.once("requestResolved", this._handlers.requestResolved);
      socket.once("close", function() {
        self2._handlers.requestResolved(wsRequest);
      });
      if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, "request") > 0) {
        this.emit("request", wsRequest);
      } else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
      } else {
        wsRequest.reject(404, "No handler is configured to accept the connection.");
      }
    };
    WebSocketServer.prototype.handleRequestAccepted = function(connection) {
      var self2 = this;
      connection.once("close", function(closeReason, description) {
        self2.handleConnectionClose(connection, closeReason, description);
      });
      this.connections.push(connection);
      this.emit("connect", connection);
    };
    WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
      var index = this.connections.indexOf(connection);
      if (index !== -1) {
        this.connections.splice(index, 1);
      }
      this.emit("close", connection, closeReason, description);
    };
    WebSocketServer.prototype.handleRequestResolved = function(request) {
      var index = this.pendingRequests.indexOf(request);
      if (index !== -1) {
        this.pendingRequests.splice(index, 1);
      }
    };
    module2.exports = WebSocketServer;
  }
});

// node_modules/websocket/lib/WebSocketClient.js
var require_WebSocketClient = __commonJS({
  "node_modules/websocket/lib/WebSocketClient.js"(exports, module2) {
    var utils = require_utils4();
    var extend = utils.extend;
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var http2 = require("http");
    var https2 = require("https");
    var url = require("url");
    var crypto2 = require("crypto");
    var WebSocketConnection = require_WebSocketConnection();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var protocolSeparators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var excludedTlsOptions = ["hostname", "port", "method", "path", "headers"];
    function WebSocketClient(config) {
      EventEmitter.call(this);
      this.config = {
        maxReceivedFrameSize: 1048576,
        maxReceivedMessageSize: 8388608,
        fragmentOutgoingMessages: true,
        fragmentationThreshold: 16384,
        webSocketVersion: 13,
        assembleFragments: true,
        disableNagleAlgorithm: true,
        closeTimeout: 5e3,
        tlsOptions: {}
      };
      if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        } else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
      }
      this._req = null;
      switch (this.config.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          throw new Error("Requested webSocketVersion is not supported. Allowed values are 8 and 13.");
      }
    }
    util.inherits(WebSocketClient, EventEmitter);
    WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
      var self2 = this;
      if (typeof protocols === "string") {
        if (protocols.length > 0) {
          protocols = [protocols];
        } else {
          protocols = [];
        }
      }
      if (!(protocols instanceof Array)) {
        protocols = [];
      }
      this.protocols = protocols;
      this.origin = origin;
      if (typeof requestUrl === "string") {
        this.url = url.parse(requestUrl);
      } else {
        this.url = requestUrl;
      }
      if (!this.url.protocol) {
        throw new Error("You must specify a full WebSocket URL, including protocol.");
      }
      if (!this.url.host) {
        throw new Error("You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.");
      }
      this.secure = this.url.protocol === "wss:";
      this.protocols.forEach(function(protocol) {
        for (var i3 = 0; i3 < protocol.length; i3++) {
          var charCode = protocol.charCodeAt(i3);
          var character = protocol.charAt(i3);
          if (charCode < 33 || charCode > 126 || protocolSeparators.indexOf(character) !== -1) {
            throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
          }
        }
      });
      var defaultPorts = {
        "ws:": "80",
        "wss:": "443"
      };
      if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
      }
      var nonce = bufferAllocUnsafe(16);
      for (var i2 = 0; i2 < 16; i2++) {
        nonce[i2] = Math.round(Math.random() * 255);
      }
      this.base64nonce = nonce.toString("base64");
      var hostHeaderValue = this.url.hostname;
      if (this.url.protocol === "ws:" && this.url.port !== "80" || this.url.protocol === "wss:" && this.url.port !== "443") {
        hostHeaderValue += ":" + this.url.port;
      }
      var reqHeaders = {};
      if (this.secure && this.config.tlsOptions.hasOwnProperty("headers")) {
        extend(reqHeaders, this.config.tlsOptions.headers);
      }
      if (headers) {
        extend(reqHeaders, headers);
      }
      extend(reqHeaders, {
        "Upgrade": "websocket",
        "Connection": "Upgrade",
        "Sec-WebSocket-Version": this.config.webSocketVersion.toString(10),
        "Sec-WebSocket-Key": this.base64nonce,
        "Host": reqHeaders.Host || hostHeaderValue
      });
      if (this.protocols.length > 0) {
        reqHeaders["Sec-WebSocket-Protocol"] = this.protocols.join(", ");
      }
      if (this.origin) {
        if (this.config.webSocketVersion === 13) {
          reqHeaders["Origin"] = this.origin;
        } else if (this.config.webSocketVersion === 8) {
          reqHeaders["Sec-WebSocket-Origin"] = this.origin;
        }
      }
      var pathAndQuery;
      if (this.url.pathname) {
        pathAndQuery = this.url.path;
      } else if (this.url.path) {
        pathAndQuery = "/" + this.url.path;
      } else {
        pathAndQuery = "/";
      }
      function handleRequestError(error2) {
        self2._req = null;
        self2.emit("connectFailed", error2);
      }
      var requestOptions = {
        agent: false
      };
      if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
      }
      extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: "GET",
        path: pathAndQuery,
        headers: reqHeaders
      });
      if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key2 in tlsOptions) {
          if (tlsOptions.hasOwnProperty(key2) && excludedTlsOptions.indexOf(key2) === -1) {
            requestOptions[key2] = tlsOptions[key2];
          }
        }
      }
      var req = this._req = (this.secure ? https2 : http2).request(requestOptions);
      req.on("upgrade", function handleRequestUpgrade(response, socket, head) {
        self2._req = null;
        req.removeListener("error", handleRequestError);
        self2.socket = socket;
        self2.response = response;
        self2.firstDataChunk = head;
        self2.validateHandshake();
      });
      req.on("error", handleRequestError);
      req.on("response", function(response) {
        self2._req = null;
        if (utils.eventEmitterListenerCount(self2, "httpResponse") > 0) {
          self2.emit("httpResponse", response, self2);
          if (response.socket) {
            response.socket.end();
          }
        } else {
          var headerDumpParts = [];
          for (var headerName in response.headers) {
            headerDumpParts.push(headerName + ": " + response.headers[headerName]);
          }
          self2.failHandshake("Server responded with a non-101 status: " + response.statusCode + " " + response.statusMessage + "\nResponse Headers Follow:\n" + headerDumpParts.join("\n") + "\n");
        }
      });
      req.end();
    };
    WebSocketClient.prototype.validateHandshake = function() {
      var headers = this.response.headers;
      if (this.protocols.length > 0) {
        this.protocol = headers["sec-websocket-protocol"];
        if (this.protocol) {
          if (this.protocols.indexOf(this.protocol) === -1) {
            this.failHandshake("Server did not respond with a requested protocol.");
            return;
          }
        } else {
          this.failHandshake("Expected a Sec-WebSocket-Protocol header.");
          return;
        }
      }
      if (!(headers["connection"] && headers["connection"].toLocaleLowerCase() === "upgrade")) {
        this.failHandshake("Expected a Connection: Upgrade header from the server");
        return;
      }
      if (!(headers["upgrade"] && headers["upgrade"].toLocaleLowerCase() === "websocket")) {
        this.failHandshake("Expected an Upgrade: websocket header from the server");
        return;
      }
      var sha1 = crypto2.createHash("sha1");
      sha1.update(this.base64nonce + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var expectedKey = sha1.digest("base64");
      if (!headers["sec-websocket-accept"]) {
        this.failHandshake("Expected Sec-WebSocket-Accept header from server");
        return;
      }
      if (headers["sec-websocket-accept"] !== expectedKey) {
        this.failHandshake("Sec-WebSocket-Accept header from server didn't match expected value of " + expectedKey);
        return;
      }
      this.succeedHandshake();
    };
    WebSocketClient.prototype.failHandshake = function(errorDescription) {
      if (this.socket && this.socket.writable) {
        this.socket.end();
      }
      this.emit("connectFailed", new Error(errorDescription));
    };
    WebSocketClient.prototype.succeedHandshake = function() {
      var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);
      connection.webSocketVersion = this.config.webSocketVersion;
      connection._addSocketEventListeners();
      this.emit("connect", connection);
      if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
      }
      this.firstDataChunk = null;
    };
    WebSocketClient.prototype.abort = function() {
      if (this._req) {
        this._req.abort();
      }
    };
    module2.exports = WebSocketClient;
  }
});

// node_modules/websocket/lib/WebSocketRouterRequest.js
var require_WebSocketRouterRequest = __commonJS({
  "node_modules/websocket/lib/WebSocketRouterRequest.js"(exports, module2) {
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
      EventEmitter.call(this);
      this.webSocketRequest = webSocketRequest;
      if (resolvedProtocol === "____no_protocol____") {
        this.protocol = null;
      } else {
        this.protocol = resolvedProtocol;
      }
      this.origin = webSocketRequest.origin;
      this.resource = webSocketRequest.resource;
      this.resourceURL = webSocketRequest.resourceURL;
      this.httpRequest = webSocketRequest.httpRequest;
      this.remoteAddress = webSocketRequest.remoteAddress;
      this.webSocketVersion = webSocketRequest.webSocketVersion;
      this.requestedExtensions = webSocketRequest.requestedExtensions;
      this.cookies = webSocketRequest.cookies;
    }
    util.inherits(WebSocketRouterRequest, EventEmitter);
    WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
      var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
      this.webSocketRequest.reject(status, reason, extraHeaders);
      this.emit("requestRejected", this);
    };
    module2.exports = WebSocketRouterRequest;
  }
});

// node_modules/websocket/lib/WebSocketRouter.js
var require_WebSocketRouter = __commonJS({
  "node_modules/websocket/lib/WebSocketRouter.js"(exports, module2) {
    var extend = require_utils4().extend;
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketRouterRequest = require_WebSocketRouterRequest();
    function WebSocketRouter(config) {
      EventEmitter.call(this);
      this.config = {
        server: null
      };
      if (config) {
        extend(this.config, config);
      }
      this.handlers = [];
      this._requestHandler = this.handleRequest.bind(this);
      if (this.config.server) {
        this.attachServer(this.config.server);
      }
    }
    util.inherits(WebSocketRouter, EventEmitter);
    WebSocketRouter.prototype.attachServer = function(server2) {
      if (server2) {
        this.server = server2;
        this.server.on("request", this._requestHandler);
      } else {
        throw new Error("You must specify a WebSocketServer instance to attach to.");
      }
    };
    WebSocketRouter.prototype.detachServer = function() {
      if (this.server) {
        this.server.removeListener("request", this._requestHandler);
        this.server = null;
      } else {
        throw new Error("Cannot detach from server: not attached.");
      }
    };
    WebSocketRouter.prototype.mount = function(path, protocol, callback) {
      if (!path) {
        throw new Error("You must specify a path for this handler.");
      }
      if (!protocol) {
        protocol = "____no_protocol____";
      }
      if (!callback) {
        throw new Error("You must specify a callback for this handler.");
      }
      path = this.pathToRegExp(path);
      if (!(path instanceof RegExp)) {
        throw new Error("Path must be specified as either a string or a RegExp.");
      }
      var pathString = path.toString();
      protocol = protocol.toLocaleLowerCase();
      if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error("You may only mount one handler per path/protocol combination.");
      }
      this.handlers.push({
        "path": path,
        "pathString": pathString,
        "protocol": protocol,
        "callback": callback
      });
    };
    WebSocketRouter.prototype.unmount = function(path, protocol) {
      var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);
      if (index !== -1) {
        this.handlers.splice(index, 1);
      } else {
        throw new Error("Unable to find a route matching the specified path and protocol.");
      }
    };
    WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
      protocol = protocol.toLocaleLowerCase();
      for (var i2 = 0, len = this.handlers.length; i2 < len; i2++) {
        var handler = this.handlers[i2];
        if (handler.pathString === pathString && handler.protocol === protocol) {
          return i2;
        }
      }
      return -1;
    };
    WebSocketRouter.prototype.pathToRegExp = function(path) {
      if (typeof path === "string") {
        if (path === "*") {
          path = /^.*$/;
        } else {
          path = path.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          path = new RegExp("^" + path + "$");
        }
      }
      return path;
    };
    WebSocketRouter.prototype.handleRequest = function(request) {
      var requestedProtocols = request.requestedProtocols;
      if (requestedProtocols.length === 0) {
        requestedProtocols = ["____no_protocol____"];
      }
      for (var i2 = 0; i2 < requestedProtocols.length; i2++) {
        var requestedProtocol = requestedProtocols[i2].toLocaleLowerCase();
        for (var j = 0, len = this.handlers.length; j < len; j++) {
          var handler = this.handlers[j];
          if (handler.path.test(request.resourceURL.pathname)) {
            if (requestedProtocol === handler.protocol || handler.protocol === "*") {
              var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
              handler.callback(routerRequest);
              return;
            }
          }
        }
      }
      request.reject(404, "No handler is available for the given request.");
    };
    module2.exports = WebSocketRouter;
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module2) {
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module2) {
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/yaeti/lib/EventTarget.js
var require_EventTarget = __commonJS({
  "node_modules/yaeti/lib/EventTarget.js"(exports, module2) {
    module2.exports = _EventTarget;
    function _EventTarget() {
      if (typeof this.addEventListener === "function") {
        return;
      }
      this._listeners = {};
      this.addEventListener = _addEventListener;
      this.removeEventListener = _removeEventListener;
      this.dispatchEvent = _dispatchEvent;
    }
    Object.defineProperties(_EventTarget.prototype, {
      listeners: {
        get: function() {
          return this._listeners;
        }
      }
    });
    function _addEventListener(type, newListener) {
      var listenersType, i2, listener;
      if (!type || !newListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        this._listeners[type] = listenersType = [];
      }
      for (i2 = 0; !!(listener = listenersType[i2]); i2++) {
        if (listener === newListener) {
          return;
        }
      }
      listenersType.push(newListener);
    }
    function _removeEventListener(type, oldListener) {
      var listenersType, i2, listener;
      if (!type || !oldListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        return;
      }
      for (i2 = 0; !!(listener = listenersType[i2]); i2++) {
        if (listener === oldListener) {
          listenersType.splice(i2, 1);
          break;
        }
      }
      if (listenersType.length === 0) {
        delete this._listeners[type];
      }
    }
    function _dispatchEvent(event) {
      var type, listenersType, dummyListener, stopImmediatePropagation = false, i2, listener;
      if (!event || typeof event.type !== "string") {
        throw new Error("`event` must have a valid `type` property");
      }
      if (event._yaeti) {
        event.target = this;
        event.cancelable = true;
      }
      try {
        event.stopImmediatePropagation = function() {
          stopImmediatePropagation = true;
        };
      } catch (error2) {
      }
      type = event.type;
      listenersType = this._listeners[type] || [];
      dummyListener = this["on" + type];
      if (typeof dummyListener === "function") {
        dummyListener.call(this, event);
      }
      for (i2 = 0; !!(listener = listenersType[i2]); i2++) {
        if (stopImmediatePropagation) {
          break;
        }
        listener.call(this, event);
      }
      return !event.defaultPrevented;
    }
  }
});

// node_modules/yaeti/lib/Event.js
var require_Event = __commonJS({
  "node_modules/yaeti/lib/Event.js"(exports, module2) {
    module2.exports = _Event;
    function _Event(type) {
      this.type = type;
      this.isTrusted = false;
      this._yaeti = true;
    }
  }
});

// node_modules/yaeti/index.js
var require_yaeti = __commonJS({
  "node_modules/yaeti/index.js"(exports, module2) {
    module2.exports = {
      EventTarget: require_EventTarget(),
      Event: require_Event()
    };
  }
});

// node_modules/websocket/lib/W3CWebSocket.js
var require_W3CWebSocket = __commonJS({
  "node_modules/websocket/lib/W3CWebSocket.js"(exports, module2) {
    var WebSocketClient = require_WebSocketClient();
    var toBuffer = require_typedarray_to_buffer();
    var yaeti = require_yaeti();
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSING = 2;
    var CLOSED = 3;
    module2.exports = W3CWebSocket;
    function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
      yaeti.EventTarget.call(this);
      clientConfig = clientConfig || {};
      clientConfig.assembleFragments = true;
      var self2 = this;
      this._url = url;
      this._readyState = CONNECTING;
      this._protocol = void 0;
      this._extensions = "";
      this._bufferedAmount = 0;
      this._binaryType = "arraybuffer";
      this._connection = void 0;
      this._client = new WebSocketClient(clientConfig);
      this._client.on("connect", function(connection) {
        onConnect.call(self2, connection);
      });
      this._client.on("connectFailed", function() {
        onConnectFailed.call(self2);
      });
      this._client.connect(url, protocols, origin, headers, requestOptions);
    }
    Object.defineProperties(W3CWebSocket.prototype, {
      url: { get: function() {
        return this._url;
      } },
      readyState: { get: function() {
        return this._readyState;
      } },
      protocol: { get: function() {
        return this._protocol;
      } },
      extensions: { get: function() {
        return this._extensions;
      } },
      bufferedAmount: { get: function() {
        return this._bufferedAmount;
      } }
    });
    Object.defineProperties(W3CWebSocket.prototype, {
      binaryType: {
        get: function() {
          return this._binaryType;
        },
        set: function(type) {
          if (type !== "arraybuffer") {
            throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
          }
          this._binaryType = type;
        }
      }
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    W3CWebSocket.prototype.send = function(data) {
      if (this._readyState !== OPEN) {
        throw new Error("cannot call send() while not connected");
      }
      if (typeof data === "string" || data instanceof String) {
        this._connection.sendUTF(data);
      } else {
        if (data instanceof Buffer) {
          this._connection.sendBytes(data);
        } else if (data.byteLength || data.byteLength === 0) {
          data = toBuffer(data);
          this._connection.sendBytes(data);
        } else {
          throw new Error("unknown binary data:", data);
        }
      }
    };
    W3CWebSocket.prototype.close = function(code, reason) {
      switch (this._readyState) {
        case CONNECTING:
          onConnectFailed.call(this);
          this._client.on("connect", function(connection) {
            if (code) {
              connection.close(code, reason);
            } else {
              connection.close();
            }
          });
          break;
        case OPEN:
          this._readyState = CLOSING;
          if (code) {
            this._connection.close(code, reason);
          } else {
            this._connection.close();
          }
          break;
        case CLOSING:
        case CLOSED:
          break;
      }
    };
    function createCloseEvent(code, reason) {
      var event = new yaeti.Event("close");
      event.code = code;
      event.reason = reason;
      event.wasClean = typeof code === "undefined" || code === 1e3;
      return event;
    }
    function createMessageEvent(data) {
      var event = new yaeti.Event("message");
      event.data = data;
      return event;
    }
    function onConnect(connection) {
      var self2 = this;
      this._readyState = OPEN;
      this._connection = connection;
      this._protocol = connection.protocol;
      this._extensions = connection.extensions;
      this._connection.on("close", function(code, reason) {
        onClose.call(self2, code, reason);
      });
      this._connection.on("message", function(msg) {
        onMessage.call(self2, msg);
      });
      this.dispatchEvent(new yaeti.Event("open"));
    }
    function onConnectFailed() {
      destroy.call(this);
      this._readyState = CLOSED;
      try {
        this.dispatchEvent(new yaeti.Event("error"));
      } finally {
        this.dispatchEvent(createCloseEvent(1006, "connection failed"));
      }
    }
    function onClose(code, reason) {
      destroy.call(this);
      this._readyState = CLOSED;
      this.dispatchEvent(createCloseEvent(code, reason || ""));
    }
    function onMessage(message) {
      if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
      } else if (message.binaryData) {
        if (this.binaryType === "arraybuffer") {
          var buffer = message.binaryData;
          var arraybuffer = new ArrayBuffer(buffer.length);
          var view = new Uint8Array(arraybuffer);
          for (var i2 = 0, len = buffer.length; i2 < len; ++i2) {
            view[i2] = buffer[i2];
          }
          this.dispatchEvent(createMessageEvent(arraybuffer));
        }
      }
    }
    function destroy() {
      this._client.removeAllListeners();
      if (this._connection) {
        this._connection.removeAllListeners();
      }
    }
  }
});

// node_modules/websocket/lib/Deprecation.js
var require_Deprecation = __commonJS({
  "node_modules/websocket/lib/Deprecation.js"(exports, module2) {
    var Deprecation = {
      disableWarnings: false,
      deprecationWarningMap: {},
      warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
          console.warn("DEPRECATION WARNING: " + this.deprecationWarningMap[deprecationName]);
          this.deprecationWarningMap[deprecationName] = false;
        }
      }
    };
    module2.exports = Deprecation;
  }
});

// node_modules/websocket/package.json
var require_package = __commonJS({
  "node_modules/websocket/package.json"(exports, module2) {
    module2.exports = {
      _args: [
        [
          "websocket@1.0.34",
          "/Users/bhekani.khumalo/dev/personal/pro-search"
        ]
      ],
      _development: true,
      _from: "websocket@1.0.34",
      _id: "websocket@1.0.34",
      _inBundle: false,
      _integrity: "sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==",
      _location: "/websocket",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: true,
        raw: "websocket@1.0.34",
        name: "websocket",
        escapedName: "websocket",
        rawSpec: "1.0.34",
        saveSpec: null,
        fetchSpec: "1.0.34"
      },
      _requiredBy: [
        "/@supabase/realtime-js"
      ],
      _resolved: "https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz",
      _spec: "1.0.34",
      _where: "/Users/bhekani.khumalo/dev/personal/pro-search",
      author: {
        name: "Brian McKelvey",
        email: "theturtle32@gmail.com",
        url: "https://github.com/theturtle32"
      },
      browser: "lib/browser.js",
      bugs: {
        url: "https://github.com/theturtle32/WebSocket-Node/issues"
      },
      config: {
        verbose: false
      },
      contributors: [
        {
          name: "I\xF1aki Baz Castillo",
          email: "ibc@aliax.net",
          url: "http://dev.sipdoc.net"
        }
      ],
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.50",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        jshint: "^2.0.0",
        "jshint-stylish": "^2.2.1",
        tape: "^4.9.1"
      },
      directories: {
        lib: "./lib"
      },
      engines: {
        node: ">=4.0.0"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      license: "Apache-2.0",
      main: "index",
      name: "websocket",
      repository: {
        type: "git",
        url: "git+https://github.com/theturtle32/WebSocket-Node.git"
      },
      scripts: {
        gulp: "gulp",
        test: "tape test/unit/*.js"
      },
      version: "1.0.34"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version5 = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module2) {
    module2.exports = require_package().version;
  }
});

// node_modules/websocket/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/websocket/lib/websocket.js"(exports, module2) {
    module2.exports = {
      "server": require_WebSocketServer(),
      "client": require_WebSocketClient(),
      "router": require_WebSocketRouter(),
      "frame": require_WebSocketFrame(),
      "request": require_WebSocketRequest(),
      "connection": require_WebSocketConnection(),
      "w3cwebsocket": require_W3CWebSocket(),
      "deprecation": require_Deprecation(),
      "version": require_version5()
    };
  }
});

// node_modules/websocket/index.js
var require_websocket2 = __commonJS({
  "node_modules/websocket/index.js"(exports, module2) {
    module2.exports = require_websocket();
  }
});

// node_modules/@supabase/realtime-js/dist/main/lib/serializer.js
var require_serializer = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/lib/serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Serializer = class {
      constructor() {
        this.HEADER_LENGTH = 1;
      }
      decode(rawPayload, callback) {
        if (rawPayload.constructor === ArrayBuffer) {
          return callback(this._binaryDecode(rawPayload));
        }
        if (typeof rawPayload === "string") {
          return callback(JSON.parse(rawPayload));
        }
        return callback({});
      }
      _binaryDecode(buffer) {
        const view = new DataView(buffer);
        const decoder = new TextDecoder();
        return this._decodeBroadcast(buffer, view, decoder);
      }
      _decodeBroadcast(buffer, view, decoder) {
        const topicSize = view.getUint8(1);
        const eventSize = view.getUint8(2);
        let offset = this.HEADER_LENGTH + 2;
        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        const event = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
        return { ref: null, topic, event, payload: data };
      }
    };
    exports.default = Serializer;
  }
});

// node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js
var require_RealtimeClient = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants7();
    var timer_1 = __importDefault(require_timer2());
    var RealtimeSubscription_1 = __importDefault(require_RealtimeSubscription());
    var websocket_1 = require_websocket2();
    var serializer_1 = __importDefault(require_serializer());
    var noop4 = () => {
    };
    var RealtimeClient = class {
      constructor(endPoint, options) {
        this.accessToken = null;
        this.channels = [];
        this.endPoint = "";
        this.headers = constants_1.DEFAULT_HEADERS;
        this.params = {};
        this.timeout = constants_1.DEFAULT_TIMEOUT;
        this.transport = websocket_1.w3cwebsocket;
        this.heartbeatIntervalMs = 3e4;
        this.longpollerTimeout = 2e4;
        this.heartbeatTimer = void 0;
        this.pendingHeartbeatRef = null;
        this.ref = 0;
        this.logger = noop4;
        this.conn = null;
        this.sendBuffer = [];
        this.serializer = new serializer_1.default();
        this.stateChangeCallbacks = {
          open: [],
          close: [],
          error: [],
          message: []
        };
        this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;
        if (options === null || options === void 0 ? void 0 : options.params)
          this.params = options.params;
        if (options === null || options === void 0 ? void 0 : options.headers)
          this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
        if (options === null || options === void 0 ? void 0 : options.timeout)
          this.timeout = options.timeout;
        if (options === null || options === void 0 ? void 0 : options.logger)
          this.logger = options.logger;
        if (options === null || options === void 0 ? void 0 : options.transport)
          this.transport = options.transport;
        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
          this.heartbeatIntervalMs = options.heartbeatIntervalMs;
        if (options === null || options === void 0 ? void 0 : options.longpollerTimeout)
          this.longpollerTimeout = options.longpollerTimeout;
        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {
          return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;
        };
        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
          return callback(JSON.stringify(payload));
        };
        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
        this.reconnectTimer = new timer_1.default(() => __awaiter(this, void 0, void 0, function* () {
          yield this.disconnect();
          this.connect();
        }), this.reconnectAfterMs);
      }
      connect() {
        if (this.conn) {
          return;
        }
        this.conn = new this.transport(this.endPointURL(), [], null, this.headers);
        if (this.conn) {
          this.conn.binaryType = "arraybuffer";
          this.conn.onopen = () => this._onConnOpen();
          this.conn.onerror = (error2) => this._onConnError(error2);
          this.conn.onmessage = (event) => this.onConnMessage(event);
          this.conn.onclose = (event) => this._onConnClose(event);
        }
      }
      disconnect(code, reason) {
        return new Promise((resolve2, _reject) => {
          try {
            if (this.conn) {
              this.conn.onclose = function() {
              };
              if (code) {
                this.conn.close(code, reason || "");
              } else {
                this.conn.close();
              }
              this.conn = null;
              this.heartbeatTimer && clearInterval(this.heartbeatTimer);
              this.reconnectTimer.reset();
            }
            resolve2({ error: null, data: true });
          } catch (error2) {
            resolve2({ error: error2, data: false });
          }
        });
      }
      log(kind, msg, data) {
        this.logger(kind, msg, data);
      }
      onOpen(callback) {
        this.stateChangeCallbacks.open.push(callback);
      }
      onClose(callback) {
        this.stateChangeCallbacks.close.push(callback);
      }
      onError(callback) {
        this.stateChangeCallbacks.error.push(callback);
      }
      onMessage(callback) {
        this.stateChangeCallbacks.message.push(callback);
      }
      connectionState() {
        switch (this.conn && this.conn.readyState) {
          case constants_1.SOCKET_STATES.connecting:
            return "connecting";
          case constants_1.SOCKET_STATES.open:
            return "open";
          case constants_1.SOCKET_STATES.closing:
            return "closing";
          default:
            return "closed";
        }
      }
      isConnected() {
        return this.connectionState() === "open";
      }
      remove(channel) {
        this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
      }
      channel(topic, chanParams = {}) {
        let chan = new RealtimeSubscription_1.default(topic, chanParams, this);
        this.channels.push(chan);
        return chan;
      }
      push(data) {
        let { topic, event, payload, ref } = data;
        let callback = () => {
          this.encode(data, (result) => {
            var _a4;
            (_a4 = this.conn) === null || _a4 === void 0 ? void 0 : _a4.send(result);
          });
        };
        this.log("push", `${topic} ${event} (${ref})`, payload);
        if (this.isConnected()) {
          callback();
        } else {
          this.sendBuffer.push(callback);
        }
      }
      onConnMessage(rawMessage) {
        this.decode(rawMessage.data, (msg) => {
          let { topic, event, payload, ref } = msg;
          if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {
            this.pendingHeartbeatRef = null;
          }
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
          this.channels.filter((channel) => channel.isMember(topic)).forEach((channel) => channel.trigger(event, payload, ref));
          this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
        });
      }
      endPointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: constants_1.VSN }));
      }
      makeRef() {
        let newRef = this.ref + 1;
        if (newRef === this.ref) {
          this.ref = 0;
        } else {
          this.ref = newRef;
        }
        return this.ref.toString();
      }
      setAuth(token) {
        this.accessToken = token;
        try {
          this.channels.forEach((channel) => {
            token && channel.updateJoinPayload({ user_token: token });
            if (channel.joinedOnce && channel.isJoined()) {
              channel.push(constants_1.CHANNEL_EVENTS.access_token, { access_token: token });
            }
          });
        } catch (error2) {
          console.log("setAuth error", error2);
        }
      }
      leaveOpenTopic(topic) {
        let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
        if (dupChannel) {
          this.log("transport", `leaving duplicate topic "${topic}"`);
          dupChannel.unsubscribe();
        }
      }
      _onConnOpen() {
        this.log("transport", `connected to ${this.endPointURL()}`);
        this._flushSendBuffer();
        this.reconnectTimer.reset();
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);
        this.stateChangeCallbacks.open.forEach((callback) => callback());
      }
      _onConnClose(event) {
        this.log("transport", "close", event);
        this._triggerChanError();
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.reconnectTimer.scheduleTimeout();
        this.stateChangeCallbacks.close.forEach((callback) => callback(event));
      }
      _onConnError(error2) {
        this.log("transport", error2.message);
        this._triggerChanError();
        this.stateChangeCallbacks.error.forEach((callback) => callback(error2));
      }
      _triggerChanError() {
        this.channels.forEach((channel) => channel.trigger(constants_1.CHANNEL_EVENTS.error));
      }
      _appendParams(url, params) {
        if (Object.keys(params).length === 0) {
          return url;
        }
        const prefix = url.match(/\?/) ? "&" : "?";
        const query = new URLSearchParams(params);
        return `${url}${prefix}${query}`;
      }
      _flushSendBuffer() {
        if (this.isConnected() && this.sendBuffer.length > 0) {
          this.sendBuffer.forEach((callback) => callback());
          this.sendBuffer = [];
        }
      }
      _sendHeartbeat() {
        var _a4;
        if (!this.isConnected()) {
          return;
        }
        if (this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null;
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          (_a4 = this.conn) === null || _a4 === void 0 ? void 0 : _a4.close(constants_1.WS_CLOSE_NORMAL, "hearbeat timeout");
          return;
        }
        this.pendingHeartbeatRef = this.makeRef();
        this.push({
          topic: "phoenix",
          event: "heartbeat",
          payload: {},
          ref: this.pendingHeartbeatRef
        });
        this.setAuth(this.accessToken);
      }
    };
    exports.default = RealtimeClient;
  }
});

// node_modules/@supabase/realtime-js/dist/main/index.js
var require_main3 = __commonJS({
  "node_modules/@supabase/realtime-js/dist/main/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transformers = exports.RealtimeSubscription = exports.RealtimeClient = void 0;
    var Transformers = __importStar(require_transformers());
    exports.Transformers = Transformers;
    var RealtimeClient_1 = __importDefault(require_RealtimeClient());
    exports.RealtimeClient = RealtimeClient_1.default;
    var RealtimeSubscription_1 = __importDefault(require_RealtimeSubscription());
    exports.RealtimeSubscription = RealtimeSubscription_1.default;
  }
});

// node_modules/@supabase/supabase-js/dist/main/lib/SupabaseRealtimeClient.js
var require_SupabaseRealtimeClient = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/lib/SupabaseRealtimeClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupabaseRealtimeClient = void 0;
    var realtime_js_1 = require_main3();
    var SupabaseRealtimeClient = class {
      constructor(socket, headers, schema, tableName) {
        const chanParams = {};
        const topic = tableName === "*" ? `realtime:${schema}` : `realtime:${schema}:${tableName}`;
        const userToken = headers["Authorization"].split(" ")[1];
        if (userToken) {
          chanParams["user_token"] = userToken;
        }
        this.subscription = socket.channel(topic, chanParams);
      }
      getPayloadRecords(payload) {
        const records = {
          new: {},
          old: {}
        };
        if (payload.type === "INSERT" || payload.type === "UPDATE") {
          records.new = realtime_js_1.Transformers.convertChangeData(payload.columns, payload.record);
        }
        if (payload.type === "UPDATE" || payload.type === "DELETE") {
          records.old = realtime_js_1.Transformers.convertChangeData(payload.columns, payload.old_record);
        }
        return records;
      }
      on(event, callback) {
        this.subscription.on(event, (payload) => {
          let enrichedPayload = {
            schema: payload.schema,
            table: payload.table,
            commit_timestamp: payload.commit_timestamp,
            eventType: payload.type,
            new: {},
            old: {},
            errors: payload.errors
          };
          enrichedPayload = Object.assign(Object.assign({}, enrichedPayload), this.getPayloadRecords(payload));
          callback(enrichedPayload);
        });
        return this;
      }
      subscribe(callback = () => {
      }) {
        this.subscription.onError((e2) => callback("SUBSCRIPTION_ERROR", e2));
        this.subscription.onClose(() => callback("CLOSED"));
        this.subscription.subscribe().receive("ok", () => callback("SUBSCRIBED")).receive("error", (e2) => callback("SUBSCRIPTION_ERROR", e2)).receive("timeout", () => callback("RETRYING_AFTER_TIMEOUT"));
        return this.subscription;
      }
    };
    exports.SupabaseRealtimeClient = SupabaseRealtimeClient;
  }
});

// node_modules/@supabase/supabase-js/dist/main/lib/SupabaseQueryBuilder.js
var require_SupabaseQueryBuilder = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/lib/SupabaseQueryBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupabaseQueryBuilder = void 0;
    var postgrest_js_1 = require_main2();
    var SupabaseRealtimeClient_1 = require_SupabaseRealtimeClient();
    var SupabaseQueryBuilder = class extends postgrest_js_1.PostgrestQueryBuilder {
      constructor(url, { headers = {}, schema, realtime, table, fetch: fetch3 }) {
        super(url, { headers, schema, fetch: fetch3 });
        this._subscription = null;
        this._realtime = realtime;
        this._headers = headers;
        this._schema = schema;
        this._table = table;
      }
      on(event, callback) {
        if (!this._realtime.isConnected()) {
          this._realtime.connect();
        }
        if (!this._subscription) {
          this._subscription = new SupabaseRealtimeClient_1.SupabaseRealtimeClient(this._realtime, this._headers, this._schema, this._table);
        }
        return this._subscription.on(event, callback);
      }
    };
    exports.SupabaseQueryBuilder = SupabaseQueryBuilder;
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/version.js
var require_version6 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.0.0";
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/constants.js
var require_constants8 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version6();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `storage-js/${version_1.version}` };
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/fetch.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.remove = exports.put = exports.post = exports.get = void 0;
    var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
    var handleError = (error2, reject) => {
      if (typeof error2.json !== "function") {
        return reject(error2);
      }
      error2.json().then((err) => {
        return reject({
          message: _getErrorMessage(err),
          status: (error2 === null || error2 === void 0 ? void 0 : error2.status) || 500
        });
      });
    };
    var _getRequestParams = (method, options, parameters, body) => {
      const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
      if (method === "GET") {
        return params;
      }
      params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
      params.body = JSON.stringify(body);
      return Object.assign(Object.assign({}, params), parameters);
    };
    function _handleRequest(fetcher, method, url, options, parameters, body) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve2, reject) => {
          fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
            if (!result.ok)
              throw result;
            if (options === null || options === void 0 ? void 0 : options.noResolveJson)
              return resolve2(result);
            return result.json();
          }).then((data) => resolve2(data)).catch((error2) => handleError(error2, reject));
        });
      });
    }
    function get2(fetcher, url, options, parameters) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "GET", url, options, parameters);
      });
    }
    exports.get = get2;
    function post(fetcher, url, body, options, parameters) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "POST", url, options, parameters, body);
      });
    }
    exports.post = post;
    function put(fetcher, url, body, options, parameters) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "PUT", url, options, parameters, body);
      });
    }
    exports.put = put;
    function remove(fetcher, url, body, options, parameters) {
      return __awaiter(this, void 0, void 0, function* () {
        return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
      });
    }
    exports.remove = remove;
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/helpers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveFetch = void 0;
    var cross_fetch_1 = __importDefault(require_node_ponyfill());
    exports.resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = cross_fetch_1.default;
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/StorageBucketApi.js
var require_StorageBucketApi = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/StorageBucketApi.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBucketApi = void 0;
    var constants_1 = require_constants8();
    var fetch_1 = require_fetch2();
    var helpers_1 = require_helpers3();
    var StorageBucketApi = class {
      constructor(url, headers = {}, fetch3) {
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.fetch = helpers_1.resolveFetch(fetch3);
      }
      listBuckets() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      getBucket(id) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      createBucket(id, options = { public: false }) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.post(this.fetch, `${this.url}/bucket`, { id, name: id, public: options.public }, { headers: this.headers });
            return { data: data.name, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      updateBucket(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.put(this.fetch, `${this.url}/bucket/${id}`, { id, name: id, public: options.public }, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      emptyBucket(id) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      deleteBucket(id) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
    };
    exports.StorageBucketApi = StorageBucketApi;
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/StorageFileApi.js
var require_StorageFileApi = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/StorageFileApi.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageFileApi = void 0;
    var fetch_1 = require_fetch2();
    var helpers_1 = require_helpers3();
    var DEFAULT_SEARCH_OPTIONS = {
      limit: 100,
      offset: 0,
      sortBy: {
        column: "name",
        order: "asc"
      }
    };
    var DEFAULT_FILE_OPTIONS = {
      cacheControl: "3600",
      contentType: "text/plain;charset=UTF-8",
      upsert: false
    };
    var StorageFileApi = class {
      constructor(url, headers = {}, bucketId, fetch3) {
        this.url = url;
        this.headers = headers;
        this.bucketId = bucketId;
        this.fetch = helpers_1.resolveFetch(fetch3);
      }
      uploadOrUpdate(method, path, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let body;
            const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
            const headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
            if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
              body = new FormData();
              body.append("cacheControl", options.cacheControl);
              body.append("", fileBody);
            } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
              body = fileBody;
              body.append("cacheControl", options.cacheControl);
            } else {
              body = fileBody;
              headers["cache-control"] = `max-age=${options.cacheControl}`;
              headers["content-type"] = options.contentType;
            }
            const cleanPath = this._removeEmptyFolders(path);
            const _path = this._getFinalPath(cleanPath);
            const res = yield this.fetch(`${this.url}/object/${_path}`, {
              method,
              body,
              headers
            });
            if (res.ok) {
              return { data: { Key: _path }, error: null };
            } else {
              const error2 = yield res.json();
              return { data: null, error: error2 };
            }
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      upload(path, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
        });
      }
      update(path, fileBody, fileOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
        });
      }
      move(fromPath, toPath) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.post(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      copy(fromPath, toPath) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.post(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      createSignedUrl(path, expiresIn) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const _path = this._getFinalPath(path);
            let data = yield fetch_1.post(this.fetch, `${this.url}/object/sign/${_path}`, { expiresIn }, { headers: this.headers });
            const signedURL = `${this.url}${data.signedURL}`;
            data = { signedURL };
            return { data, error: null, signedURL };
          } catch (error2) {
            return { data: null, error: error2, signedURL: null };
          }
        });
      }
      createSignedUrls(paths, expiresIn) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
            return {
              data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedURL: datum.signedURL ? `${this.url}${datum.signedURL}` : null })),
              error: null
            };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      download(path) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const _path = this._getFinalPath(path);
            const res = yield fetch_1.get(this.fetch, `${this.url}/object/${_path}`, {
              headers: this.headers,
              noResolveJson: true
            });
            const data = yield res.blob();
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      getPublicUrl(path) {
        try {
          const _path = this._getFinalPath(path);
          const publicURL = `${this.url}/object/public/${_path}`;
          const data = { publicURL };
          return { data, error: null, publicURL };
        } catch (error2) {
          return { data: null, error: error2, publicURL: null };
        }
      }
      remove(paths) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const data = yield fetch_1.remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      list(path, options, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
            const data = yield fetch_1.post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
            return { data, error: null };
          } catch (error2) {
            return { data: null, error: error2 };
          }
        });
      }
      _getFinalPath(path) {
        return `${this.bucketId}/${path}`;
      }
      _removeEmptyFolders(path) {
        return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
      }
    };
    exports.StorageFileApi = StorageFileApi;
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/types.js
var require_types4 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@supabase/storage-js/dist/main/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_StorageBucketApi(), exports);
    __exportStar(require_StorageFileApi(), exports);
    __exportStar(require_types4(), exports);
    __exportStar(require_constants8(), exports);
  }
});

// node_modules/@supabase/storage-js/dist/main/SupabaseStorageClient.js
var require_SupabaseStorageClient = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/SupabaseStorageClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupabaseStorageClient = void 0;
    var lib_1 = require_lib5();
    var SupabaseStorageClient = class extends lib_1.StorageBucketApi {
      constructor(url, headers = {}, fetch3) {
        super(url, headers, fetch3);
      }
      from(id) {
        return new lib_1.StorageFileApi(this.url, this.headers, id, this.fetch);
      }
    };
    exports.SupabaseStorageClient = SupabaseStorageClient;
  }
});

// node_modules/@supabase/storage-js/dist/main/index.js
var require_main4 = __commonJS({
  "node_modules/@supabase/storage-js/dist/main/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupabaseStorageClient = void 0;
    var SupabaseStorageClient_1 = require_SupabaseStorageClient();
    Object.defineProperty(exports, "SupabaseStorageClient", { enumerable: true, get: function() {
      return SupabaseStorageClient_1.SupabaseStorageClient;
    } });
    __exportStar(require_types4(), exports);
  }
});

// node_modules/@supabase/supabase-js/dist/main/SupabaseClient.js
var require_SupabaseClient = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/SupabaseClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var helpers_1 = require_helpers();
    var SupabaseAuthClient_1 = require_SupabaseAuthClient();
    var SupabaseQueryBuilder_1 = require_SupabaseQueryBuilder();
    var storage_js_1 = require_main4();
    var postgrest_js_1 = require_main2();
    var realtime_js_1 = require_main3();
    var DEFAULT_OPTIONS = {
      schema: "public",
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      multiTab: true,
      headers: constants_1.DEFAULT_HEADERS
    };
    var SupabaseClient = class {
      constructor(supabaseUrl2, supabaseKey, options) {
        this.supabaseUrl = supabaseUrl2;
        this.supabaseKey = supabaseKey;
        if (!supabaseUrl2)
          throw new Error("supabaseUrl is required.");
        if (!supabaseKey)
          throw new Error("supabaseKey is required.");
        const _supabaseUrl = (0, helpers_1.stripTrailingSlash)(supabaseUrl2);
        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.restUrl = `${_supabaseUrl}/rest/v1`;
        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace("http", "ws");
        this.authUrl = `${_supabaseUrl}/auth/v1`;
        this.storageUrl = `${_supabaseUrl}/storage/v1`;
        this.schema = settings.schema;
        this.multiTab = settings.multiTab;
        this.fetch = settings.fetch;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), options === null || options === void 0 ? void 0 : options.headers);
        this.auth = this._initSupabaseAuthClient(settings);
        this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));
        this._listenForAuthEvents();
        this._listenForMultiTabEvents();
      }
      get storage() {
        return new storage_js_1.SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch);
      }
      from(table) {
        const url = `${this.restUrl}/${table}`;
        return new SupabaseQueryBuilder_1.SupabaseQueryBuilder(url, {
          headers: this._getAuthHeaders(),
          schema: this.schema,
          realtime: this.realtime,
          table,
          fetch: this.fetch
        });
      }
      rpc(fn, params, { head = false, count = null } = {}) {
        const rest = this._initPostgRESTClient();
        return rest.rpc(fn, params, { head, count });
      }
      removeAllSubscriptions() {
        return __awaiter(this, void 0, void 0, function* () {
          const allSubs = this.getSubscriptions().slice();
          const allSubPromises = allSubs.map((sub) => this.removeSubscription(sub));
          const allRemovedSubs = yield Promise.all(allSubPromises);
          return allRemovedSubs.map(({ error: error2 }, i2) => {
            return {
              data: { subscription: allSubs[i2] },
              error: error2
            };
          });
        });
      }
      removeSubscription(subscription) {
        return __awaiter(this, void 0, void 0, function* () {
          const { error: error2 } = yield this._closeSubscription(subscription);
          const allSubs = this.getSubscriptions();
          const openSubCount = allSubs.filter((chan) => chan.isJoined()).length;
          if (allSubs.length === 0)
            yield this.realtime.disconnect();
          return { data: { openSubscriptions: openSubCount }, error: error2 };
        });
      }
      _closeSubscription(subscription) {
        return __awaiter(this, void 0, void 0, function* () {
          let error2 = null;
          if (!subscription.isClosed()) {
            const { error: unsubError } = yield this._unsubscribeSubscription(subscription);
            error2 = unsubError;
          }
          this.realtime.remove(subscription);
          return { error: error2 };
        });
      }
      _unsubscribeSubscription(subscription) {
        return new Promise((resolve2) => {
          subscription.unsubscribe().receive("ok", () => resolve2({ error: null })).receive("error", (error2) => resolve2({ error: error2 })).receive("timeout", () => resolve2({ error: new Error("timed out") }));
        });
      }
      getSubscriptions() {
        return this.realtime.channels;
      }
      _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, localStorage: localStorage2, headers, fetch: fetch3 }) {
        const authHeaders = {
          Authorization: `Bearer ${this.supabaseKey}`,
          apikey: `${this.supabaseKey}`
        };
        return new SupabaseAuthClient_1.SupabaseAuthClient({
          url: this.authUrl,
          headers: Object.assign(Object.assign({}, headers), authHeaders),
          autoRefreshToken,
          persistSession,
          detectSessionInUrl,
          localStorage: localStorage2,
          fetch: fetch3
        });
      }
      _initRealtimeClient(options) {
        return new realtime_js_1.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), { apikey: this.supabaseKey }) }));
      }
      _initPostgRESTClient() {
        return new postgrest_js_1.PostgrestClient(this.restUrl, {
          headers: this._getAuthHeaders(),
          schema: this.schema,
          fetch: this.fetch
        });
      }
      _getAuthHeaders() {
        var _a4, _b;
        const headers = this.headers;
        const authBearer = (_b = (_a4 = this.auth.session()) === null || _a4 === void 0 ? void 0 : _a4.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
        headers["apikey"] = this.supabaseKey;
        headers["Authorization"] = `Bearer ${authBearer}`;
        return headers;
      }
      _listenForMultiTabEvents() {
        if (!this.multiTab || !(0, helpers_1.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
          return null;
        }
        try {
          return window === null || window === void 0 ? void 0 : window.addEventListener("storage", (e2) => {
            var _a4, _b, _c;
            if (e2.key === constants_1.STORAGE_KEY) {
              const newSession = JSON.parse(String(e2.newValue));
              const accessToken = (_b = (_a4 = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a4 === void 0 ? void 0 : _a4.access_token) !== null && _b !== void 0 ? _b : void 0;
              const previousAccessToken = (_c = this.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;
              if (!accessToken) {
                this._handleTokenChanged("SIGNED_OUT", accessToken, "STORAGE");
              } else if (!previousAccessToken && accessToken) {
                this._handleTokenChanged("SIGNED_IN", accessToken, "STORAGE");
              } else if (previousAccessToken !== accessToken) {
                this._handleTokenChanged("TOKEN_REFRESHED", accessToken, "STORAGE");
              }
            }
          });
        } catch (error2) {
          console.error("_listenForMultiTabEvents", error2);
          return null;
        }
      }
      _listenForAuthEvents() {
        let { data } = this.auth.onAuthStateChange((event, session) => {
          this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, "CLIENT");
        });
        return data;
      }
      _handleTokenChanged(event, token, source) {
        if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
          this.realtime.setAuth(token);
          if (source == "STORAGE")
            this.auth.setAuth(token);
          this.changedAccessToken = token;
        } else if (event === "SIGNED_OUT" || event === "USER_DELETED") {
          this.realtime.setAuth(this.supabaseKey);
          if (source == "STORAGE")
            this.auth.signOut();
        }
      }
    };
    exports.default = SupabaseClient;
  }
});

// node_modules/@supabase/supabase-js/dist/main/index.js
var require_main5 = __commonJS({
  "node_modules/@supabase/supabase-js/dist/main/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupabaseClient = exports.createClient = void 0;
    var SupabaseClient_1 = __importDefault(require_SupabaseClient());
    exports.SupabaseClient = SupabaseClient_1.default;
    __exportStar(require_main(), exports);
    __exportStar(require_main3(), exports);
    var createClient2 = (supabaseUrl2, supabaseKey, options) => {
      return new SupabaseClient_1.default(supabaseUrl2, supabaseKey, options);
    };
    exports.createClient = createClient2;
  }
});

// .svelte-kit/output/server/chunks/supabaseClient-772c11ee.js
function readable2(value, start) {
  return {
    subscribe: writable2(value, start).subscribe
  };
}
function writable2(value, start = noop2) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set22(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
            subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update22(fn) {
    set22(fn(value));
  }
  function subscribe22(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set22) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set22, update: update22, subscribe: subscribe22 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable2(initial_value, (set22) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop2;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set22);
      if (auto) {
        set22(result);
      } else {
        cleanup = is_function(result) ? result : noop2;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
var import_splitio, import_supabase_js, authorizationKey, factory, splitClient, subscriber_queue2, authReadiness, authStore, featureFlagNames, featureFlagsReadiness, featureFlagsStore, searchProvidersWithoutAll, searchProvidersWithAll, defaultQuery, subscribe$1, set$1, update$1, queryStore, subscribe2, set, update, queryToShareStore, readiness, searchProvidersStore, supabaseUrl, supabaseAnonKey, supabase;
var init_supabaseClient_772c11ee = __esm({
  ".svelte-kit/output/server/chunks/supabaseClient-772c11ee.js"() {
    import_splitio = __toESM(require_lib4(), 1);
    init_index_d153bcdc();
    import_supabase_js = __toESM(require_main5(), 1);
    authorizationKey = "iii3e56u9r991ofqen1ait7mdfe90ddof36a";
    factory = (0, import_splitio.SplitFactory)({
      core: {
        authorizationKey,
        key: "key"
      },
      startup: {
        readyTimeout: 1.5
      }
    });
    splitClient = factory.client();
    subscriber_queue2 = [];
    authReadiness = writable2(false);
    authStore = writable2({
      isLoggedIn: false,
      user: null
    });
    featureFlagNames = ["Search_All_Providers", "Results_In_IFrame"];
    featureFlagsReadiness = writable2(true);
    featureFlagsStore = writable2((splitClient == null ? void 0 : splitClient.getTreatments(featureFlagNames.concat())) || {
      Search_All_Providers: "off",
      Results_In_IFrame: "off"
    });
    splitClient == null ? void 0 : splitClient.on(splitClient == null ? void 0 : splitClient.Event.SDK_READY, function() {
      featureFlagsStore.update((value) => {
        const treatments = splitClient == null ? void 0 : splitClient.getTreatments(Object.keys(value));
        return treatments;
      });
      featureFlagsReadiness.set(true);
    });
    splitClient == null ? void 0 : splitClient.on(splitClient == null ? void 0 : splitClient.Event.SDK_UPDATE, function() {
      featureFlagsStore.update((value) => {
        const treatments = splitClient == null ? void 0 : splitClient.getTreatments(Object.keys(value));
        return treatments;
      });
    });
    searchProvidersWithoutAll = [
      {
        id: 1,
        name: "Google",
        url: "https://google.com/search?q="
      },
      {
        id: 2,
        name: "DuckDuckGo",
        url: "https://duckduckgo.com/?q="
      },
      {
        id: 3,
        name: "Bing",
        url: "https://bing.com/search?q="
      },
      {
        id: 4,
        name: "Yahoo",
        url: "https://search.yahoo.com/search?q="
      }
    ];
    searchProvidersWithAll = [
      ...searchProvidersWithoutAll,
      {
        id: 5,
        name: "All",
        url: [
          "https://search.yahoo.com/search?q=",
          "https://google.com/search?q=",
          "https://bing.com/search?q=",
          "https://duckduckgo.com/?q="
        ]
      }
    ];
    defaultQuery = {
      name: "",
      search_term: "",
      filters: {},
      provider: searchProvidersWithAll[0]
    };
    ({ subscribe: subscribe$1, set: set$1, update: update$1 } = writable2(__spreadValues({}, defaultQuery)));
    queryStore = {
      subscribe: subscribe$1,
      update: update$1,
      set: set$1,
      reset: () => set$1(__spreadProps(__spreadValues({}, defaultQuery), { filters: {} }))
    };
    ({ subscribe: subscribe2, set, update } = writable2(__spreadValues({}, defaultQuery)));
    queryToShareStore = {
      subscribe: subscribe2,
      update,
      set,
      reset: () => set(__spreadProps(__spreadValues({}, defaultQuery), { filters: {} }))
    };
    readiness = derived([authReadiness, featureFlagsReadiness], ([_authReadiness, _featureFlagsReadiness]) => {
      return _authReadiness && _featureFlagsReadiness;
    });
    searchProvidersStore = writable2(searchProvidersWithoutAll.sort((a, b) => b.id - a.id));
    supabaseUrl = "https://ztunkewekajphyudekyk.supabase.co";
    supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inp0dW5rZXdla2FqcGh5dWRla3lrIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NDYxMDI4MTQsImV4cCI6MTk2MTY3ODgxNH0.-t8GyxLA3u3QKM12FyMQINP5YtZDz8LjST9cCE8EzHk";
    supabase = (0, import_supabase_js.createClient)(supabaseUrl, supabaseAnonKey);
  }
});

// .svelte-kit/output/server/chunks/SearchProviderSelect-577da9fc.js
var defaultSettings, subscribe3, update2, set2, settingsStore, SearchProviderSelect;
var init_SearchProviderSelect_577da9fc = __esm({
  ".svelte-kit/output/server/chunks/SearchProviderSelect-577da9fc.js"() {
    init_supabaseClient_772c11ee();
    init_index_d153bcdc();
    defaultSettings = {
      autosave_queries: false,
      default_search_provider: searchProvidersWithAll[0],
      query_preview: false
    };
    ({ subscribe: subscribe3, update: update2, set: set2 } = writable2(__spreadValues({}, defaultSettings)));
    settingsStore = {
      subscribe: subscribe3,
      update: update2,
      set: set2,
      reset: () => set2(__spreadValues({}, defaultSettings))
    };
    SearchProviderSelect = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { searchProviders = [] } = $$props;
      let { value } = $$props;
      if ($$props.searchProviders === void 0 && $$bindings.searchProviders && searchProviders !== void 0)
        $$bindings.searchProviders(searchProviders);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      return `<select class="${"select select-bordered text-gray-300"}" name="${"provider"}" id="${"provider"}"${add_attribute("value", value, 0)}>${each(searchProviders, (provider) => {
        return `<option class="${"rounded-md text-lg p-4 text-gray-300 border-2 dark:bg-gray-600 border-gray-400 dark:border-gray-400"}" selected${add_attribute("value", provider.id, 0)}>${escape(provider.name)}</option>`;
      })}</select>`;
    });
  }
});

// .svelte-kit/output/server/chunks/Protected-4906baaa.js
var Protected;
var init_Protected_4906baaa = __esm({
  ".svelte-kit/output/server/chunks/Protected-4906baaa.js"() {
    init_index_d153bcdc();
    init_supabaseClient_772c11ee();
    Protected = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $authStore, $$unsubscribe_authStore;
      $$unsubscribe_authStore = subscribe(authStore, (value) => $authStore = value);
      $$unsubscribe_authStore();
      return `${$authStore.isLoggedIn ? `${slots.default ? slots.default({}) : ``}` : ``}`;
    });
  }
});

// node_modules/logrocket/dist/build.umd.js
var require_build_umd = __commonJS({
  "node_modules/logrocket/dist/build.umd.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory2) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory2();
      else if (typeof define === "function" && define.amd)
        define([], factory2);
      else {
        var a = factory2();
        for (var i2 in a)
          (typeof exports === "object" ? exports : root)[i2] = a[i2];
      }
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__2(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__2.m = modules;
        __webpack_require__2.c = installedModules;
        __webpack_require__2.d = function(exports2, name, getter) {
          if (!__webpack_require__2.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__2.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__2.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__2(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__2.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key2 in value)
              __webpack_require__2.d(ns, key2, function(key3) {
                return value[key3];
              }.bind(null, key2));
          return ns;
        };
        __webpack_require__2.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__2.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__2.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__2.p = "";
        return __webpack_require__2(__webpack_require__2.s = 0);
      }({
        "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js": function(module3, exports2) {
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length)
              len = arr.length;
            for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
              arr2[i2] = arr[i2];
            }
            return arr2;
          }
          module3.exports = _arrayLikeToArray;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js": function(module3, exports2, __webpack_require__2) {
          var arrayLikeToArray = __webpack_require__2("./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
          function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr))
              return arrayLikeToArray(arr);
          }
          module3.exports = _arrayWithoutHoles;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/classCallCheck.js": function(module3, exports2) {
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          module3.exports = _classCallCheck;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/createClass.js": function(module3, exports2) {
          function _defineProperties(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          module3.exports = _createClass;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/defineProperty.js": function(module3, exports2) {
          function _defineProperty(obj, key2, value) {
            if (key2 in obj) {
              Object.defineProperty(obj, key2, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key2] = value;
            }
            return obj;
          }
          module3.exports = _defineProperty;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/interopRequireDefault.js": function(module3, exports2) {
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              "default": obj
            };
          }
          module3.exports = _interopRequireDefault;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js": function(module3, exports2, __webpack_require__2) {
          var _typeof = __webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js")["default"];
          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function")
              return null;
            var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
            var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
            return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
              return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }
          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }
            if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return {
                "default": obj
              };
            }
            var cache = _getRequireWildcardCache(nodeInterop);
            if (cache && cache.has(obj)) {
              return cache.get(obj);
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key2 in obj) {
              if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
                if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key2, desc);
                } else {
                  newObj[key2] = obj[key2];
                }
              }
            }
            newObj["default"] = obj;
            if (cache) {
              cache.set(obj, newObj);
            }
            return newObj;
          }
          module3.exports = _interopRequireWildcard;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/iterableToArray.js": function(module3, exports2) {
          function _iterableToArray(iter) {
            if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
              return Array.from(iter);
          }
          module3.exports = _iterableToArray;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/nonIterableSpread.js": function(module3, exports2) {
          function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          module3.exports = _nonIterableSpread;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js": function(module3, exports2, __webpack_require__2) {
          var objectWithoutPropertiesLoose = __webpack_require__2("./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");
          function _objectWithoutProperties(source, excluded) {
            if (source == null)
              return {};
            var target = objectWithoutPropertiesLoose(source, excluded);
            var key2, i2;
            if (Object.getOwnPropertySymbols) {
              var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
              for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
                key2 = sourceSymbolKeys[i2];
                if (excluded.indexOf(key2) >= 0)
                  continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key2))
                  continue;
                target[key2] = source[key2];
              }
            }
            return target;
          }
          module3.exports = _objectWithoutProperties;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js": function(module3, exports2) {
          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null)
              return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key2, i2;
            for (i2 = 0; i2 < sourceKeys.length; i2++) {
              key2 = sourceKeys[i2];
              if (excluded.indexOf(key2) >= 0)
                continue;
              target[key2] = source[key2];
            }
            return target;
          }
          module3.exports = _objectWithoutPropertiesLoose;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/toConsumableArray.js": function(module3, exports2, __webpack_require__2) {
          var arrayWithoutHoles = __webpack_require__2("./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
          var iterableToArray = __webpack_require__2("./node_modules/@babel/runtime/helpers/iterableToArray.js");
          var unsupportedIterableToArray = __webpack_require__2("./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
          var nonIterableSpread = __webpack_require__2("./node_modules/@babel/runtime/helpers/nonIterableSpread.js");
          function _toConsumableArray(arr) {
            return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
          }
          module3.exports = _toConsumableArray;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/typeof.js": function(module3, exports2) {
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              module3.exports = _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
              module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
            } else {
              module3.exports = _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
              module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
            }
            return _typeof(obj);
          }
          module3.exports = _typeof;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js": function(module3, exports2, __webpack_require__2) {
          var arrayLikeToArray = __webpack_require__2("./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
          function _unsupportedIterableToArray(o, minLen) {
            if (!o)
              return;
            if (typeof o === "string")
              return arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor)
              n = o.constructor.name;
            if (n === "Map" || n === "Set")
              return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
              return arrayLikeToArray(o, minLen);
          }
          module3.exports = _unsupportedIterableToArray;
          module3.exports["default"] = module3.exports, module3.exports.__esModule = true;
        },
        "./node_modules/webpack/buildin/global.js": function(module3, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e2) {
            if (typeof window === "object")
              g = window;
          }
          module3.exports = g;
        },
        "./packages/@apphub:logrocket-console/src/index.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _registerConsole = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-console/src/registerConsole.js"));
          var _default = _registerConsole.default;
          exports2.default = _default;
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-console/src/registerConsole.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = registerConsole;
          var _typeof2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js"));
          var _enhanceFunc = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/enhanceFunc.js"));
          var _logrocketExceptions = __webpack_require__2("./packages/@apphub:logrocket-exceptions/src/index.js");
          function registerConsole(logger) {
            var unsubFunctions = [];
            var methods = ["log", "warn", "info", "error", "debug"];
            methods.forEach(function(method) {
              unsubFunctions.push((0, _enhanceFunc.default)(console, method, function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                logger.addEvent("lr.core.LogEvent", function() {
                  var consoleOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var isEnabled = consoleOptions.isEnabled;
                  if ((0, _typeof2.default)(isEnabled) === "object" && isEnabled[method] === false || isEnabled === false) {
                    return null;
                  }
                  if (method === "error" && consoleOptions.shouldAggregateConsoleErrors) {
                    _logrocketExceptions.Capture.captureMessage(logger, args[0], {}, true);
                  }
                  return {
                    logLevel: method.toUpperCase(),
                    args
                  };
                });
              }));
            });
            return function() {
              unsubFunctions.forEach(function(unsubFunction) {
                return unsubFunction();
              });
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-exceptions/src/Capture.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.captureMessage = captureMessage;
          exports2.captureException = captureException;
          var _typeof2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js"));
          var _TraceKit = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/TraceKit.js"));
          var _stackTraceFromError = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-exceptions/src/stackTraceFromError.js"));
          function isScalar(value) {
            return /boolean|number|string/.test((0, _typeof2.default)(value));
          }
          function scrub(data, options) {
            if (options) {
              var optionalScalars = [
                "level",
                "logger"
              ];
              for (var _i = 0, _optionalScalars = optionalScalars; _i < _optionalScalars.length; _i++) {
                var field = _optionalScalars[_i];
                var value = options[field];
                if (isScalar(value)) {
                  data[field] = value.toString();
                }
              }
              var optionalMaps = ["tags", "extra"];
              for (var _i2 = 0, _optionalMaps = optionalMaps; _i2 < _optionalMaps.length; _i2++) {
                var _field = _optionalMaps[_i2];
                var dirty = options[_field] || {};
                var scrubbed = {};
                for (var _i3 = 0, _Object$keys = Object.keys(dirty); _i3 < _Object$keys.length; _i3++) {
                  var key2 = _Object$keys[_i3];
                  var _value = dirty[key2];
                  if (isScalar(_value)) {
                    scrubbed[key2.toString()] = _value.toString();
                  }
                }
                data[_field] = scrubbed;
              }
            }
          }
          function captureMessage(logger, message) {
            var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var isConsole = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var data = {
              exceptionType: isConsole ? "CONSOLE" : "MESSAGE",
              message,
              browserHref: window.location ? window.location.href : ""
            };
            scrub(data, options);
            logger.addEvent("lr.core.Exception", function() {
              return data;
            });
          }
          function captureException(logger, exception) {
            var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var preppedTrace = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            var trace = preppedTrace || _TraceKit.default.computeStackTrace(exception);
            var data = {
              exceptionType: "WINDOW",
              errorType: trace.name,
              message: trace.message,
              browserHref: window.location ? window.location.href : ""
            };
            scrub(data, options);
            var addEventOptions = {
              _stackTrace: (0, _stackTraceFromError.default)(trace)
            };
            logger.addEvent("lr.core.Exception", function() {
              return data;
            }, addEventOptions);
          }
        },
        "./packages/@apphub:logrocket-exceptions/src/index.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireWildcard = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "registerExceptions", {
            enumerable: true,
            get: function get2() {
              return _registerExceptions.default;
            }
          });
          exports2.Capture = void 0;
          var _registerExceptions = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-exceptions/src/registerExceptions.js"));
          var Capture = _interopRequireWildcard(__webpack_require__2("./packages/@apphub:logrocket-exceptions/src/Capture.js"));
          exports2.Capture = Capture;
        },
        "./packages/@apphub:logrocket-exceptions/src/raven/raven.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          (function(global2) {
            var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = void 0;
            var _classCallCheck2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/classCallCheck.js"));
            var _createClass2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/createClass.js"));
            var _TraceKit = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/TraceKit.js"));
            var objectPrototype = Object.prototype;
            function isUndefined(what) {
              return what === void 0;
            }
            function isFunction(what) {
              return typeof what === "function";
            }
            function each2(obj, callback) {
              var i2, j;
              if (isUndefined(obj.length)) {
                for (i2 in obj) {
                  if (hasKey(obj, i2)) {
                    callback.call(null, i2, obj[i2]);
                  }
                }
              } else {
                j = obj.length;
                if (j) {
                  for (i2 = 0; i2 < j; i2++) {
                    callback.call(null, i2, obj[i2]);
                  }
                }
              }
            }
            function hasKey(object, key2) {
              return objectPrototype.hasOwnProperty.call(object, key2);
            }
            function fill(obj, name, replacement, track) {
              var orig = obj[name];
              obj[name] = replacement(orig);
              if (track) {
                track.push([obj, name, orig]);
              }
            }
            var _window = typeof window !== "undefined" ? window : typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : {};
            var _document = _window.document;
            var Handler = /* @__PURE__ */ function() {
              function Handler2(_ref) {
                var captureException = _ref.captureException;
                (0, _classCallCheck2.default)(this, Handler2);
                this._errorHandler = this._errorHandler.bind(this);
                this._ignoreOnError = 0;
                this._wrappedBuiltIns = [];
                this.captureException = captureException;
                _TraceKit.default.report.subscribe(this._errorHandler);
                this._instrumentTryCatch();
              }
              (0, _createClass2.default)(Handler2, [{
                key: "uninstall",
                value: function uninstall() {
                  _TraceKit.default.report.unsubscribe(this._errorHandler);
                  var builtin;
                  while (this._wrappedBuiltIns.length) {
                    builtin = this._wrappedBuiltIns.shift();
                    var obj = builtin[0], name = builtin[1], orig = builtin[2];
                    obj[name] = orig;
                  }
                }
              }, {
                key: "_errorHandler",
                value: function _errorHandler(report) {
                  if (!this._ignoreOnError) {
                    this.captureException(report);
                  }
                }
              }, {
                key: "_ignoreNextOnError",
                value: function _ignoreNextOnError() {
                  var _this = this;
                  this._ignoreOnError += 1;
                  setTimeout(function() {
                    _this._ignoreOnError -= 1;
                  });
                }
              }, {
                key: "context",
                value: function context(options, func, args) {
                  if (isFunction(options)) {
                    args = func || [];
                    func = options;
                    options = void 0;
                  }
                  return this.wrap(options, func).apply(this, args);
                }
              }, {
                key: "wrap",
                value: function wrap(options, func, _before) {
                  var self2 = this;
                  if (isUndefined(func) && !isFunction(options)) {
                    return options;
                  }
                  if (isFunction(options)) {
                    func = options;
                    options = void 0;
                  }
                  if (!isFunction(func)) {
                    return func;
                  }
                  try {
                    if (func.__lr__) {
                      return func;
                    }
                    if (func.__lr_wrapper__) {
                      return func.__lr_wrapper__;
                    }
                    if (!Object.isExtensible(func)) {
                      return func;
                    }
                  } catch (e2) {
                    return func;
                  }
                  function wrapped() {
                    var args = [], i2 = arguments.length, deep = !options || options && options.deep !== false;
                    if (_before && isFunction(_before)) {
                      _before.apply(this, arguments);
                    }
                    while (i2--) {
                      args[i2] = deep ? self2.wrap(options, arguments[i2]) : arguments[i2];
                    }
                    try {
                      return func.apply(this, args);
                    } catch (e2) {
                      self2._ignoreNextOnError();
                      self2.captureException(_TraceKit.default.computeStackTrace(e2), options);
                      throw e2;
                    }
                  }
                  for (var property in func) {
                    if (hasKey(func, property)) {
                      wrapped[property] = func[property];
                    }
                  }
                  wrapped.prototype = func.prototype;
                  func.__lr_wrapper__ = wrapped;
                  wrapped.__lr__ = true;
                  wrapped.__inner__ = func;
                  return wrapped;
                }
              }, {
                key: "_instrumentTryCatch",
                value: function _instrumentTryCatch() {
                  var self2 = this;
                  var wrappedBuiltIns = self2._wrappedBuiltIns;
                  function wrapTimeFn(orig) {
                    return function(fn, t2) {
                      var args = new Array(arguments.length);
                      for (var i3 = 0; i3 < args.length; ++i3) {
                        args[i3] = arguments[i3];
                      }
                      var originalCallback = args[0];
                      if (isFunction(originalCallback)) {
                        args[0] = self2.wrap(originalCallback);
                      }
                      if (orig.apply) {
                        return orig.apply(this, args);
                      } else {
                        return orig(args[0], args[1]);
                      }
                    };
                  }
                  function wrapEventTarget(global3) {
                    var proto = _window[global3] && _window[global3].prototype;
                    if (proto && proto.hasOwnProperty && proto.hasOwnProperty("addEventListener")) {
                      fill(proto, "addEventListener", function(orig) {
                        return function(evtName, fn, capture, secure) {
                          try {
                            if (fn && fn.handleEvent) {
                              fn.handleEvent = self2.wrap(fn.handleEvent);
                            }
                          } catch (err) {
                          }
                          var before;
                          return orig.call(this, evtName, self2.wrap(fn, void 0, before), capture, secure);
                        };
                      }, wrappedBuiltIns);
                      fill(proto, "removeEventListener", function(orig) {
                        return function(evt, fn, capture, secure) {
                          try {
                            fn = fn && (fn.__lr_wrapper__ ? fn.__lr_wrapper__ : fn);
                          } catch (e2) {
                          }
                          return orig.call(this, evt, fn, capture, secure);
                        };
                      }, wrappedBuiltIns);
                    }
                  }
                  fill(_window, "setTimeout", wrapTimeFn, wrappedBuiltIns);
                  fill(_window, "setInterval", wrapTimeFn, wrappedBuiltIns);
                  if (_window.requestAnimationFrame) {
                    fill(_window, "requestAnimationFrame", function(orig) {
                      return function(cb) {
                        return orig(self2.wrap(cb));
                      };
                    }, wrappedBuiltIns);
                  }
                  var eventTargets = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
                  for (var i2 = 0; i2 < eventTargets.length; i2++) {
                    wrapEventTarget(eventTargets[i2]);
                  }
                  var $ = _window.jQuery || _window.$;
                  if ($ && $.fn && $.fn.ready) {
                    fill($.fn, "ready", function(orig) {
                      return function(fn) {
                        return orig.call(this, self2.wrap(fn));
                      };
                    }, wrappedBuiltIns);
                  }
                }
              }]);
              return Handler2;
            }();
            exports2.default = Handler;
            ;
            module3.exports = exports2.default;
          }).call(this, __webpack_require__2("./node_modules/webpack/buildin/global.js"));
        },
        "./packages/@apphub:logrocket-exceptions/src/registerExceptions.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireWildcard = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = registerCore;
          var _raven = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-exceptions/src/raven/raven.js"));
          var Capture = _interopRequireWildcard(__webpack_require__2("./packages/@apphub:logrocket-exceptions/src/Capture.js"));
          function registerCore(logger) {
            var raven = new _raven.default({
              captureException: function captureException(errorReport) {
                Capture.captureException(logger, null, null, errorReport);
              }
            });
            var rejectionHandler = function rejectionHandler2(evt) {
              logger.addEvent("lr.core.Exception", function() {
                return {
                  exceptionType: "UNHANDLED_REJECTION",
                  message: evt.reason || "Unhandled Promise rejection"
                };
              });
            };
            window.addEventListener("unhandledrejection", rejectionHandler);
            return function() {
              window.removeEventListener("unhandledrejection", rejectionHandler);
              raven.uninstall();
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-exceptions/src/stackTraceFromError.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = stackTraceFromError;
          function stackTraceFromError(errorReport) {
            function makeNotNull(val) {
              return val === null ? void 0 : val;
            }
            return errorReport.stack ? errorReport.stack.map(function(frame) {
              return {
                lineNumber: makeNotNull(frame.line),
                columnNumber: makeNotNull(frame.column),
                fileName: makeNotNull(frame.url),
                functionName: makeNotNull(frame.func)
              };
            }) : void 0;
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-network/src/fetchIntercept.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _toConsumableArray2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));
          var _registerXHR = __webpack_require__2("./packages/@apphub:logrocket-network/src/registerXHR.js");
          var interceptors = [];
          function makeInterceptor(fetch3, fetchId) {
            var reversedInterceptors = interceptors.reduce(function(array, interceptor) {
              return [interceptor].concat(array);
            }, []);
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            var promise = Promise.resolve(args);
            reversedInterceptors.forEach(function(_ref) {
              var request = _ref.request, requestError = _ref.requestError;
              if (request || requestError) {
                promise = promise.then(function(args2) {
                  return request.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args2)));
                }, function(args2) {
                  return requestError.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args2)));
                });
              }
            });
            promise = promise.then(function(args2) {
              (0, _registerXHR.setActive)(false);
              var res;
              var err;
              try {
                res = fetch3.apply(void 0, (0, _toConsumableArray2.default)(args2));
              } catch (_err) {
                err = _err;
              }
              (0, _registerXHR.setActive)(true);
              if (err) {
                throw err;
              }
              return res;
            });
            reversedInterceptors.forEach(function(_ref2) {
              var response = _ref2.response, responseError = _ref2.responseError;
              if (response || responseError) {
                promise = promise.then(function(res) {
                  return response(fetchId, res);
                }, function(err) {
                  return responseError && responseError(fetchId, err);
                });
              }
            });
            return promise;
          }
          function attach(env) {
            if (!env.fetch || !env.Promise) {
              return;
            }
            var isPolyfill = env.fetch.polyfill;
            env.fetch = function(fetch3) {
              var fetchId = 0;
              return function() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                return makeInterceptor.apply(void 0, [fetch3, fetchId++].concat(args));
              };
            }(env.fetch);
            if (isPolyfill) {
              env.fetch.polyfill = isPolyfill;
            }
          }
          var didAttach = false;
          var _default = {
            register: function register(interceptor) {
              if (!didAttach) {
                didAttach = true;
                attach(window);
              }
              interceptors.push(interceptor);
              return function() {
                var index = interceptors.indexOf(interceptor);
                if (index >= 0) {
                  interceptors.splice(index, 1);
                }
              };
            },
            clear: function clear() {
              interceptors = [];
            }
          };
          exports2.default = _default;
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-network/src/index.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = registerNetwork;
          var _defineProperty2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/defineProperty.js"));
          var _typeof2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/typeof.js"));
          var _registerFetch = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-network/src/registerFetch.js"));
          var _registerNetworkInformation = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-network/src/registerNetworkInformation.js"));
          var _registerXHR = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-network/src/registerXHR.js"));
          var _mapValues = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/mapValues.js"));
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              if (i2 % 2) {
                ownKeys(Object(source), true).forEach(function(key2) {
                  (0, _defineProperty2.default)(target, key2, source[key2]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key2) {
                  Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
                });
              }
            }
            return target;
          }
          function registerNetwork(logger) {
            var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
              isReactNative: false
            };
            var isReactNative = config.isReactNative, shouldAugmentNPS = config.shouldAugmentNPS, shouldParseXHRBlob = config.shouldParseXHRBlob;
            var ignoredNetwork = {};
            var truncate = function truncate2(data) {
              var limit = 1024 * 1e3 * 4;
              var str = data;
              if ((0, _typeof2.default)(data) === "object" && data != null) {
                var proto = Object.getPrototypeOf(data);
                if (proto === Object.prototype || proto === null) {
                  str = JSON.stringify(data);
                }
              }
              if (str && str.length && str.length > limit && typeof str === "string") {
                var beginning = str.substring(0, 1e3);
                return "".concat(beginning, " ... LogRocket truncating to first 1000 characters.\n      Keep data under 4MB to prevent truncation. https://docs.logrocket.com/reference#network");
              }
              return data;
            };
            var addRequest = function addRequest2(reqId, request) {
              var method = request.method;
              logger.addEvent("lr.network.RequestEvent", function() {
                var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled, _ref$requestSanitizer = _ref.requestSanitizer, requestSanitizer = _ref$requestSanitizer === void 0 ? function(f3) {
                  return f3;
                } : _ref$requestSanitizer;
                if (!isEnabled) {
                  return null;
                }
                var sanitized = null;
                try {
                  sanitized = requestSanitizer(_objectSpread(_objectSpread({}, request), {}, {
                    reqId
                  }));
                } catch (err) {
                  console.error(err);
                }
                if (sanitized) {
                  var url = sanitized.url;
                  if (typeof document !== "undefined" && typeof document.createElement === "function") {
                    var a = document.createElement("a");
                    a.href = sanitized.url;
                    url = a.href;
                  }
                  return {
                    reqId,
                    url,
                    headers: (0, _mapValues.default)(sanitized.headers, function(headerValue) {
                      return "".concat(headerValue);
                    }),
                    body: truncate(sanitized.body),
                    method,
                    referrer: sanitized.referrer || void 0,
                    mode: sanitized.mode || void 0,
                    credentials: sanitized.credentials || void 0
                  };
                }
                ignoredNetwork[reqId] = true;
                return null;
              });
            };
            var addResponse = function addResponse2(reqId, response) {
              var method = response.method, status = response.status;
              logger.addEvent("lr.network.ResponseEvent", function() {
                var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$isEnabled = _ref2.isEnabled, isEnabled = _ref2$isEnabled === void 0 ? true : _ref2$isEnabled, _ref2$responseSanitiz = _ref2.responseSanitizer, responseSanitizer = _ref2$responseSanitiz === void 0 ? function(f3) {
                  return f3;
                } : _ref2$responseSanitiz;
                if (!isEnabled) {
                  return null;
                } else if (ignoredNetwork[reqId]) {
                  delete ignoredNetwork[reqId];
                  return null;
                }
                var sanitized = null;
                try {
                  sanitized = responseSanitizer(_objectSpread(_objectSpread({}, response), {}, {
                    reqId
                  }));
                } catch (err) {
                  console.error(err);
                }
                if (sanitized) {
                  return {
                    reqId,
                    status: sanitized.status,
                    headers: (0, _mapValues.default)(sanitized.headers, function(headerValue) {
                      return "".concat(headerValue);
                    }),
                    body: truncate(sanitized.body),
                    method
                  };
                }
                return {
                  reqId,
                  status,
                  headers: {},
                  body: null,
                  method
                };
              });
            };
            var isIgnored = function isIgnored2(reqId) {
              return logger.isDisabled || ignoredNetwork[reqId] === true;
            };
            var unsubFetch = (0, _registerFetch.default)({
              addRequest,
              addResponse,
              isIgnored
            });
            var unsubXHR = (0, _registerXHR.default)({
              addRequest,
              addResponse,
              isIgnored,
              logger,
              shouldAugmentNPS,
              shouldParseXHRBlob
            });
            var unsubNetworkInformation = isReactNative ? function() {
            } : (0, _registerNetworkInformation.default)(logger);
            return function() {
              unsubNetworkInformation();
              unsubFetch();
              unsubXHR();
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-network/src/registerFetch.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = registerFetch;
          var _defineProperty2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/defineProperty.js"));
          var _mapValues = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/mapValues.js"));
          var _fetchIntercept = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-network/src/fetchIntercept.js"));
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              if (i2 % 2) {
                ownKeys(Object(source), true).forEach(function(key2) {
                  (0, _defineProperty2.default)(target, key2, source[key2]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key2) {
                  Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
                });
              }
            }
            return target;
          }
          function makeObjectFromHeaders(headers) {
            if (headers == null || typeof headers.forEach !== "function") {
              return headers;
            }
            var result = {};
            headers.forEach(function(value, key2) {
              if (result[key2]) {
                result[key2] = "".concat(result[key2], ",").concat(value);
              } else {
                result[key2] = "".concat(value);
              }
            });
            return result;
          }
          var stringifyHeaders = function stringifyHeaders2(headers) {
            return (0, _mapValues.default)(makeObjectFromHeaders(headers), function(value) {
              return "".concat(value);
            });
          };
          function pluckFetchFields() {
            var arg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return {
              url: arg.url,
              headers: stringifyHeaders(arg.headers),
              method: arg.method && arg.method.toUpperCase(),
              referrer: arg.referrer || void 0,
              mode: arg.mode || void 0,
              credentials: arg.credentials || void 0
            };
          }
          function registerFetch(_ref) {
            var addRequest = _ref.addRequest, addResponse = _ref.addResponse, isIgnored = _ref.isIgnored;
            var LOGROCKET_FETCH_LABEL = "fetch-";
            var fetchMethodMap = {};
            var unregister = _fetchIntercept.default.register({
              request: function request(fetchId) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                var p;
                if (typeof Request !== "undefined" && args[0] instanceof Request) {
                  var clonedText;
                  try {
                    clonedText = args[0].clone().text();
                  } catch (err) {
                    clonedText = Promise.resolve("LogRocket fetch error: ".concat(err.message));
                  }
                  p = clonedText.then(function(body) {
                    return _objectSpread(_objectSpread({}, pluckFetchFields(args[0])), {}, {
                      body
                    });
                  }, function(err) {
                    return _objectSpread(_objectSpread({}, pluckFetchFields(args[0])), {}, {
                      body: "LogRocket fetch error: ".concat(err.message)
                    });
                  });
                } else {
                  p = Promise.resolve(_objectSpread(_objectSpread({}, pluckFetchFields(args[1])), {}, {
                    url: "".concat(args[0]),
                    body: (args[1] || {}).body
                  }));
                }
                return p.then(function(req) {
                  fetchMethodMap[fetchId] = req.method;
                  addRequest("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), req);
                  return args;
                });
              },
              requestError: function requestError(fetchId, error2) {
                return Promise.reject(error2);
              },
              response: function response(fetchId, _response) {
                var clonedText;
                if (isIgnored("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId))) {
                  return _response;
                }
                try {
                  clonedText = _response.clone().text();
                } catch (err) {
                  clonedText = Promise.resolve("LogRocket fetch error: ".concat(err.message));
                }
                clonedText.catch(function(error2) {
                  if (error2.name === "AbortError" && error2 instanceof DOMException) {
                    return;
                  }
                  throw error2;
                }).then(function(data) {
                  var responseHash = {
                    url: _response.url,
                    status: _response.status,
                    headers: stringifyHeaders(_response.headers),
                    body: data,
                    method: fetchMethodMap[fetchId]
                  };
                  delete fetchMethodMap[fetchId];
                  addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash);
                });
                return _response;
              },
              responseError: function responseError(fetchId, error2) {
                var response = {
                  url: void 0,
                  status: 0,
                  headers: {},
                  body: "".concat(error2)
                };
                addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), response);
                return Promise.reject(error2);
              }
            });
            return unregister;
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-network/src/registerNetworkInformation.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = registerNetworkInformation;
          var EFFECTIVE_TYPE_VALS = {
            "slow-2g": "SLOW2G",
            "2g": "TWOG",
            "3g": "THREEG",
            "4g": "FOURG"
          };
          function registerNetworkInformation(logger) {
            var lastStatus = void 0;
            function sendNetworkInformation() {
              var newStatus = {
                online: window.navigator.onLine,
                effectiveType: "UNKOWN"
              };
              if (!window.navigator.onLine) {
                newStatus.effectiveType = "NONE";
              } else if (window.navigator.connection && window.navigator.connection.effectiveType) {
                newStatus.effectiveType = EFFECTIVE_TYPE_VALS[window.navigator.connection.effectiveType] || "UNKNOWN";
              }
              if (lastStatus && newStatus.online === lastStatus.online && newStatus.effectiveType === lastStatus.effectiveType) {
                return;
              }
              lastStatus = newStatus;
              logger.addEvent("lr.network.NetworkStatusEvent", function() {
                var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled;
                if (!isEnabled) {
                  return null;
                }
                return newStatus;
              });
            }
            setTimeout(sendNetworkInformation);
            if (window.navigator.connection && typeof window.navigator.connection.addEventListener === "function") {
              window.navigator.connection.addEventListener("change", sendNetworkInformation);
            }
            window.addEventListener("online", sendNetworkInformation);
            window.addEventListener("offline", sendNetworkInformation);
            return function() {
              window.removeEventListener("offline", sendNetworkInformation);
              window.removeEventListener("online", sendNetworkInformation);
              if (window.navigator.connection && typeof window.navigator.connection.removeEventListener === "function") {
                window.navigator.connection.removeEventListener("change", sendNetworkInformation);
              }
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-network/src/registerXHR.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.setActive = setActive;
          exports2.default = registerXHR;
          var _mapValues = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/mapValues.js"));
          var _enhanceFunc = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/enhanceFunc.js"));
          var _startsWith = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-utils/src/startsWith.js"));
          var _nps = __webpack_require__2("./packages/@apphub:logrocket-utils/src/constants/nps.js");
          var isActive = true;
          function setActive(shouldBeActive) {
            isActive = shouldBeActive;
          }
          var currentXHRId = 0;
          function registerXHR(_ref) {
            var addRequest = _ref.addRequest, addResponse = _ref.addResponse, isIgnored = _ref.isIgnored, logger = _ref.logger, _ref$shouldAugmentNPS = _ref.shouldAugmentNPS, shouldAugmentNPS = _ref$shouldAugmentNPS === void 0 ? true : _ref$shouldAugmentNPS, _ref$shouldParseXHRBl = _ref.shouldParseXHRBlob, shouldParseXHRBlob = _ref$shouldParseXHRBl === void 0 ? false : _ref$shouldParseXHRBl;
            var _XHR = XMLHttpRequest;
            var xhrMap = /* @__PURE__ */ new WeakMap();
            var unsubscribedFromXhr = false;
            var LOGROCKET_XHR_LABEL = "xhr-";
            window._lrXMLHttpRequest = XMLHttpRequest;
            XMLHttpRequest = function XMLHttpRequest2(mozAnon, mozSystem) {
              var xhrObject = new _XHR(mozAnon, mozSystem);
              if (!isActive) {
                return xhrObject;
              }
              xhrMap.set(xhrObject, {
                xhrId: ++currentXHRId,
                headers: {}
              });
              var openOriginal = xhrObject.open;
              function openShim() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                try {
                  var url = args[1];
                  if (window.URL && typeof window.URL === "function" && url.search(_nps.WOOTRIC_RESPONSES_REGEX) === 0) {
                    var logrocketSessionURL = new window.URL(logger.recordingURL);
                    logrocketSessionURL.searchParams.set("nps", "wootric");
                    var urlObj = new window.URL(url);
                    var responseText = urlObj.searchParams.get("response[text]");
                    var feedback = responseText ? "".concat(responseText, "\n\n") : "";
                    urlObj.searchParams.set("response[text]", "".concat(feedback, "<").concat(logrocketSessionURL.href, "|View LogRocket session>"));
                    args[1] = urlObj.href;
                  }
                } catch (e2) {
                }
                return openOriginal.apply(this, args);
              }
              var sendOriginal = xhrObject.send;
              function sendShim() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                try {
                  var currentXHR = xhrMap.get(xhrObject);
                  if (window.URL && typeof window.URL === "function" && currentXHR && currentXHR.url && currentXHR.url.search(_nps.DELIGHTED_RESPONSES_REGEX) === 0 && args.length && args[0].indexOf(_nps.DELIGHTED_FEEDBACK_PREFIX) !== -1) {
                    var recordingURL = new window.URL(logger.recordingURL);
                    recordingURL.searchParams.set("nps", "delighted");
                    var logrocketSessionURL = encodeURIComponent(recordingURL.href);
                    var data = args[0].split("&").map(function(dataString) {
                      if ((0, _startsWith.default)(dataString, _nps.DELIGHTED_FEEDBACK_PREFIX)) {
                        var isEmpty = dataString === _nps.DELIGHTED_FEEDBACK_PREFIX;
                        return "".concat(dataString).concat(isEmpty ? "" : "\n\n", "<").concat(logrocketSessionURL, "|View LogRocket session>");
                      }
                      return dataString;
                    }).join("&");
                    args[0] = data;
                  }
                } catch (e2) {
                }
                return sendOriginal.apply(this, args);
              }
              if (shouldAugmentNPS) {
                xhrObject.open = openShim;
                xhrObject.send = sendShim;
              }
              (0, _enhanceFunc.default)(xhrObject, "open", function(method, url) {
                if (unsubscribedFromXhr) {
                  return;
                }
                var currentXHR = xhrMap.get(xhrObject);
                currentXHR.method = method;
                currentXHR.url = url;
              });
              (0, _enhanceFunc.default)(xhrObject, "send", function(data) {
                if (unsubscribedFromXhr) {
                  return;
                }
                var currentXHR = xhrMap.get(xhrObject);
                if (!currentXHR) {
                  return;
                }
                var request = {
                  url: currentXHR.url,
                  method: currentXHR.method && currentXHR.method.toUpperCase(),
                  headers: (0, _mapValues.default)(currentXHR.headers || {}, function(headerValues) {
                    return headerValues.join(", ");
                  }),
                  body: data
                };
                addRequest("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), request);
              });
              (0, _enhanceFunc.default)(xhrObject, "setRequestHeader", function(header, value) {
                if (unsubscribedFromXhr) {
                  return;
                }
                var currentXHR = xhrMap.get(xhrObject);
                if (!currentXHR) {
                  return;
                }
                currentXHR.headers = currentXHR.headers || {};
                currentXHR.headers[header] = currentXHR.headers[header] || [];
                currentXHR.headers[header].push(value);
              });
              var xhrListeners = {
                readystatechange: function readystatechange() {
                  if (unsubscribedFromXhr) {
                    return;
                  }
                  if (xhrObject.readyState === 4) {
                    var currentXHR = xhrMap.get(xhrObject);
                    if (!currentXHR) {
                      return;
                    }
                    if (isIgnored("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId))) {
                      return;
                    }
                    var headerString = xhrObject.getAllResponseHeaders();
                    var headers = headerString.split(/[\r\n]+/).reduce(function(previous, current) {
                      var next = previous;
                      var headerParts = current.split(": ");
                      if (headerParts.length > 0) {
                        var key2 = headerParts.shift();
                        var value = headerParts.join(": ");
                        if (previous[key2]) {
                          next[key2] += ", ".concat(value);
                        } else {
                          next[key2] = value;
                        }
                      }
                      return next;
                    }, {});
                    var body;
                    try {
                      switch (xhrObject.responseType) {
                        case "json":
                          body = logger._shouldCloneResponse ? JSON.parse(JSON.stringify(xhrObject.response)) : xhrObject.response;
                          break;
                        case "arraybuffer":
                        case "blob": {
                          body = xhrObject.response;
                          break;
                        }
                        case "document": {
                          body = xhrObject.responseXML;
                          break;
                        }
                        case "text":
                        case "": {
                          body = xhrObject.responseText;
                          break;
                        }
                        default: {
                          body = "";
                        }
                      }
                    } catch (err) {
                      body = "LogRocket: Error accessing response.";
                    }
                    var response = {
                      url: currentXHR.url,
                      status: xhrObject.status,
                      headers,
                      body,
                      method: (currentXHR.method || "").toUpperCase()
                    };
                    if (shouldParseXHRBlob && response.body instanceof Blob) {
                      var blobReader = new FileReader();
                      blobReader.readAsText(response.body);
                      blobReader.onload = function() {
                        try {
                          response.body = JSON.parse(blobReader.result);
                        } catch (_unused) {
                        }
                        addResponse("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);
                      };
                    } else {
                      addResponse("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);
                    }
                  }
                }
              };
              Object.keys(xhrListeners).forEach(function(key2) {
                xhrObject.addEventListener(key2, xhrListeners[key2]);
              });
              return xhrObject;
            };
            XMLHttpRequest.prototype = _XHR.prototype;
            ["UNSENT", "OPENED", "HEADERS_RECEIVED", "LOADING", "DONE"].forEach(function(variable) {
              XMLHttpRequest[variable] = _XHR[variable];
            });
            return function() {
              unsubscribedFromXhr = true;
              XMLHttpRequest = _XHR;
            };
          }
        },
        "./packages/@apphub:logrocket-redux/src/createEnhancer.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = createEnhancer;
          var _defineProperty2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/defineProperty.js"));
          var _now = _interopRequireDefault(__webpack_require__2("./packages/@apphub:now/src/index.js"));
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              if (i2 % 2) {
                ownKeys(Object(source), true).forEach(function(key2) {
                  (0, _defineProperty2.default)(target, key2, source[key2]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key2) {
                  Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
                });
              }
            }
            return target;
          }
          var storeIdCounter = 0;
          function createEnhancer(logger) {
            var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$stateSanitizer = _ref.stateSanitizer, stateSanitizer = _ref$stateSanitizer === void 0 ? function(f3) {
              return f3;
            } : _ref$stateSanitizer, _ref$actionSanitizer = _ref.actionSanitizer, actionSanitizer = _ref$actionSanitizer === void 0 ? function(f3) {
              return f3;
            } : _ref$actionSanitizer;
            return function(createStore) {
              return function(reducer, initialState, enhancer) {
                var store = createStore(reducer, initialState, enhancer);
                var originalDispatch = store.dispatch;
                var storeId = storeIdCounter++;
                logger.addEvent("lr.redux.InitialState", function() {
                  var sanitizedState;
                  try {
                    sanitizedState = stateSanitizer(store.getState());
                  } catch (err) {
                    console.error(err.toString());
                  }
                  return {
                    state: sanitizedState,
                    storeId
                  };
                });
                var dispatch = function dispatch2(action) {
                  var start = (0, _now.default)();
                  var err;
                  var res;
                  try {
                    res = originalDispatch(action);
                  } catch (_err) {
                    err = _err;
                  } finally {
                    var duration = (0, _now.default)() - start;
                    logger.addEvent("lr.redux.ReduxAction", function() {
                      var sanitizedState = null;
                      var sanitizedAction = null;
                      try {
                        sanitizedState = stateSanitizer(store.getState());
                        sanitizedAction = actionSanitizer(action);
                      } catch (err2) {
                        console.error(err2.toString());
                      }
                      if (sanitizedState && sanitizedAction) {
                        return {
                          storeId,
                          action: sanitizedAction,
                          duration,
                          stateDelta: sanitizedState
                        };
                      }
                      return null;
                    });
                  }
                  if (err) {
                    throw err;
                  }
                  return res;
                };
                return _objectSpread(_objectSpread({}, store), {}, {
                  dispatch
                });
              };
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-redux/src/createMiddleware.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = createMiddleware;
          var _now = _interopRequireDefault(__webpack_require__2("./packages/@apphub:now/src/index.js"));
          var storeIdCounter = 0;
          function createMiddleware(logger) {
            var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$stateSanitizer = _ref.stateSanitizer, stateSanitizer = _ref$stateSanitizer === void 0 ? function(f3) {
              return f3;
            } : _ref$stateSanitizer, _ref$actionSanitizer = _ref.actionSanitizer, actionSanitizer = _ref$actionSanitizer === void 0 ? function(f3) {
              return f3;
            } : _ref$actionSanitizer;
            return function(store) {
              var storeId = storeIdCounter++;
              logger.addEvent("lr.redux.InitialState", function() {
                var sanitizedState;
                try {
                  sanitizedState = stateSanitizer(store.getState());
                } catch (err) {
                  console.error(err.toString());
                }
                return {
                  state: sanitizedState,
                  storeId
                };
              });
              return function(next) {
                return function(action) {
                  var start = (0, _now.default)();
                  var err;
                  var res;
                  try {
                    res = next(action);
                  } catch (_err) {
                    err = _err;
                  } finally {
                    var duration = (0, _now.default)() - start;
                    logger.addEvent("lr.redux.ReduxAction", function() {
                      var sanitizedState = null;
                      var sanitizedAction = null;
                      try {
                        sanitizedState = stateSanitizer(store.getState());
                        sanitizedAction = actionSanitizer(action);
                      } catch (err2) {
                        console.error(err2.toString());
                      }
                      if (sanitizedState && sanitizedAction) {
                        return {
                          storeId,
                          action: sanitizedAction,
                          duration,
                          stateDelta: sanitizedState
                        };
                      }
                      return null;
                    });
                  }
                  if (err) {
                    throw err;
                  }
                  return res;
                };
              };
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-redux/src/index.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "createEnhancer", {
            enumerable: true,
            get: function get2() {
              return _createEnhancer.default;
            }
          });
          Object.defineProperty(exports2, "createMiddleware", {
            enumerable: true,
            get: function get2() {
              return _createMiddleware.default;
            }
          });
          var _createEnhancer = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-redux/src/createEnhancer.js"));
          var _createMiddleware = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-redux/src/createMiddleware.js"));
        },
        "./packages/@apphub:logrocket-utils/src/TraceKit.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          (function(global2) {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = void 0;
            var TraceKit = {
              collectWindowErrors: true,
              debug: false
            };
            var _window = typeof window !== "undefined" ? window : typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : {};
            var _slice = [].slice;
            var UNKNOWN_FUNCTION = "?";
            var ERROR_TYPES_RE = /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;
            function getLocationHref() {
              if (typeof document === "undefined" || typeof document.location === "undefined")
                return "";
              return document.location.href;
            }
            TraceKit.report = function reportModuleWrapper() {
              var handlers = [], lastArgs = null, lastException = null, lastExceptionStack = null;
              function subscribe4(handler) {
                installGlobalHandler();
                handlers.push(handler);
              }
              function unsubscribe(handler) {
                for (var i2 = handlers.length - 1; i2 >= 0; --i2) {
                  if (handlers[i2] === handler) {
                    handlers.splice(i2, 1);
                  }
                }
              }
              function unsubscribeAll() {
                uninstallGlobalHandler();
                handlers = [];
              }
              function notifyHandlers(stack, isWindowError) {
                var exception = null;
                if (isWindowError && !TraceKit.collectWindowErrors) {
                  return;
                }
                for (var i2 in handlers) {
                  if (handlers.hasOwnProperty(i2)) {
                    try {
                      handlers[i2].apply(null, [stack].concat(_slice.call(arguments, 2)));
                    } catch (inner) {
                      exception = inner;
                    }
                  }
                }
                if (exception) {
                  throw exception;
                }
              }
              var _oldOnerrorHandler, _onErrorHandlerInstalled;
              function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
                var stack = null;
                if (lastExceptionStack) {
                  TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
                  processLastException();
                } else if (ex) {
                  stack = TraceKit.computeStackTrace(ex);
                  notifyHandlers(stack, true);
                } else {
                  var location = {
                    "url": url,
                    "line": lineNo,
                    "column": colNo
                  };
                  var name = void 0;
                  var msg = message;
                  var groups;
                  if ({}.toString.call(message) === "[object String]") {
                    var groups = message.match(ERROR_TYPES_RE);
                    if (groups) {
                      name = groups[1];
                      msg = groups[2];
                    }
                  }
                  location.func = UNKNOWN_FUNCTION;
                  stack = {
                    "name": name,
                    "message": msg,
                    "url": getLocationHref(),
                    "stack": [location]
                  };
                  notifyHandlers(stack, true);
                }
                if (_oldOnerrorHandler) {
                  return _oldOnerrorHandler.apply(this, arguments);
                }
                return false;
              }
              function installGlobalHandler() {
                if (_onErrorHandlerInstalled) {
                  return;
                }
                _oldOnerrorHandler = _window.onerror;
                _window.onerror = traceKitWindowOnError;
                _onErrorHandlerInstalled = true;
              }
              function uninstallGlobalHandler() {
                if (!_onErrorHandlerInstalled) {
                  return;
                }
                _window.onerror = _oldOnerrorHandler;
                _onErrorHandlerInstalled = false;
                _oldOnerrorHandler = void 0;
              }
              function processLastException() {
                var _lastExceptionStack = lastExceptionStack, _lastArgs = lastArgs;
                lastArgs = null;
                lastExceptionStack = null;
                lastException = null;
                notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
              }
              function report(ex, rethrow) {
                var args = _slice.call(arguments, 1);
                if (lastExceptionStack) {
                  if (lastException === ex) {
                    return;
                  } else {
                    processLastException();
                  }
                }
                var stack = TraceKit.computeStackTrace(ex);
                lastExceptionStack = stack;
                lastException = ex;
                lastArgs = args;
                setTimeout(function() {
                  if (lastException === ex) {
                    processLastException();
                  }
                }, stack.incomplete ? 2e3 : 0);
                if (rethrow !== false) {
                  throw ex;
                }
              }
              report.subscribe = subscribe4;
              report.unsubscribe = unsubscribe;
              report.uninstall = unsubscribeAll;
              return report;
            }();
            TraceKit.computeStackTrace = function computeStackTraceWrapper() {
              function escapeRegExp(text) {
                return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, "\\$&");
              }
              function escapeCodeAsRegExpForMatchingInsideHTML(body) {
                return escapeRegExp(body).replace("<", "(?:<|&lt;)").replace(">", "(?:>|&gt;)").replace("&", "(?:&|&amp;)").replace('"', '(?:"|&quot;)').replace(/\s+/g, "\\s+");
              }
              function computeStackTraceFromStackProp(ex) {
                if (typeof ex.stack === "undefined" || !ex.stack)
                  return;
                var chrome2 = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|resource|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i, winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i, lines = ex.stack.split("\n"), stack = [], parts, element, reference = /^(.*) is undefined$/.exec(ex.message);
                for (var i2 = 0, j = lines.length; i2 < j; ++i2) {
                  if (parts = chrome2.exec(lines[i2])) {
                    var isNative = parts[2] && parts[2].indexOf("native") !== -1;
                    element = {
                      "url": !isNative ? parts[2] : null,
                      "func": parts[1] || UNKNOWN_FUNCTION,
                      "args": isNative ? [parts[2]] : [],
                      "line": parts[3] ? +parts[3] : null,
                      "column": parts[4] ? +parts[4] : null
                    };
                  } else if (parts = winjs.exec(lines[i2])) {
                    element = {
                      "url": parts[2],
                      "func": parts[1] || UNKNOWN_FUNCTION,
                      "args": [],
                      "line": +parts[3],
                      "column": parts[4] ? +parts[4] : null
                    };
                  } else if (parts = gecko.exec(lines[i2])) {
                    element = {
                      "url": parts[3],
                      "func": parts[1] || UNKNOWN_FUNCTION,
                      "args": parts[2] ? parts[2].split(",") : [],
                      "line": parts[4] ? +parts[4] : null,
                      "column": parts[5] ? +parts[5] : null
                    };
                  } else {
                    continue;
                  }
                  if (!element.func && element.line) {
                    element.func = UNKNOWN_FUNCTION;
                  }
                  stack.push(element);
                }
                if (!stack.length) {
                  return null;
                }
                if (!stack[0].column && typeof ex.columnNumber !== "undefined") {
                  stack[0].column = ex.columnNumber + 1;
                }
                return {
                  "name": ex.name,
                  "message": ex.message,
                  "url": getLocationHref(),
                  "stack": stack
                };
              }
              function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
                var initial = {
                  "url": url,
                  "line": lineNo
                };
                if (initial.url && initial.line) {
                  stackInfo.incomplete = false;
                  if (!initial.func) {
                    initial.func = UNKNOWN_FUNCTION;
                  }
                  if (stackInfo.stack.length > 0) {
                    if (stackInfo.stack[0].url === initial.url) {
                      if (stackInfo.stack[0].line === initial.line) {
                        return false;
                      } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                        stackInfo.stack[0].line = initial.line;
                        return false;
                      }
                    }
                  }
                  stackInfo.stack.unshift(initial);
                  stackInfo.partial = true;
                  return true;
                } else {
                  stackInfo.incomplete = true;
                }
                return false;
              }
              function computeStackTraceByWalkingCallerChain(ex, depth) {
                var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i, stack = [], funcs = {}, recursion = false, parts, item, source;
                for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
                  if (curr === computeStackTrace || curr === TraceKit.report) {
                    continue;
                  }
                  item = {
                    "url": null,
                    "func": UNKNOWN_FUNCTION,
                    "line": null,
                    "column": null
                  };
                  if (curr.name) {
                    item.func = curr.name;
                  } else if (parts = functionName.exec(curr.toString())) {
                    item.func = parts[1];
                  }
                  if (typeof item.func === "undefined") {
                    try {
                      item.func = parts.input.substring(0, parts.input.indexOf("{"));
                    } catch (e2) {
                    }
                  }
                  if (funcs["" + curr]) {
                    recursion = true;
                  } else {
                    funcs["" + curr] = true;
                  }
                  stack.push(item);
                }
                if (depth) {
                  stack.splice(0, depth);
                }
                var result = {
                  "name": ex.name,
                  "message": ex.message,
                  "url": getLocationHref(),
                  "stack": stack
                };
                augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
                return result;
              }
              function computeStackTrace(ex, depth) {
                var stack = null;
                depth = depth == null ? 0 : +depth;
                try {
                  stack = computeStackTraceFromStackProp(ex);
                  if (stack) {
                    return stack;
                  }
                } catch (e2) {
                  if (TraceKit.debug) {
                    throw e2;
                  }
                }
                try {
                  stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
                  if (stack) {
                    return stack;
                  }
                } catch (e2) {
                  if (TraceKit.debug) {
                    throw e2;
                  }
                }
                return {
                  "name": ex.name,
                  "message": ex.message,
                  "url": getLocationHref()
                };
              }
              computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
              computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;
              return computeStackTrace;
            }();
            var _default = TraceKit;
            exports2.default = _default;
            module3.exports = exports2.default;
          }).call(this, __webpack_require__2("./node_modules/webpack/buildin/global.js"));
        },
        "./packages/@apphub:logrocket-utils/src/constants/nps.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.DELIGHTED_FEEDBACK_PREFIX = exports2.DELIGHTED_RESPONSES_REGEX = exports2.WOOTRIC_RESPONSES_REGEX = void 0;
          var WOOTRIC_RESPONSES_REGEX = /^https:\/\/production.wootric.com\/responses/;
          exports2.WOOTRIC_RESPONSES_REGEX = WOOTRIC_RESPONSES_REGEX;
          var DELIGHTED_RESPONSES_REGEX = /^https:\/\/web.delighted.com\/e\/[a-zA-Z-]*\/c/;
          exports2.DELIGHTED_RESPONSES_REGEX = DELIGHTED_RESPONSES_REGEX;
          var DELIGHTED_FEEDBACK_PREFIX = "comment=";
          exports2.DELIGHTED_FEEDBACK_PREFIX = DELIGHTED_FEEDBACK_PREFIX;
        },
        "./packages/@apphub:logrocket-utils/src/enhanceFunc.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = enhanceFunc;
          function enhanceFunc(obj, method, handler) {
            var original = obj[method];
            function shim() {
              var res;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (original) {
                res = original.apply(this, args);
              }
              handler.apply(this, args);
              return res;
            }
            obj[method] = shim;
            return function() {
              obj[method] = original;
            };
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-utils/src/mapValues.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = mapValues;
          function mapValues(obj, f3) {
            if (obj == null) {
              return {};
            }
            var res = {};
            Object.keys(obj).forEach(function(key2) {
              res[key2] = f3(obj[key2]);
            });
            return res;
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:logrocket-utils/src/startsWith.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = startsWith;
          function startsWith(value, search) {
            var pos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            return value && search && value.substring(pos, pos + search.length) === search;
          }
          module3.exports = exports2.default;
        },
        "./packages/@apphub:now/src/index.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var dateNow = Date.now.bind(Date);
          var loadTime = dateNow();
          var _default = typeof performance !== "undefined" && performance.now ? performance.now.bind(performance) : function() {
            return dateNow() - loadTime;
          };
          exports2.default = _default;
          module3.exports = exports2.default;
        },
        "./packages/logrocket/src/LogRocket.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = exports2.MAX_QUEUE_SIZE = void 0;
          var _classCallCheck2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/classCallCheck.js"));
          var _createClass2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/createClass.js"));
          var _defineProperty2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/defineProperty.js"));
          var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));
          var _logrocketNetwork = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-network/src/index.js"));
          var _logrocketExceptions = __webpack_require__2("./packages/@apphub:logrocket-exceptions/src/index.js");
          var _logrocketConsole = _interopRequireDefault(__webpack_require__2("./packages/@apphub:logrocket-console/src/index.js"));
          var _logrocketRedux = __webpack_require__2("./packages/@apphub:logrocket-redux/src/index.js");
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              if (i2 % 2) {
                ownKeys(Object(source), true).forEach(function(key2) {
                  (0, _defineProperty2.default)(target, key2, source[key2]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key2) {
                  Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
                });
              }
            }
            return target;
          }
          var MAX_QUEUE_SIZE = 1e3;
          exports2.MAX_QUEUE_SIZE = MAX_QUEUE_SIZE;
          var considerIngestServerOption = function considerIngestServerOption2() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ingestServer = _ref.ingestServer, options = (0, _objectWithoutProperties2.default)(_ref, ["ingestServer"]);
            if (ingestServer) {
              return _objectSpread({
                serverURL: "".concat(ingestServer, "/i"),
                statsURL: "".concat(ingestServer, "/s")
              }, options);
            }
            return options;
          };
          var LogRocket2 = /* @__PURE__ */ function() {
            function LogRocket3() {
              var _this = this;
              (0, _classCallCheck2.default)(this, LogRocket3);
              this._buffer = [];
              ["log", "info", "warn", "error", "debug"].forEach(function(method) {
                _this[method] = function() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  _this.addEvent("lr.core.LogEvent", function() {
                    var consoleOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    if (method === "error" && consoleOptions.shouldAggregateConsoleErrors) {
                      _logrocketExceptions.Capture.captureMessage(_this, args[0], {}, true);
                    }
                    return {
                      logLevel: method.toUpperCase(),
                      args
                    };
                  }, {
                    shouldCaptureStackTrace: true
                  });
                };
              });
              this._isInitialized = false;
              this._installed = [];
              window._lr_surl_cb = this.getSessionURL.bind(this);
            }
            (0, _createClass2.default)(LogRocket3, [{
              key: "addEvent",
              value: function addEvent(type, getMessage) {
                var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var time = Date.now();
                this._run(function(logger) {
                  logger.addEvent(type, getMessage, _objectSpread(_objectSpread({}, opts), {}, {
                    timeOverride: time
                  }));
                });
              }
            }, {
              key: "onLogger",
              value: function onLogger(logger) {
                this._logger = logger;
                while (this._buffer.length > 0) {
                  var f3 = this._buffer.shift();
                  f3(this._logger);
                }
              }
            }, {
              key: "_run",
              value: function _run(f3) {
                if (this._isDisabled) {
                  return;
                }
                if (this._logger) {
                  f3(this._logger);
                } else {
                  if (this._buffer.length >= MAX_QUEUE_SIZE) {
                    this._isDisabled = true;
                    console.warn("LogRocket: script did not load. Check that you have a valid network connection.");
                    this.uninstall();
                    return;
                  }
                  this._buffer.push(f3.bind(this));
                }
              }
            }, {
              key: "init",
              value: function init3(appID) {
                var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (!this._isInitialized) {
                  var _opts$shouldAugmentNP = opts.shouldAugmentNPS, shouldAugmentNPS = _opts$shouldAugmentNP === void 0 ? true : _opts$shouldAugmentNP, _opts$shouldParseXHRB = opts.shouldParseXHRBlob, shouldParseXHRBlob = _opts$shouldParseXHRB === void 0 ? false : _opts$shouldParseXHRB;
                  this._installed.push((0, _logrocketExceptions.registerExceptions)(this));
                  this._installed.push((0, _logrocketNetwork.default)(this, {
                    shouldAugmentNPS: !!shouldAugmentNPS,
                    shouldParseXHRBlob: !!shouldParseXHRBlob
                  }));
                  this._installed.push((0, _logrocketConsole.default)(this));
                  this._isInitialized = true;
                  this._run(function(logger) {
                    logger.init(appID, considerIngestServerOption(opts));
                  });
                }
              }
            }, {
              key: "start",
              value: function start() {
                this._run(function(logger) {
                  logger.start();
                });
              }
            }, {
              key: "uninstall",
              value: function uninstall() {
                this._installed.forEach(function(f3) {
                  return f3();
                });
                this._buffer = [];
                this._run(function(logger) {
                  logger.uninstall();
                });
              }
            }, {
              key: "identify",
              value: function identify(id, opts) {
                this._run(function(logger) {
                  logger.identify(id, opts);
                });
              }
            }, {
              key: "startNewSession",
              value: function startNewSession() {
                this._run(function(logger) {
                  logger.startNewSession();
                });
              }
            }, {
              key: "track",
              value: function track(customEventName, eventProperties) {
                this._run(function(logger) {
                  logger.track(customEventName, eventProperties);
                });
              }
            }, {
              key: "getSessionURL",
              value: function getSessionURL(cb) {
                if (typeof cb !== "function") {
                  throw new Error("LogRocket: must pass callback to getSessionURL()");
                }
                this._run(function(logger) {
                  if (logger.getSessionURL) {
                    logger.getSessionURL(cb);
                  } else {
                    cb(logger.recordingURL);
                  }
                });
              }
            }, {
              key: "getVersion",
              value: function getVersion(cb) {
                this._run(function(logger) {
                  cb(logger.version);
                });
              }
            }, {
              key: "captureMessage",
              value: function captureMessage(message) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _logrocketExceptions.Capture.captureMessage(this, message, options);
              }
            }, {
              key: "captureException",
              value: function captureException(exception) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _logrocketExceptions.Capture.captureException(this, exception, options);
              }
            }, {
              key: "version",
              get: function get2() {
                return this._logger && this._logger.version;
              }
            }, {
              key: "sessionURL",
              get: function get2() {
                return this._logger && this._logger.recordingURL;
              }
            }, {
              key: "recordingURL",
              get: function get2() {
                return this._logger && this._logger.recordingURL;
              }
            }, {
              key: "recordingID",
              get: function get2() {
                return this._logger && this._logger.recordingID;
              }
            }, {
              key: "threadID",
              get: function get2() {
                return this._logger && this._logger.threadID;
              }
            }, {
              key: "tabID",
              get: function get2() {
                return this._logger && this._logger.tabID;
              }
            }, {
              key: "reduxEnhancer",
              value: function reduxEnhancer() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return (0, _logrocketRedux.createEnhancer)(this, options);
              }
            }, {
              key: "reduxMiddleware",
              value: function reduxMiddleware() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return (0, _logrocketRedux.createMiddleware)(this, options);
              }
            }, {
              key: "isDisabled",
              get: function get2() {
                return !!(this._isDisabled || this._logger && this._logger._isDisabled);
              }
            }]);
            return LogRocket3;
          }();
          exports2.default = LogRocket2;
        },
        "./packages/logrocket/src/makeLogRocket.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = makeLogRocket;
          var _LogRocket = _interopRequireDefault(__webpack_require__2("./packages/logrocket/src/LogRocket.js"));
          var REACT_NATIVE_NOTICE = "LogRocket does not yet support React Native.";
          var makeNoopPolyfill = function makeNoopPolyfill2() {
            return {
              init: function init3() {
              },
              uninstall: function uninstall() {
              },
              log: function log() {
              },
              info: function info() {
              },
              warn: function warn() {
              },
              error: function error2() {
              },
              debug: function debug() {
              },
              addEvent: function addEvent() {
              },
              identify: function identify() {
              },
              start: function start() {
              },
              get threadID() {
                return null;
              },
              get recordingID() {
                return null;
              },
              get recordingURL() {
                return null;
              },
              reduxEnhancer: function reduxEnhancer() {
                return function(store) {
                  return function() {
                    return store.apply(void 0, arguments);
                  };
                };
              },
              reduxMiddleware: function reduxMiddleware() {
                return function() {
                  return function(next) {
                    return function(action) {
                      return next(action);
                    };
                  };
                };
              },
              track: function track() {
              },
              getSessionURL: function getSessionURL() {
              },
              getVersion: function getVersion() {
              },
              startNewSession: function startNewSession() {
              },
              onLogger: function onLogger() {
              },
              setClock: function setClock() {
              },
              captureMessage: function captureMessage() {
              },
              captureException: function captureException() {
              }
            };
          };
          function makeLogRocket() {
            var getLogger = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
            };
            if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
              throw new Error(REACT_NATIVE_NOTICE);
            }
            if (typeof window !== "undefined") {
              if (window._disableLogRocket) {
                return makeNoopPolyfill();
              }
              if (window.MutationObserver && window.WeakMap) {
                window._lrMutationObserver = window.MutationObserver;
                var instance = new _LogRocket.default();
                getLogger(instance);
                return instance;
              }
            }
            return makeNoopPolyfill();
          }
          module3.exports = exports2.default;
        },
        "./packages/logrocket/src/module-npm.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _setup = _interopRequireDefault(__webpack_require__2("./packages/logrocket/src/setup.js"));
          var instance = (0, _setup.default)();
          var _default = instance;
          exports2.default = _default;
          module3.exports = exports2.default;
        },
        "./packages/logrocket/src/setup.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _interopRequireDefault = __webpack_require__2("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = setup;
          var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__2("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));
          var _makeLogRocket = _interopRequireDefault(__webpack_require__2("./packages/logrocket/src/makeLogRocket.js"));
          var CDN_SERVER_MAP = {
            "cdn.logrocket.io": "https://r.logrocket.io",
            "cdn.lr-ingest.io": "https://r.lr-ingest.io",
            "cdn.lr-in.com": "https://r.lr-in.com",
            "cdn-staging.logrocket.io": "https://staging-i.logrocket.io",
            "cdn-staging.lr-ingest.io": "https://staging-i.lr-ingest.io",
            "cdn-staging.lr-in.com": "https://staging-i.lr-in.com"
          };
          function setup() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, enterpriseServer = _ref.enterpriseServer, _ref$sdkVersion = _ref.sdkVersion, sdkVersion = _ref$sdkVersion === void 0 ? "2.2.0" : _ref$sdkVersion, opts = (0, _objectWithoutProperties2.default)(_ref, ["enterpriseServer", "sdkVersion"]);
            var scriptOrigin = void 0 === "staging" ? "https://cdn-staging.logrocket.io" : "https://cdn.logrocket.io";
            var scriptIngest;
            if (sdkVersion === "script") {
              try {
                var scriptTag = document.currentScript;
                var matches = scriptTag.src.match(/^(https?:\/\/([^\\]+))\/.+$/);
                var scriptHostname = matches && matches[2];
                if (scriptHostname && CDN_SERVER_MAP[scriptHostname]) {
                  scriptOrigin = matches && matches[1];
                  scriptIngest = CDN_SERVER_MAP[scriptHostname];
                }
              } catch (_) {
              }
            } else {
              scriptOrigin = void 0 === "staging" ? "https://cdn-staging.lr-in.com" : "https://cdn.lr-in.com";
              scriptIngest = void 0 === "staging" ? "https://staging-i.lr-in.com" : "https://r.lr-in.com";
            }
            var sdkServer = opts.sdkServer || enterpriseServer;
            var ingestServer = opts.ingestServer || enterpriseServer || scriptIngest;
            var instance = (0, _makeLogRocket.default)(function() {
              var script = document.createElement("script");
              if (ingestServer) {
                if (typeof window.__SDKCONFIG__ === "undefined") {
                  window.__SDKCONFIG__ = {};
                }
                window.__SDKCONFIG__.serverURL = "".concat(ingestServer, "/i");
                window.__SDKCONFIG__.statsURL = "".concat(ingestServer, "/s");
              }
              if (sdkServer) {
                script.src = "".concat(sdkServer, "/logger.min.js");
              } else if (window.__SDKCONFIG__ && window.__SDKCONFIG__.loggerURL) {
                script.src = window.__SDKCONFIG__.loggerURL;
              } else if (window._lrAsyncScript) {
                script.src = window._lrAsyncScript;
              } else {
                script.src = "".concat(scriptOrigin, "/logger-1.min.js");
              }
              script.async = true;
              document.head.appendChild(script);
              script.onload = function() {
                if (typeof window._LRLogger === "function") {
                  instance.onLogger(new window._LRLogger({
                    sdkVersion
                  }));
                } else {
                  console.warn("LogRocket: script execution has been blocked by a product or service.");
                  instance.uninstall();
                }
              };
              script.onerror = function() {
                console.warn("LogRocket: script could not load. Check that you have a valid network connection.");
                instance.uninstall();
              };
            });
            return instance;
          }
          module3.exports = exports2.default;
        },
        0: function(module3, exports2, __webpack_require__2) {
          module3.exports = __webpack_require__2("./packages/logrocket/src/module-npm.js");
        }
      });
    });
  }
});

// node_modules/theme-change/index.js
var require_theme_change = __commonJS({
  "node_modules/theme-change/index.js"(exports, module2) {
    function themeToggle() {
      var toggleEl = document.querySelector("[data-toggle-theme]");
      (function(theme = localStorage.getItem("theme")) {
        if (localStorage.getItem("theme")) {
          document.documentElement.setAttribute("data-theme", theme);
          if (toggleEl) {
            [...document.querySelectorAll("[data-toggle-theme]")].forEach((el) => {
              el.classList.add(toggleEl.getAttribute("data-act-class"));
            });
          }
        }
      })();
      if (toggleEl) {
        [...document.querySelectorAll("[data-toggle-theme]")].forEach((el) => {
          el.addEventListener("click", function() {
            var themesList = el.getAttribute("data-toggle-theme");
            if (themesList) {
              var themesArray = themesList.split(",");
              if (document.documentElement.getAttribute("data-theme") == themesArray[0]) {
                if (themesArray.length == 1) {
                  document.documentElement.removeAttribute("data-theme");
                  localStorage.removeItem("theme");
                } else {
                  document.documentElement.setAttribute("data-theme", themesArray[1]);
                  localStorage.setItem("theme", themesArray[1]);
                }
              } else {
                document.documentElement.setAttribute("data-theme", themesArray[0]);
                localStorage.setItem("theme", themesArray[0]);
              }
            }
            [...document.querySelectorAll("[data-toggle-theme]")].forEach((el2) => {
              el2.classList.toggle(this.getAttribute("data-act-class"));
            });
          });
        });
      }
    }
    function themeBtn() {
      (function(theme = localStorage.getItem("theme")) {
        if (theme != void 0 && theme != "") {
          if (localStorage.getItem("theme") && localStorage.getItem("theme") != "") {
            document.documentElement.setAttribute("data-theme", theme);
            var btnEl = document.querySelector("[data-set-theme='" + theme.toString() + "']");
            if (btnEl) {
              [...document.querySelectorAll("[data-set-theme]")].forEach((el) => {
                el.classList.remove(el.getAttribute("data-act-class"));
              });
              if (btnEl.getAttribute("data-act-class")) {
                btnEl.classList.add(btnEl.getAttribute("data-act-class"));
              }
            }
          } else {
            var btnEl = document.querySelector("[data-set-theme='']");
            if (btnEl.getAttribute("data-act-class")) {
              btnEl.classList.add(btnEl.getAttribute("data-act-class"));
            }
          }
        }
      })();
      [...document.querySelectorAll("[data-set-theme]")].forEach((el) => {
        el.addEventListener("click", function() {
          document.documentElement.setAttribute("data-theme", this.getAttribute("data-set-theme"));
          localStorage.setItem("theme", document.documentElement.getAttribute("data-theme"));
          [...document.querySelectorAll("[data-set-theme]")].forEach((el2) => {
            el2.classList.remove(el2.getAttribute("data-act-class"));
          });
          if (el.getAttribute("data-act-class")) {
            el.classList.add(el.getAttribute("data-act-class"));
          }
        });
      });
    }
    function themeSelect() {
      (function(theme = localStorage.getItem("theme")) {
        if (localStorage.getItem("theme")) {
          document.documentElement.setAttribute("data-theme", theme);
          var optionToggler = document.querySelector("select[data-choose-theme] [value='" + theme.toString() + "']");
          if (optionToggler) {
            [...document.querySelectorAll("select[data-choose-theme] [value='" + theme.toString() + "']")].forEach((el) => {
              el.selected = true;
            });
          }
        }
      })();
      if (document.querySelector("select[data-choose-theme]")) {
        [...document.querySelectorAll("select[data-choose-theme]")].forEach((el) => {
          el.addEventListener("change", function() {
            document.documentElement.setAttribute("data-theme", this.value);
            localStorage.setItem("theme", document.documentElement.getAttribute("data-theme"));
            [...document.querySelectorAll("select[data-choose-theme] [value='" + localStorage.getItem("theme") + "']")].forEach((el2) => {
              el2.selected = true;
            });
          });
        });
      }
    }
    function themeChange(attach = true) {
      if (attach === true) {
        document.addEventListener("DOMContentLoaded", function(event) {
          themeToggle();
          themeSelect();
          themeBtn();
        });
      } else {
        themeToggle();
        themeSelect();
        themeBtn();
      }
    }
    if (typeof exports != "undefined") {
      module2.exports = { themeChange };
    } else {
      themeChange();
    }
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils5 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f3) {
      if (typeof f3 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f3;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i2 = 0; i2 < length; i2++) {
          this.putBit((num >>> length - i2 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module2) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved2) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved2)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils5().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j = 0; j < posLength; j++) {
          if (i2 === 0 && j === 0 || i2 === 0 && j === posLength - 1 || i2 === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils5().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++)
        darkCount += data.data[i2];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i2, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i2 + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j % 2 + i2 * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j % 2 + i2 * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j % 3 + (i2 + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x2 = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x2;
        LOG_TABLE[x2] = i2;
        x2 <<= 1;
        if (x2 & 256) {
          x2 ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1)
        throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x2, y) {
      if (x2 === 0 || y === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i2 + j] ^= GF.mul(p1[i2], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module2) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode2 = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version7 = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils5();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode2();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version << 12 | d;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils5();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module2) {
    var Mode = require_mode2();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i2, group, value;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group = this.data.substr(i2, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group = this.data.substr(i2);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module2) {
    var Mode = require_mode2();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports, module2) {
    "use strict";
    module2.exports = function encodeUtf8(input) {
      var result = [];
      var size = input.length;
      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);
        if (point >= 55296 && point <= 56319 && size > index + 1) {
          var second = input.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        }
        if (point < 55296 || point >= 57344 && point < 65536) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module2) {
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode2();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = new Uint8Array(encodeUtf8(data));
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l = this.data.length; i2 < l; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module2) {
    var Mode = require_mode2();
    var Utils = require_utils5();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value = Utils.toSJIS(this.data[i2]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error("Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8");
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s3, d) {
        var predecessors = {};
        var costs = {};
        costs[s3] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s3, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s3, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        var predecessor;
        while (u) {
          nodes.push(u);
          predecessor = predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s3, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s3, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
      },
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra.PriorityQueue, t2 = {}, key2;
          opts = opts || {};
          for (key2 in T) {
            if (T.hasOwnProperty(key2)) {
              t2[key2] = T[key2];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T.default_sorter;
          return t2;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments2 = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode2();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils5();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup = nodes[i2];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key2 = "" + i2 + j;
          currentNodeIds.push(key2);
          table[key2] = { node, lastCount: 0 };
          graph[key2] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path.length - 1; i2++) {
        optimizedSegs.push(graph.table[path[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils5();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version7();
    var FormatInfo = require_format_info();
    var Mode = require_mode2();
    var Segments = require_segments2();
    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r2 = -1; r2 <= 7; r2++) {
          if (row + r2 <= -1 || size <= row + r2)
            continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c)
              continue;
            if (r2 >= 0 && r2 <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r2, col + c, true, true);
            } else {
              matrix.set(row + r2, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r2 = 8; r2 < size - 8; r2++) {
        const value = r2 % 2 === 0;
        matrix.set(r2, 6, value, true);
        matrix.set(6, r2, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r2 = -2; r2 <= 2; r2++) {
          for (let c = -2; c <= 2; c++) {
            if (r2 === -2 || r2 === 2 || c === -2 || c === 2 || r2 === 0 && c === 0) {
              matrix.set(row + r2, col + c, true, true);
            } else {
              matrix.set(row + r2, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size - 8 - 3;
        mod = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod;
      for (i2 = 0; i2 < 15; i2++) {
        mod = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i2, 8, mod, true);
        }
        if (i2 < 8) {
          matrix.set(8, size - i2 - 1, mod, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i2, r2;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r2 = 0; r2 < ecTotalBlocks; r2++) {
          if (i2 < dcData[r2].length) {
            data[index++] = dcData[r2][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r2 = 0; r2 < ecTotalBlocks; r2++) {
          data[index++] = ecData[r2][i2];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read2) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read2.length) {
        this._buffered -= read2.length;
        this._buffers[0] = smallerBuf.slice(read2.length);
        read2.func.call(this, smallerBuf.slice(0, read2.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read2.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read2) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read2.length);
      while (pos < read2.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read2.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read2.length;
      read2.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read2 = this._reads[0];
          if (read2.allowLess) {
            this._processReadAllowingLess(read2);
          } else if (this._buffered >= read2.length) {
            this._processRead(read2);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i2 = 0; i2 < imagePasses.length; i2++) {
        let pass = imagePasses[i2];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i2 });
        }
      }
      return images;
    };
    exports.getInterlaceIterator = function(width) {
      return function(x2, y, pass) {
        let outerXLeftOver = x2 % imagePasses[pass].x.length;
        let outerX = (x2 - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i2 = 0; i2 < passes.length; i2++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i2].width, bpp, depth),
            height: passes[i2].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f1Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        unfilteredLine[x2] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f2Up = lastLine ? lastLine[x2] : 0;
        unfilteredLine[x2] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f3Up = lastLine ? lastLine[x2] : 0;
        let f3Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x2] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f4Up = lastLine ? lastLine[x2] : 0;
        let f4Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        let f4UpLeft = x2 > xBiggerThan && lastLine ? lastLine[x2 - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x2] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants9 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i2 = 0; i2 < 256; i2++) {
        let currentCrc = i2;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i2] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i2 = 0; i2 < data.length; i2++) {
        this._crc = crcTable[(this._crc ^ data[i2]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i2 = 0; i2 < buf.length; i2++) {
        crc = crcTable[(crc ^ buf[i2]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser4 = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports, module2) {
    "use strict";
    var constants = require_constants9();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i2 = 0; i2 < signature.length; i2++) {
        if (data[i2] !== signature[i2]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i2 = 4; i2 < 8; i2++) {
        name += String.fromCharCode(data[i2]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i2 = 0; i2 < entries; i2++) {
        this._palette.push([data[i2 * 3], data[i2 * 3 + 1], data[i2 * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i2 = 0; i2 < data.length; i2++) {
          this._palette[i2][3] = data[i2];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i2 = 0;
      function split2() {
        if (i2 === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i2];
        i2++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i2];
            i2++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split2();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i2 !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x2 = 0; x2 < imageWidth; x2++) {
          let pxPos = getPxPos(x2, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x2 = 0; x2 < imageWidth; x2++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x2, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = color[i2];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i2 = 0; i2 < 4; i2++) {
              outdata[pxPos + i2] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = Math.floor(indata[pxPos + i2] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var zlib2 = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser4();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports, module2) {
    "use strict";
    var constants = require_constants9();
    module2.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        rawData[rawPos + x2] = pxData[pxPos + x2];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i2 = pxPos; i2 < length; i2++) {
        sum += Math.abs(pxData[i2]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let val = pxData[pxPos + x2] - left;
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let val = pxData[pxPos + x2] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - up;
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x2 = pxPos; x2 < length; x2++) {
        let up = pxPos > 0 ? pxData[x2 - byteWidth] : 0;
        let val = pxData[x2] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - (left + up >> 1);
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i2 = 0; i2 < filterTypes.length; i2++) {
            let sum = filterSums[filterTypes[i2]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i2];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports, module2) {
    "use strict";
    var constants = require_constants9();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib2.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var constants = require_constants9();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream2.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib2 = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error2;
      this.on("error", function(err) {
        error2 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error2;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read2 = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read2.length || read2.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read2.length);
          read2.func.call(this, buf.slice(0, read2.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser4();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants9();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports.PNG = function(options) {
      Stream2.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x2 = 0; x2 < src.width; x2++) {
            let idx = src.width * y + x2 << 2;
            for (let i2 = 0; i2 < 3; i2++) {
              let sample = src.data[idx + i2] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i2] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils6 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i2 = 0; i2 < symbolSize; i2++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i2 * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i2 >= scaledMargin && j >= scaledMargin && i2 < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i2 - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/png.js
var require_png2 = __commonJS({
  "node_modules/qrcode/lib/renderer/png.js"(exports) {
    var fs = require("fs");
    var PNG = require_png().PNG;
    var Utils = require_utils6();
    exports.render = function render(qrData, options) {
      const opts = Utils.getOptions(options);
      const pngOpts = opts.rendererOpts;
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      pngOpts.width = size;
      pngOpts.height = size;
      const pngImage = new PNG(pngOpts);
      Utils.qrToImageData(pngImage.data, qrData, opts);
      return pngImage;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      exports.renderToBuffer(qrData, options, function(err, output) {
        if (err)
          cb(err);
        let url = "data:image/png;base64,";
        url += output.toString("base64");
        cb(null, url);
      });
    };
    exports.renderToBuffer = function renderToBuffer(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const png = exports.render(qrData, options);
      const buffer = [];
      png.on("error", cb);
      png.on("data", function(data) {
        buffer.push(data);
      });
      png.on("end", function() {
        cb(null, Buffer.concat(buffer));
      });
      png.pack();
    };
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      let called = false;
      const done = (...args) => {
        if (called)
          return;
        called = true;
        cb.apply(null, args);
      };
      const stream = fs.createWriteStream(path);
      stream.on("error", done);
      stream.on("close", done);
      exports.renderToFileStream(stream, qrData, options);
    };
    exports.renderToFileStream = function renderToFileStream(stream, qrData, options) {
      const png = exports.render(qrData, options);
      png.pack().pipe(stream);
    };
  }
});

// node_modules/qrcode/lib/renderer/utf8.js
var require_utf8 = __commonJS({
  "node_modules/qrcode/lib/renderer/utf8.js"(exports) {
    var Utils = require_utils6();
    var BLOCK_CHAR = {
      WW: " ",
      WB: "\u2584",
      BB: "\u2588",
      BW: "\u2580"
    };
    var INVERTED_BLOCK_CHAR = {
      BB: " ",
      BW: "\u2584",
      WW: "\u2588",
      WB: "\u2580"
    };
    function getBlockChar(top, bottom, blocks) {
      if (top && bottom)
        return blocks.BB;
      if (top && !bottom)
        return blocks.BW;
      if (!top && bottom)
        return blocks.WB;
      return blocks.WW;
    }
    exports.render = function(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      let blocks = BLOCK_CHAR;
      if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") {
        blocks = INVERTED_BLOCK_CHAR;
      }
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      let output = "";
      let hMargin = Array(size + opts.margin * 2 + 1).join(blocks.WW);
      hMargin = Array(opts.margin / 2 + 1).join(hMargin + "\n");
      const vMargin = Array(opts.margin + 1).join(blocks.WW);
      output += hMargin;
      for (let i2 = 0; i2 < size; i2 += 2) {
        output += vMargin;
        for (let j = 0; j < size; j++) {
          const topModule = data[i2 * size + j];
          const bottomModule = data[(i2 + 1) * size + j];
          output += getBlockChar(topModule, bottomModule, blocks);
        }
        output += vMargin + "\n";
      }
      output += hMargin.slice(0, -1);
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const fs = require("fs");
      const utf8 = exports.render(qrData, options);
      fs.writeFile(path, utf8, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal/terminal.js
var require_terminal = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal/terminal.js"(exports) {
    exports.render = function(qrData, options, cb) {
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const black = "\x1B[40m  \x1B[0m";
      const white = "\x1B[47m  \x1B[0m";
      let output = "";
      const hMargin = Array(size + 3).join(white);
      const vMargin = Array(2).join(white);
      output += hMargin + "\n";
      for (let i2 = 0; i2 < size; ++i2) {
        output += white;
        for (let j = 0; j < size; j++) {
          output += data[i2 * size + j] ? black : white;
        }
        output += vMargin + "\n";
      }
      output += hMargin + "\n";
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal/terminal-small.js
var require_terminal_small = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal/terminal-small.js"(exports) {
    var backgroundWhite = "\x1B[47m";
    var backgroundBlack = "\x1B[40m";
    var foregroundWhite = "\x1B[37m";
    var foregroundBlack = "\x1B[30m";
    var reset = "\x1B[0m";
    var lineSetupNormal = backgroundWhite + foregroundBlack;
    var lineSetupInverse = backgroundBlack + foregroundWhite;
    var createPalette = function(lineSetup, foregroundWhite2, foregroundBlack2) {
      return {
        "00": reset + " " + lineSetup,
        "01": reset + foregroundWhite2 + "\u2584" + lineSetup,
        "02": reset + foregroundBlack2 + "\u2584" + lineSetup,
        10: reset + foregroundWhite2 + "\u2580" + lineSetup,
        11: " ",
        12: "\u2584",
        20: reset + foregroundBlack2 + "\u2580" + lineSetup,
        21: "\u2580",
        22: "\u2588"
      };
    };
    var mkCodePixel = function(modules, size, x2, y) {
      const sizePlus = size + 1;
      if (x2 >= sizePlus || y >= sizePlus || y < -1 || x2 < -1)
        return "0";
      if (x2 >= size || y >= size || y < 0 || x2 < 0)
        return "1";
      const idx = y * size + x2;
      return modules[idx] ? "2" : "1";
    };
    var mkCode = function(modules, size, x2, y) {
      return mkCodePixel(modules, size, x2, y) + mkCodePixel(modules, size, x2, y + 1);
    };
    exports.render = function(qrData, options, cb) {
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const inverse = !!(options && options.inverse);
      const lineSetup = options && options.inverse ? lineSetupInverse : lineSetupNormal;
      const white = inverse ? foregroundBlack : foregroundWhite;
      const black = inverse ? foregroundWhite : foregroundBlack;
      const palette = createPalette(lineSetup, white, black);
      const newLine = reset + "\n" + lineSetup;
      let output = lineSetup;
      for (let y = -1; y < size + 1; y += 2) {
        for (let x2 = -1; x2 < size; x2++) {
          output += palette[mkCode(data, size, x2, y)];
        }
        output += palette[mkCode(data, size, size, y)] + newLine;
      }
      output += reset;
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal.js
var require_terminal2 = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal.js"(exports) {
    var big = require_terminal();
    var small = require_terminal_small();
    exports.render = function(qrData, options, cb) {
      if (options && options.small) {
        return small.render(qrData, options, cb);
      }
      return big.render(qrData, options, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils6();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x2, y) {
      let str = cmd + x2;
      if (typeof y !== "undefined")
        str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i2 = 0; i2 < data.length; i2++) {
        const col = Math.floor(i2 % size);
        const row = Math.floor(i2 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i2]) {
          lineLength++;
          if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i2 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/renderer/svg.js
var require_svg = __commonJS({
  "node_modules/qrcode/lib/renderer/svg.js"(exports) {
    var svgTagRenderer = require_svg_tag();
    exports.render = svgTagRenderer.render;
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const fs = require("fs");
      const svgTag = exports.render(qrData, options);
      const xmlStr = '<?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' + svgTag;
      fs.writeFile(path, xmlStr, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils6();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve2, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve2(renderFunc(data, canvas, opts));
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e2) {
        cb(e2);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/qrcode/lib/server.js
var require_server = __commonJS({
  "node_modules/qrcode/lib/server.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var PngRenderer = require_png2();
    var Utf8Renderer = require_utf8();
    var TerminalRenderer = require_terminal2();
    var SvgRenderer = require_svg();
    function checkParams(text, opts, cb) {
      if (typeof text === "undefined") {
        throw new Error("String required as first argument");
      }
      if (typeof cb === "undefined") {
        cb = opts;
        opts = {};
      }
      if (typeof cb !== "function") {
        if (!canPromise()) {
          throw new Error("Callback required as last argument");
        } else {
          opts = cb || {};
          cb = null;
        }
      }
      return {
        opts,
        cb
      };
    }
    function getTypeFromFilename(path) {
      return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
    }
    function getRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "txt":
        case "utf8":
          return Utf8Renderer;
        case "png":
        case "image/png":
        default:
          return PngRenderer;
      }
    }
    function getStringRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "terminal":
          return TerminalRenderer;
        case "utf8":
        default:
          return Utf8Renderer;
      }
    }
    function render(renderFunc, text, params) {
      if (!params.cb) {
        return new Promise(function(resolve2, reject) {
          try {
            const data = QRCode.create(text, params.opts);
            return renderFunc(data, params.opts, function(err, data2) {
              return err ? reject(err) : resolve2(data2);
            });
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode.create(text, params.opts);
        return renderFunc(data, params.opts, params.cb);
      } catch (e2) {
        params.cb(e2);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = require_browser3().toCanvas;
    exports.toString = function toString(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const type = params.opts ? params.opts.type : void 0;
      const renderer = getStringRendererFromType(type);
      return render(renderer.render, text, params);
    };
    exports.toDataURL = function toDataURL(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToDataURL, text, params);
    };
    exports.toBuffer = function toBuffer(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToBuffer, text, params);
    };
    exports.toFile = function toFile(path, text, opts, cb) {
      if (typeof path !== "string" || !(typeof text === "string" || typeof text === "object")) {
        throw new Error("Invalid argument");
      }
      if (arguments.length < 3 && !canPromise()) {
        throw new Error("Too few arguments provided");
      }
      const params = checkParams(text, opts, cb);
      const type = params.opts.type || getTypeFromFilename(path);
      const renderer = getRendererFromType(type);
      const renderToFile = renderer.renderToFile.bind(null, path);
      return render(renderToFile, text, params);
    };
    exports.toFileStream = function toFileStream(stream, text, opts) {
      if (arguments.length < 2) {
        throw new Error("Too few arguments provided");
      }
      const params = checkParams(text, opts, stream.emit.bind(stream, "error"));
      const renderer = getRendererFromType("png");
      const renderToFileStream = renderer.renderToFileStream.bind(null, stream);
      render(renderToFileStream, text, params);
    };
  }
});

// node_modules/qrcode/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/qrcode/lib/index.js"(exports, module2) {
    module2.exports = require_server();
  }
});

// node_modules/@sentry/browser/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/@sentry/browser/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory2(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key2, r2) : d(target, key2)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f3 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __exportStar = function(m2, exports2) {
        for (var p in m2)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m2[p];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o[s3], i2 = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i2 = m2.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v) {
          if (f3(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f3) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f3 ? f3(v) : v;
          } : f3;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/types/dist/severity.js
var require_severity = __commonJS({
  "node_modules/@sentry/types/dist/severity.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var Severity;
    (function(Severity2) {
      Severity2["Fatal"] = "fatal";
      Severity2["Error"] = "error";
      Severity2["Warning"] = "warning";
      Severity2["Log"] = "log";
      Severity2["Info"] = "info";
      Severity2["Debug"] = "debug";
      Severity2["Critical"] = "critical";
    })(Severity = exports.Severity || (exports.Severity = {}));
    exports.SeverityLevels = ["fatal", "error", "warning", "log", "info", "debug", "critical"];
  }
});

// node_modules/@sentry/types/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sentry/types/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var severity_1 = require_severity();
    exports.Severity = severity_1.Severity;
    var severity_2 = require_severity();
    exports.SeverityLevels = severity_2.SeverityLevels;
  }
});

// node_modules/@sentry/minimal/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "node_modules/@sentry/minimal/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory2(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key2, r2) : d(target, key2)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f3 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __exportStar = function(m2, exports2) {
        for (var p in m2)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m2[p];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o[s3], i2 = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i2 = m2.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v) {
          if (f3(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f3) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f3 ? f3(v) : v;
          } : f3;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/hub/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS({
  "node_modules/@sentry/hub/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory2(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key2, r2) : d(target, key2)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f3 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __exportStar = function(m2, exports2) {
        for (var p in m2)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m2[p];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o[s3], i2 = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i2 = m2.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v) {
          if (f3(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f3) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f3 ? f3(v) : v;
          } : f3;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/utils/node_modules/tslib/tslib.js
var require_tslib4 = __commonJS({
  "node_modules/@sentry/utils/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory2(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key2, r2) : d(target, key2)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f3 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __exportStar = function(m2, exports2) {
        for (var p in m2)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m2[p];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o[s3], i2 = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i2 = m2.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v) {
          if (f3(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f3) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f3 ? f3(v) : v;
          } : f3;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/utils/dist/async.js
var require_async = __commonJS({
  "node_modules/@sentry/utils/dist/async.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function forget(promise) {
      void promise.then(null, function(e2) {
        console.error(e2);
      });
    }
    exports.forget = forget;
  }
});

// node_modules/@sentry/utils/dist/env.js
var require_env = __commonJS({
  "node_modules/@sentry/utils/dist/env.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDebugBuild() {
      return typeof __SENTRY_NO_DEBUG__ !== "undefined" && !__SENTRY_BROWSER_BUNDLE__;
    }
    exports.isDebugBuild = isDebugBuild;
    function isBrowserBundle() {
      return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
    }
    exports.isBrowserBundle = isBrowserBundle;
  }
});

// node_modules/@sentry/utils/dist/node.js
var require_node25 = __commonJS({
  "node_modules/@sentry/utils/dist/node.js"(exports, module2) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var env_1 = require_env();
    function isNodeEnv() {
      return !env_1.isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    }
    exports.isNodeEnv = isNodeEnv;
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    exports.dynamicRequire = dynamicRequire;
    function loadModule(moduleName) {
      var mod;
      try {
        mod = dynamicRequire(module2, moduleName);
      } catch (e2) {
      }
      try {
        var cwd = dynamicRequire(module2, "process").cwd;
        mod = dynamicRequire(module2, cwd() + "/node_modules/" + moduleName);
      } catch (e2) {
      }
      return mod;
    }
    exports.loadModule = loadModule;
  }
});

// node_modules/@sentry/utils/dist/global.js
var require_global = __commonJS({
  "node_modules/@sentry/utils/dist/global.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_1 = require_node25();
    var fallbackGlobalObject = {};
    function getGlobalObject() {
      return node_1.isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
    }
    exports.getGlobalObject = getGlobalObject;
  }
});

// node_modules/@sentry/utils/dist/is.js
var require_is = __commonJS({
  "node_modules/@sentry/utils/dist/is.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var objectToString = Object.prototype.toString;
    function isError(wat) {
      switch (objectToString.call(wat)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    exports.isError = isError;
    function isBuiltin(wat, ty) {
      return objectToString.call(wat) === "[object " + ty + "]";
    }
    function isErrorEvent(wat) {
      return isBuiltin(wat, "ErrorEvent");
    }
    exports.isErrorEvent = isErrorEvent;
    function isDOMError(wat) {
      return isBuiltin(wat, "DOMError");
    }
    exports.isDOMError = isDOMError;
    function isDOMException(wat) {
      return isBuiltin(wat, "DOMException");
    }
    exports.isDOMException = isDOMException;
    function isString(wat) {
      return isBuiltin(wat, "String");
    }
    exports.isString = isString;
    function isPrimitive2(wat) {
      return wat === null || typeof wat !== "object" && typeof wat !== "function";
    }
    exports.isPrimitive = isPrimitive2;
    function isPlainObject(wat) {
      return isBuiltin(wat, "Object");
    }
    exports.isPlainObject = isPlainObject;
    function isEvent(wat) {
      return typeof Event !== "undefined" && isInstanceOf(wat, Event);
    }
    exports.isEvent = isEvent;
    function isElement(wat) {
      return typeof Element !== "undefined" && isInstanceOf(wat, Element);
    }
    exports.isElement = isElement;
    function isRegExp(wat) {
      return isBuiltin(wat, "RegExp");
    }
    exports.isRegExp = isRegExp;
    function isThenable(wat) {
      return Boolean(wat && wat.then && typeof wat.then === "function");
    }
    exports.isThenable = isThenable;
    function isSyntheticEvent(wat) {
      return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
    }
    exports.isSyntheticEvent = isSyntheticEvent;
    function isInstanceOf(wat, base2) {
      try {
        return wat instanceof base2;
      } catch (_e) {
        return false;
      }
    }
    exports.isInstanceOf = isInstanceOf;
  }
});

// node_modules/@sentry/utils/dist/browser.js
var require_browser4 = __commonJS({
  "node_modules/@sentry/utils/dist/browser.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var global_1 = require_global();
    var is_1 = require_is();
    function htmlTreeAsString(elem, keyAttrs) {
      try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = " > ";
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
            break;
          }
          out.push(nextStr);
          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    exports.htmlTreeAsString = htmlTreeAsString;
    function _htmlElementAsString(el, keyAttrs) {
      var elem = el;
      var out = [];
      var className;
      var classes;
      var key2;
      var attr;
      var i2;
      if (!elem || !elem.tagName) {
        return "";
      }
      out.push(elem.tagName.toLowerCase());
      var keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter(function(keyAttr) {
        return elem.getAttribute(keyAttr);
      }).map(function(keyAttr) {
        return [keyAttr, elem.getAttribute(keyAttr)];
      }) : null;
      if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach(function(keyAttrPair) {
          out.push("[" + keyAttrPair[0] + '="' + keyAttrPair[1] + '"]');
        });
      } else {
        if (elem.id) {
          out.push("#" + elem.id);
        }
        className = elem.className;
        if (className && is_1.isString(className)) {
          classes = className.split(/\s+/);
          for (i2 = 0; i2 < classes.length; i2++) {
            out.push("." + classes[i2]);
          }
        }
      }
      var allowedAttrs = ["type", "name", "title", "alt"];
      for (i2 = 0; i2 < allowedAttrs.length; i2++) {
        key2 = allowedAttrs[i2];
        attr = elem.getAttribute(key2);
        if (attr) {
          out.push("[" + key2 + '="' + attr + '"]');
        }
      }
      return out.join("");
    }
    function getLocationHref() {
      var global2 = global_1.getGlobalObject();
      try {
        return global2.document.location.href;
      } catch (oO) {
        return "";
      }
    }
    exports.getLocationHref = getLocationHref;
  }
});

// node_modules/@sentry/utils/dist/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/@sentry/utils/dist/polyfill.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/@sentry/utils/dist/error.js
var require_error = __commonJS({
  "node_modules/@sentry/utils/dist/error.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    var polyfill_1 = require_polyfill();
    var SentryError = function(_super) {
      tslib_1.__extends(SentryError2, _super);
      function SentryError2(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _newTarget.prototype.constructor.name;
        polyfill_1.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
      }
      return SentryError2;
    }(Error);
    exports.SentryError = SentryError;
  }
});

// node_modules/@sentry/utils/dist/dsn.js
var require_dsn = __commonJS({
  "node_modules/@sentry/utils/dist/dsn.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    var env_1 = require_env();
    var error_1 = require_error();
    var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function isValidProtocol(protocol) {
      return protocol === "http" || protocol === "https";
    }
    function dsnToString(dsn, withPassword) {
      if (withPassword === void 0) {
        withPassword = false;
      }
      var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
      return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path ? path + "/" : path) + projectId);
    }
    exports.dsnToString = dsnToString;
    function dsnFromString(str) {
      var match = DSN_REGEX.exec(str);
      if (!match) {
        throw new error_1.SentryError("Invalid Sentry Dsn: " + str);
      }
      var _a4 = tslib_1.__read(match.slice(1), 6), protocol = _a4[0], publicKey = _a4[1], _b = _a4[2], pass = _b === void 0 ? "" : _b, host = _a4[3], _c = _a4[4], port = _c === void 0 ? "" : _c, lastPath = _a4[5];
      var path = "";
      var projectId = lastPath;
      var split2 = projectId.split("/");
      if (split2.length > 1) {
        path = split2.slice(0, -1).join("/");
        projectId = split2.pop();
      }
      if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
    }
    function dsnFromComponents(components) {
      if ("user" in components && !("publicKey" in components)) {
        components.publicKey = components.user;
      }
      return {
        user: components.publicKey || "",
        protocol: components.protocol,
        publicKey: components.publicKey || "",
        pass: components.pass || "",
        host: components.host,
        port: components.port || "",
        path: components.path || "",
        projectId: components.projectId
      };
    }
    function validateDsn(dsn) {
      if (!env_1.isDebugBuild()) {
        return;
      }
      var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
      var requiredComponents = ["protocol", "publicKey", "host", "projectId"];
      requiredComponents.forEach(function(component) {
        if (!dsn[component]) {
          throw new error_1.SentryError("Invalid Sentry Dsn: " + component + " missing");
        }
      });
      if (!projectId.match(/^\d+$/)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
      }
      if (!isValidProtocol(protocol)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
      }
      if (port && isNaN(parseInt(port, 10))) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid port " + port);
      }
      return true;
    }
    function makeDsn(from) {
      var components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
      validateDsn(components);
      return components;
    }
    exports.makeDsn = makeDsn;
  }
});

// node_modules/@sentry/utils/dist/enums.js
var require_enums = __commonJS({
  "node_modules/@sentry/utils/dist/enums.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SeverityLevels = ["fatal", "error", "warning", "log", "info", "debug", "critical"];
  }
});

// node_modules/@sentry/utils/dist/logger.js
var require_logger2 = __commonJS({
  "node_modules/@sentry/utils/dist/logger.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var global_1 = require_global();
    var global2 = global_1.getGlobalObject();
    var PREFIX = "Sentry Logger ";
    function consoleSandbox(callback) {
      var global3 = global_1.getGlobalObject();
      var levels = ["debug", "info", "warn", "error", "log", "assert"];
      if (!("console" in global3)) {
        return callback();
      }
      var originalConsole = global3.console;
      var wrappedLevels = {};
      levels.forEach(function(level) {
        if (level in global3.console && originalConsole[level].__sentry_original__) {
          wrappedLevels[level] = originalConsole[level];
          originalConsole[level] = originalConsole[level].__sentry_original__;
        }
      });
      var result = callback();
      Object.keys(wrappedLevels).forEach(function(level) {
        originalConsole[level] = wrappedLevels[level];
      });
      return result;
    }
    exports.consoleSandbox = consoleSandbox;
    var Logger = function() {
      function Logger2() {
        this._enabled = false;
      }
      Logger2.prototype.disable = function() {
        this._enabled = false;
      };
      Logger2.prototype.enable = function() {
        this._enabled = true;
      };
      Logger2.prototype.log = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._enabled) {
          return;
        }
        consoleSandbox(function() {
          global2.console.log(PREFIX + "[Log]: " + args.join(" "));
        });
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._enabled) {
          return;
        }
        consoleSandbox(function() {
          global2.console.warn(PREFIX + "[Warn]: " + args.join(" "));
        });
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._enabled) {
          return;
        }
        consoleSandbox(function() {
          global2.console.error(PREFIX + "[Error]: " + args.join(" "));
        });
      };
      return Logger2;
    }();
    global2.__SENTRY__ = global2.__SENTRY__ || {};
    var logger = global2.__SENTRY__.logger || (global2.__SENTRY__.logger = new Logger());
    exports.logger = logger;
  }
});

// node_modules/@sentry/utils/dist/memo.js
var require_memo = __commonJS({
  "node_modules/@sentry/utils/dist/memo.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoBuilder() {
      var hasWeakSet = typeof WeakSet === "function";
      var inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
      function memoize(obj) {
        if (hasWeakSet) {
          if (inner.has(obj)) {
            return true;
          }
          inner.add(obj);
          return false;
        }
        for (var i2 = 0; i2 < inner.length; i2++) {
          var value = inner[i2];
          if (value === obj) {
            return true;
          }
        }
        inner.push(obj);
        return false;
      }
      function unmemoize(obj) {
        if (hasWeakSet) {
          inner.delete(obj);
        } else {
          for (var i2 = 0; i2 < inner.length; i2++) {
            if (inner[i2] === obj) {
              inner.splice(i2, 1);
              break;
            }
          }
        }
      }
      return [memoize, unmemoize];
    }
    exports.memoBuilder = memoBuilder;
  }
});

// node_modules/@sentry/utils/dist/stacktrace.js
var require_stacktrace = __commonJS({
  "node_modules/@sentry/utils/dist/stacktrace.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    var STACKTRACE_LIMIT = 50;
    function createStackParser() {
      var parsers = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
      }
      return function(stack, skipFirst) {
        var e_1, _a4, e_2, _b;
        if (skipFirst === void 0) {
          skipFirst = 0;
        }
        var frames = [];
        try {
          for (var _c = tslib_1.__values(stack.split("\n").slice(skipFirst)), _d2 = _c.next(); !_d2.done; _d2 = _c.next()) {
            var line = _d2.value;
            try {
              for (var parsers_1 = (e_2 = void 0, tslib_1.__values(parsers)), parsers_1_1 = parsers_1.next(); !parsers_1_1.done; parsers_1_1 = parsers_1.next()) {
                var parser = parsers_1_1.value;
                var frame = parser(line);
                if (frame) {
                  frames.push(frame);
                  break;
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (parsers_1_1 && !parsers_1_1.done && (_b = parsers_1.return))
                  _b.call(parsers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d2 && !_d2.done && (_a4 = _c.return))
              _a4.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return stripSentryFramesAndReverse(frames);
      };
    }
    exports.createStackParser = createStackParser;
    function stripSentryFramesAndReverse(stack) {
      if (!stack.length) {
        return [];
      }
      var localStack = stack;
      var firstFrameFunction = localStack[0].function || "";
      var lastFrameFunction = localStack[localStack.length - 1].function || "";
      if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
        localStack = localStack.slice(1);
      }
      if (lastFrameFunction.indexOf("sentryWrapped") !== -1) {
        localStack = localStack.slice(0, -1);
      }
      return localStack.slice(0, STACKTRACE_LIMIT).map(function(frame) {
        return tslib_1.__assign(tslib_1.__assign({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || "?" });
      }).reverse();
    }
    exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
    var defaultFunctionName = "<anonymous>";
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== "function") {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      } catch (e2) {
        return defaultFunctionName;
      }
    }
    exports.getFunctionName = getFunctionName;
  }
});

// node_modules/@sentry/utils/dist/string.js
var require_string2 = __commonJS({
  "node_modules/@sentry/utils/dist/string.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require_is();
    function truncate(str, max) {
      if (max === void 0) {
        max = 0;
      }
      if (typeof str !== "string" || max === 0) {
        return str;
      }
      return str.length <= max ? str : str.substr(0, max) + "...";
    }
    exports.truncate = truncate;
    function snipLine(line, colno) {
      var newLine = line;
      var lineLength = newLine.length;
      if (lineLength <= 150) {
        return newLine;
      }
      if (colno > lineLength) {
        colno = lineLength;
      }
      var start = Math.max(colno - 60, 0);
      if (start < 5) {
        start = 0;
      }
      var end = Math.min(start + 140, lineLength);
      if (end > lineLength - 5) {
        end = lineLength;
      }
      if (end === lineLength) {
        start = Math.max(end - 140, 0);
      }
      newLine = newLine.slice(start, end);
      if (start > 0) {
        newLine = "'{snip} " + newLine;
      }
      if (end < lineLength) {
        newLine += " {snip}";
      }
      return newLine;
    }
    exports.snipLine = snipLine;
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return "";
      }
      var output = [];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = input[i2];
        try {
          output.push(String(value));
        } catch (e2) {
          output.push("[value cannot be serialized]");
        }
      }
      return output.join(delimiter);
    }
    exports.safeJoin = safeJoin;
    function isMatchingPattern(value, pattern) {
      if (!is_1.isString(value)) {
        return false;
      }
      if (is_1.isRegExp(pattern)) {
        return pattern.test(value);
      }
      if (typeof pattern === "string") {
        return value.indexOf(pattern) !== -1;
      }
      return false;
    }
    exports.isMatchingPattern = isMatchingPattern;
    function escapeStringForRegex(regexString) {
      return regexString.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    exports.escapeStringForRegex = escapeStringForRegex;
  }
});

// node_modules/@sentry/utils/dist/object.js
var require_object = __commonJS({
  "node_modules/@sentry/utils/dist/object.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    var browser_1 = require_browser4();
    var is_1 = require_is();
    var memo_1 = require_memo();
    var stacktrace_1 = require_stacktrace();
    var string_1 = require_string2();
    function fill(source, name, replacementFactory) {
      if (!(name in source)) {
        return;
      }
      var original = source[name];
      var wrapped = replacementFactory(original);
      if (typeof wrapped === "function") {
        try {
          markFunctionWrapped(wrapped, original);
        } catch (_Oo) {
        }
      }
      source[name] = wrapped;
    }
    exports.fill = fill;
    function addNonEnumerableProperty(obj, name, value) {
      Object.defineProperty(obj, name, {
        value,
        writable: true,
        configurable: true
      });
    }
    exports.addNonEnumerableProperty = addNonEnumerableProperty;
    function markFunctionWrapped(wrapped, original) {
      var proto = original.prototype || {};
      wrapped.prototype = original.prototype = proto;
      addNonEnumerableProperty(wrapped, "__sentry_original__", original);
    }
    exports.markFunctionWrapped = markFunctionWrapped;
    function getOriginalFunction(func) {
      return func.__sentry_original__;
    }
    exports.getOriginalFunction = getOriginalFunction;
    function urlEncode(object) {
      return Object.keys(object).map(function(key2) {
        return encodeURIComponent(key2) + "=" + encodeURIComponent(object[key2]);
      }).join("&");
    }
    exports.urlEncode = urlEncode;
    function getWalkSource(value) {
      if (is_1.isError(value)) {
        var error2 = value;
        var err = {
          message: error2.message,
          name: error2.name,
          stack: error2.stack
        };
        for (var i2 in error2) {
          if (Object.prototype.hasOwnProperty.call(error2, i2)) {
            err[i2] = error2[i2];
          }
        }
        return err;
      }
      if (is_1.isEvent(value)) {
        var event_1 = value;
        var source = {};
        source.type = event_1.type;
        try {
          source.target = is_1.isElement(event_1.target) ? browser_1.htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);
        } catch (_oO) {
          source.target = "<unknown>";
        }
        try {
          source.currentTarget = is_1.isElement(event_1.currentTarget) ? browser_1.htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);
        } catch (_oO) {
          source.currentTarget = "<unknown>";
        }
        if (typeof CustomEvent !== "undefined" && is_1.isInstanceOf(value, CustomEvent)) {
          source.detail = event_1.detail;
        }
        for (var attr in event_1) {
          if (Object.prototype.hasOwnProperty.call(event_1, attr)) {
            source[attr] = event_1[attr];
          }
        }
        return source;
      }
      return value;
    }
    function utf8Length(value) {
      return ~-encodeURI(value).split(/%..|./).length;
    }
    function jsonSize(value) {
      return utf8Length(JSON.stringify(value));
    }
    function normalizeToSize(object, depth, maxSize) {
      if (depth === void 0) {
        depth = 3;
      }
      if (maxSize === void 0) {
        maxSize = 100 * 1024;
      }
      var serialized = normalize2(object, depth);
      if (jsonSize(serialized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
      }
      return serialized;
    }
    exports.normalizeToSize = normalizeToSize;
    function serializeValue(value) {
      if (typeof value === "string") {
        return value;
      }
      var type = Object.prototype.toString.call(value);
      if (type === "[object Object]") {
        return "[Object]";
      }
      if (type === "[object Array]") {
        return "[Array]";
      }
      var normalized = normalizeValue(value);
      return is_1.isPrimitive(normalized) ? normalized : type;
    }
    function normalizeValue(value, key2) {
      if (key2 === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key2 === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (is_1.isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (value === void 0) {
        return "[undefined]";
      }
      if (typeof value === "function") {
        return "[Function: " + stacktrace_1.getFunctionName(value) + "]";
      }
      if (typeof value === "symbol") {
        return "[" + String(value) + "]";
      }
      if (typeof value === "bigint") {
        return "[BigInt: " + String(value) + "]";
      }
      return value;
    }
    function walk(key2, value, depth, memo) {
      if (depth === void 0) {
        depth = Infinity;
      }
      if (memo === void 0) {
        memo = memo_1.memoBuilder();
      }
      if (depth === 0) {
        return serializeValue(value);
      }
      if (value !== null && value !== void 0 && typeof value.toJSON === "function") {
        return value.toJSON();
      }
      var normalized = normalizeValue(value, key2);
      if (is_1.isPrimitive(normalized)) {
        return normalized;
      }
      var source = getWalkSource(value);
      var acc = Array.isArray(value) ? [] : {};
      if (memo[0](value)) {
        return "[Circular ~]";
      }
      for (var innerKey in source) {
        if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
          continue;
        }
        acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);
      }
      memo[1](value);
      return acc;
    }
    exports.walk = walk;
    function normalize2(input, depth) {
      try {
        return JSON.parse(JSON.stringify(input, function(key2, value) {
          return walk(key2, value, depth);
        }));
      } catch (_oO) {
        return "**non-serializable**";
      }
    }
    exports.normalize = normalize2;
    function extractExceptionKeysForMessage(exception, maxLength) {
      if (maxLength === void 0) {
        maxLength = 40;
      }
      var keys = Object.keys(getWalkSource(exception));
      keys.sort();
      if (!keys.length) {
        return "[object has no keys]";
      }
      if (keys[0].length >= maxLength) {
        return string_1.truncate(keys[0], maxLength);
      }
      for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        var serialized = keys.slice(0, includedKeys).join(", ");
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys.length) {
          return serialized;
        }
        return string_1.truncate(serialized, maxLength);
      }
      return "";
    }
    exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
    function dropUndefinedKeys(val) {
      var e_1, _a4;
      if (is_1.isPlainObject(val)) {
        var obj = val;
        var rv = {};
        try {
          for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key2 = _c.value;
            if (typeof obj[key2] !== "undefined") {
              rv[key2] = dropUndefinedKeys(obj[key2]);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a4 = _b.return))
              _a4.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return rv;
      }
      if (Array.isArray(val)) {
        return val.map(dropUndefinedKeys);
      }
      return val;
    }
    exports.dropUndefinedKeys = dropUndefinedKeys;
    function objectify(wat) {
      var objectified;
      switch (true) {
        case (wat === void 0 || wat === null):
          objectified = new String(wat);
          break;
        case (typeof wat === "symbol" || typeof wat === "bigint"):
          objectified = Object(wat);
          break;
        case is_1.isPrimitive(wat):
          objectified = new wat.constructor(wat);
          break;
        default:
          objectified = wat;
          break;
      }
      return objectified;
    }
    exports.objectify = objectify;
  }
});

// node_modules/@sentry/utils/dist/supports.js
var require_supports = __commonJS({
  "node_modules/@sentry/utils/dist/supports.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var env_1 = require_env();
    var global_1 = require_global();
    var logger_1 = require_logger2();
    function supportsErrorEvent() {
      try {
        new ErrorEvent("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.supportsErrorEvent = supportsErrorEvent;
    function supportsDOMError() {
      try {
        new DOMError("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.supportsDOMError = supportsDOMError;
    function supportsDOMException() {
      try {
        new DOMException("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.supportsDOMException = supportsDOMException;
    function supportsFetch() {
      if (!("fetch" in global_1.getGlobalObject())) {
        return false;
      }
      try {
        new Headers();
        new Request("");
        new Response();
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.supportsFetch = supportsFetch;
    function isNativeFetch(func) {
      return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    exports.isNativeFetch = isNativeFetch;
    function supportsNativeFetch() {
      if (!supportsFetch()) {
        return false;
      }
      var global2 = global_1.getGlobalObject();
      if (isNativeFetch(global2.fetch)) {
        return true;
      }
      var result = false;
      var doc = global2.document;
      if (doc && typeof doc.createElement === "function") {
        try {
          var sandbox = doc.createElement("iframe");
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
            result = isNativeFetch(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        } catch (err) {
          if (env_1.isDebugBuild()) {
            logger_1.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
          }
        }
      }
      return result;
    }
    exports.supportsNativeFetch = supportsNativeFetch;
    function supportsReportingObserver() {
      return "ReportingObserver" in global_1.getGlobalObject();
    }
    exports.supportsReportingObserver = supportsReportingObserver;
    function supportsReferrerPolicy() {
      if (!supportsFetch()) {
        return false;
      }
      try {
        new Request("_", {
          referrerPolicy: "origin"
        });
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.supportsReferrerPolicy = supportsReferrerPolicy;
    function supportsHistory() {
      var global2 = global_1.getGlobalObject();
      var chrome2 = global2.chrome;
      var isChromePackagedApp = chrome2 && chrome2.app && chrome2.app.runtime;
      var hasHistoryApi = "history" in global2 && !!global2.history.pushState && !!global2.history.replaceState;
      return !isChromePackagedApp && hasHistoryApi;
    }
    exports.supportsHistory = supportsHistory;
  }
});

// node_modules/@sentry/utils/dist/instrument.js
var require_instrument = __commonJS({
  "node_modules/@sentry/utils/dist/instrument.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    var env_1 = require_env();
    var global_1 = require_global();
    var is_1 = require_is();
    var logger_1 = require_logger2();
    var object_1 = require_object();
    var stacktrace_1 = require_stacktrace();
    var supports_1 = require_supports();
    var global2 = global_1.getGlobalObject();
    var handlers = {};
    var instrumented = {};
    function instrument(type) {
      if (instrumented[type]) {
        return;
      }
      instrumented[type] = true;
      switch (type) {
        case "console":
          instrumentConsole();
          break;
        case "dom":
          instrumentDOM();
          break;
        case "xhr":
          instrumentXHR();
          break;
        case "fetch":
          instrumentFetch();
          break;
        case "history":
          instrumentHistory();
          break;
        case "error":
          instrumentError();
          break;
        case "unhandledrejection":
          instrumentUnhandledRejection();
          break;
        default:
          logger_1.logger.warn("unknown instrumentation type:", type);
      }
    }
    function addInstrumentationHandler(type, callback) {
      handlers[type] = handlers[type] || [];
      handlers[type].push(callback);
      instrument(type);
    }
    exports.addInstrumentationHandler = addInstrumentationHandler;
    function triggerHandlers(type, data) {
      var e_1, _a4;
      if (!type || !handlers[type]) {
        return;
      }
      try {
        for (var _b = tslib_1.__values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
          var handler = _c.value;
          try {
            handler(data);
          } catch (e2) {
            if (env_1.isDebugBuild()) {
              logger_1.logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + stacktrace_1.getFunctionName(handler) + "\nError: " + e2);
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a4 = _b.return))
            _a4.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    function instrumentConsole() {
      if (!("console" in global2)) {
        return;
      }
      ["debug", "info", "warn", "error", "log", "assert"].forEach(function(level) {
        if (!(level in global2.console)) {
          return;
        }
        object_1.fill(global2.console, level, function(originalConsoleMethod) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            triggerHandlers("console", { args, level });
            if (originalConsoleMethod) {
              originalConsoleMethod.apply(global2.console, args);
            }
          };
        });
      });
    }
    function instrumentFetch() {
      if (!supports_1.supportsNativeFetch()) {
        return;
      }
      object_1.fill(global2, "fetch", function(originalFetch) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var handlerData = {
            args,
            fetchData: {
              method: getFetchMethod(args),
              url: getFetchUrl(args)
            },
            startTimestamp: Date.now()
          };
          triggerHandlers("fetch", tslib_1.__assign({}, handlerData));
          return originalFetch.apply(global2, args).then(function(response) {
            triggerHandlers("fetch", tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), response }));
            return response;
          }, function(error2) {
            triggerHandlers("fetch", tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), error: error2 }));
            throw error2;
          });
        };
      });
    }
    function getFetchMethod(fetchArgs) {
      if (fetchArgs === void 0) {
        fetchArgs = [];
      }
      if ("Request" in global2 && is_1.isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
        return String(fetchArgs[0].method).toUpperCase();
      }
      if (fetchArgs[1] && fetchArgs[1].method) {
        return String(fetchArgs[1].method).toUpperCase();
      }
      return "GET";
    }
    function getFetchUrl(fetchArgs) {
      if (fetchArgs === void 0) {
        fetchArgs = [];
      }
      if (typeof fetchArgs[0] === "string") {
        return fetchArgs[0];
      }
      if ("Request" in global2 && is_1.isInstanceOf(fetchArgs[0], Request)) {
        return fetchArgs[0].url;
      }
      return String(fetchArgs[0]);
    }
    function instrumentXHR() {
      if (!("XMLHttpRequest" in global2)) {
        return;
      }
      var xhrproto = XMLHttpRequest.prototype;
      object_1.fill(xhrproto, "open", function(originalOpen) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var xhr = this;
          var url = args[1];
          var xhrInfo = xhr.__sentry_xhr__ = {
            method: is_1.isString(args[0]) ? args[0].toUpperCase() : args[0],
            url: args[1]
          };
          if (is_1.isString(url) && xhrInfo.method === "POST" && url.match(/sentry_key/)) {
            xhr.__sentry_own_request__ = true;
          }
          var onreadystatechangeHandler = function() {
            if (xhr.readyState === 4) {
              try {
                xhrInfo.status_code = xhr.status;
              } catch (e2) {
              }
              triggerHandlers("xhr", {
                args,
                endTimestamp: Date.now(),
                startTimestamp: Date.now(),
                xhr
              });
            }
          };
          if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
            object_1.fill(xhr, "onreadystatechange", function(original) {
              return function() {
                var readyStateArgs = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  readyStateArgs[_i2] = arguments[_i2];
                }
                onreadystatechangeHandler();
                return original.apply(xhr, readyStateArgs);
              };
            });
          } else {
            xhr.addEventListener("readystatechange", onreadystatechangeHandler);
          }
          return originalOpen.apply(xhr, args);
        };
      });
      object_1.fill(xhrproto, "send", function(originalSend) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this.__sentry_xhr__ && args[0] !== void 0) {
            this.__sentry_xhr__.body = args[0];
          }
          triggerHandlers("xhr", {
            args,
            startTimestamp: Date.now(),
            xhr: this
          });
          return originalSend.apply(this, args);
        };
      });
    }
    var lastHref;
    function instrumentHistory() {
      if (!supports_1.supportsHistory()) {
        return;
      }
      var oldOnPopState = global2.onpopstate;
      global2.onpopstate = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var to = global2.location.href;
        var from = lastHref;
        lastHref = to;
        triggerHandlers("history", {
          from,
          to
        });
        if (oldOnPopState) {
          try {
            return oldOnPopState.apply(this, args);
          } catch (_oO) {
          }
        }
      };
      function historyReplacementFunction(originalHistoryFunction) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var url = args.length > 2 ? args[2] : void 0;
          if (url) {
            var from = lastHref;
            var to = String(url);
            lastHref = to;
            triggerHandlers("history", {
              from,
              to
            });
          }
          return originalHistoryFunction.apply(this, args);
        };
      }
      object_1.fill(global2.history, "pushState", historyReplacementFunction);
      object_1.fill(global2.history, "replaceState", historyReplacementFunction);
    }
    var debounceDuration = 1e3;
    var debounceTimerID;
    var lastCapturedEvent;
    function shouldShortcircuitPreviousDebounce(previous, current) {
      if (!previous) {
        return true;
      }
      if (previous.type !== current.type) {
        return true;
      }
      try {
        if (previous.target !== current.target) {
          return true;
        }
      } catch (e2) {
      }
      return false;
    }
    function shouldSkipDOMEvent(event) {
      if (event.type !== "keypress") {
        return false;
      }
      try {
        var target = event.target;
        if (!target || !target.tagName) {
          return true;
        }
        if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
          return false;
        }
      } catch (e2) {
      }
      return true;
    }
    function makeDOMEventHandler(handler, globalListener) {
      if (globalListener === void 0) {
        globalListener = false;
      }
      return function(event) {
        if (!event || lastCapturedEvent === event) {
          return;
        }
        if (shouldSkipDOMEvent(event)) {
          return;
        }
        var name = event.type === "keypress" ? "input" : event.type;
        if (debounceTimerID === void 0) {
          handler({
            event,
            name,
            global: globalListener
          });
          lastCapturedEvent = event;
        } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
          handler({
            event,
            name,
            global: globalListener
          });
          lastCapturedEvent = event;
        }
        clearTimeout(debounceTimerID);
        debounceTimerID = global2.setTimeout(function() {
          debounceTimerID = void 0;
        }, debounceDuration);
      };
    }
    function instrumentDOM() {
      if (!("document" in global2)) {
        return;
      }
      var triggerDOMHandler = triggerHandlers.bind(null, "dom");
      var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      global2.document.addEventListener("click", globalDOMEventHandler, false);
      global2.document.addEventListener("keypress", globalDOMEventHandler, false);
      ["EventTarget", "Node"].forEach(function(target) {
        var proto = global2[target] && global2[target].prototype;
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
          return;
        }
        object_1.fill(proto, "addEventListener", function(originalAddEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                var el = this;
                var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
                var handlerForType = handlers_1[type] = handlers_1[type] || { refCount: 0 };
                if (!handlerForType.handler) {
                  var handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }
                handlerForType.refCount += 1;
              } catch (e2) {
              }
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        });
        object_1.fill(proto, "removeEventListener", function(originalRemoveEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                var el = this;
                var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                var handlerForType = handlers_2[type];
                if (handlerForType) {
                  handlerForType.refCount -= 1;
                  if (handlerForType.refCount <= 0) {
                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                    handlerForType.handler = void 0;
                    delete handlers_2[type];
                  }
                  if (Object.keys(handlers_2).length === 0) {
                    delete el.__sentry_instrumentation_handlers__;
                  }
                }
              } catch (e2) {
              }
            }
            return originalRemoveEventListener.call(this, type, listener, options);
          };
        });
      });
    }
    var _oldOnErrorHandler = null;
    function instrumentError() {
      _oldOnErrorHandler = global2.onerror;
      global2.onerror = function(msg, url, line, column, error2) {
        triggerHandlers("error", {
          column,
          error: error2,
          line,
          msg,
          url
        });
        if (_oldOnErrorHandler) {
          return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
      };
    }
    var _oldOnUnhandledRejectionHandler = null;
    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = global2.onunhandledrejection;
      global2.onunhandledrejection = function(e2) {
        triggerHandlers("unhandledrejection", e2);
        if (_oldOnUnhandledRejectionHandler) {
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
      };
    }
  }
});

// node_modules/@sentry/utils/dist/misc.js
var require_misc = __commonJS({
  "node_modules/@sentry/utils/dist/misc.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    var global_1 = require_global();
    var object_1 = require_object();
    var string_1 = require_string2();
    function uuid4() {
      var global2 = global_1.getGlobalObject();
      var crypto2 = global2.crypto || global2.msCrypto;
      if (!(crypto2 === void 0) && crypto2.getRandomValues) {
        var arr = new Uint16Array(8);
        crypto2.getRandomValues(arr);
        arr[3] = arr[3] & 4095 | 16384;
        arr[4] = arr[4] & 16383 | 32768;
        var pad = function(num) {
          var v = num.toString(16);
          while (v.length < 4) {
            v = "0" + v;
          }
          return v;
        };
        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
      }
      return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r2 = Math.random() * 16 | 0;
        var v = c === "x" ? r2 : r2 & 3 | 8;
        return v.toString(16);
      });
    }
    exports.uuid4 = uuid4;
    function parseUrl(url) {
      if (!url) {
        return {};
      }
      var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match) {
        return {};
      }
      var query = match[6] || "";
      var fragment = match[8] || "";
      return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        relative: match[5] + query + fragment
      };
    }
    exports.parseUrl = parseUrl;
    function getFirstException(event) {
      return event.exception && event.exception.values ? event.exception.values[0] : void 0;
    }
    function getEventDescription(event) {
      var message = event.message, eventId = event.event_id;
      if (message) {
        return message;
      }
      var firstException = getFirstException(event);
      if (firstException) {
        if (firstException.type && firstException.value) {
          return firstException.type + ": " + firstException.value;
        }
        return firstException.type || firstException.value || eventId || "<unknown>";
      }
      return eventId || "<unknown>";
    }
    exports.getEventDescription = getEventDescription;
    function addExceptionTypeValue(event, value, type) {
      var exception = event.exception = event.exception || {};
      var values = exception.values = exception.values || [];
      var firstException = values[0] = values[0] || {};
      if (!firstException.value) {
        firstException.value = value || "";
      }
      if (!firstException.type) {
        firstException.type = type || "Error";
      }
    }
    exports.addExceptionTypeValue = addExceptionTypeValue;
    function addExceptionMechanism(event, newMechanism) {
      var firstException = getFirstException(event);
      if (!firstException) {
        return;
      }
      var defaultMechanism = { type: "generic", handled: true };
      var currentMechanism = firstException.mechanism;
      firstException.mechanism = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, defaultMechanism), currentMechanism), newMechanism);
      if (newMechanism && "data" in newMechanism) {
        var mergedData = tslib_1.__assign(tslib_1.__assign({}, currentMechanism && currentMechanism.data), newMechanism.data);
        firstException.mechanism.data = mergedData;
      }
    }
    exports.addExceptionMechanism = addExceptionMechanism;
    var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    function parseSemver(input) {
      var match = input.match(SEMVER_REGEXP) || [];
      var major = parseInt(match[1], 10);
      var minor = parseInt(match[2], 10);
      var patch = parseInt(match[3], 10);
      return {
        buildmetadata: match[5],
        major: isNaN(major) ? void 0 : major,
        minor: isNaN(minor) ? void 0 : minor,
        patch: isNaN(patch) ? void 0 : patch,
        prerelease: match[4]
      };
    }
    exports.parseSemver = parseSemver;
    var defaultRetryAfter = 60 * 1e3;
    function parseRetryAfterHeader(now, header) {
      if (!header) {
        return defaultRetryAfter;
      }
      var headerDelay = parseInt("" + header, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1e3;
      }
      var headerDate = Date.parse("" + header);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }
      return defaultRetryAfter;
    }
    exports.parseRetryAfterHeader = parseRetryAfterHeader;
    function addContextToFrame(lines, frame, linesOfContext) {
      if (linesOfContext === void 0) {
        linesOfContext = 5;
      }
      var lineno = frame.lineno || 0;
      var maxLines = lines.length;
      var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
      frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map(function(line) {
        return string_1.snipLine(line, 0);
      });
      frame.context_line = string_1.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
      frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map(function(line) {
        return string_1.snipLine(line, 0);
      });
    }
    exports.addContextToFrame = addContextToFrame;
    function stripUrlQueryAndFragment(urlPath) {
      return urlPath.split(/[\?#]/, 1)[0];
    }
    exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
    function checkOrSetAlreadyCaught(exception) {
      if (exception && exception.__sentry_captured__) {
        return true;
      }
      try {
        object_1.addNonEnumerableProperty(exception, "__sentry_captured__", true);
      } catch (err) {
      }
      return false;
    }
    exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
  }
});

// node_modules/@sentry/utils/dist/path.js
var require_path = __commonJS({
  "node_modules/@sentry/utils/dist/path.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i2 = parts.length - 1; i2 >= 0; i2--) {
        var last = parts[i2];
        if (last === ".") {
          parts.splice(i2, 1);
        } else if (last === "..") {
          parts.splice(i2, 1);
          up++;
        } else if (up) {
          parts.splice(i2, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift("..");
        }
      }
      return parts;
    }
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
    function splitPath(filename) {
      var parts = splitPathRe.exec(filename);
      return parts ? parts.slice(1) : [];
    }
    function resolve2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resolvedPath = "";
      var resolvedAbsolute = false;
      for (var i2 = args.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        var path = i2 >= 0 ? args[i2] : "/";
        if (!path) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === "/";
      }
      resolvedPath = normalizeArray(resolvedPath.split("/").filter(function(p) {
        return !!p;
      }), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }
    exports.resolve = resolve2;
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") {
          break;
        }
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") {
          break;
        }
      }
      if (start > end) {
        return [];
      }
      return arr.slice(start, end - start + 1);
    }
    function relative(from, to) {
      from = resolve2(from).substr(1);
      to = resolve2(to).substr(1);
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i2 = 0; i2 < length; i2++) {
        if (fromParts[i2] !== toParts[i2]) {
          samePartsLength = i2;
          break;
        }
      }
      var outputParts = [];
      for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
    exports.relative = relative;
    function normalizePath(path) {
      var isPathAbsolute = isAbsolute(path);
      var trailingSlash = path.substr(-1) === "/";
      var normalizedPath = normalizeArray(path.split("/").filter(function(p) {
        return !!p;
      }), !isPathAbsolute).join("/");
      if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = ".";
      }
      if (normalizedPath && trailingSlash) {
        normalizedPath += "/";
      }
      return (isPathAbsolute ? "/" : "") + normalizedPath;
    }
    exports.normalizePath = normalizePath;
    function isAbsolute(path) {
      return path.charAt(0) === "/";
    }
    exports.isAbsolute = isAbsolute;
    function join() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return normalizePath(args.join("/"));
    }
    exports.join = join;
    function dirname(path) {
      var result = splitPath(path);
      var root = result[0];
      var dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    }
    exports.dirname = dirname;
    function basename(path, ext) {
      var f3 = splitPath(path)[2];
      if (ext && f3.substr(ext.length * -1) === ext) {
        f3 = f3.substr(0, f3.length - ext.length);
      }
      return f3;
    }
    exports.basename = basename;
  }
});

// node_modules/@sentry/utils/dist/syncpromise.js
var require_syncpromise = __commonJS({
  "node_modules/@sentry/utils/dist/syncpromise.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require_is();
    function resolvedSyncPromise(value) {
      return new SyncPromise(function(resolve2) {
        resolve2(value);
      });
    }
    exports.resolvedSyncPromise = resolvedSyncPromise;
    function rejectedSyncPromise(reason) {
      return new SyncPromise(function(_, reject) {
        reject(reason);
      });
    }
    exports.rejectedSyncPromise = rejectedSyncPromise;
    var SyncPromise = function() {
      function SyncPromise2(executor) {
        var _this = this;
        this._state = 0;
        this._handlers = [];
        this._resolve = function(value) {
          _this._setResult(1, value);
        };
        this._reject = function(reason) {
          _this._setResult(2, reason);
        };
        this._setResult = function(state, value) {
          if (_this._state !== 0) {
            return;
          }
          if (is_1.isThenable(value)) {
            void value.then(_this._resolve, _this._reject);
            return;
          }
          _this._state = state;
          _this._value = value;
          _this._executeHandlers();
        };
        this._executeHandlers = function() {
          if (_this._state === 0) {
            return;
          }
          var cachedHandlers = _this._handlers.slice();
          _this._handlers = [];
          cachedHandlers.forEach(function(handler) {
            if (handler[0]) {
              return;
            }
            if (_this._state === 1) {
              handler[1](_this._value);
            }
            if (_this._state === 2) {
              handler[2](_this._value);
            }
            handler[0] = true;
          });
        };
        try {
          executor(this._resolve, this._reject);
        } catch (e2) {
          this._reject(e2);
        }
      }
      SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise2(function(resolve2, reject) {
          _this._handlers.push([
            false,
            function(result) {
              if (!onfulfilled) {
                resolve2(result);
              } else {
                try {
                  resolve2(onfulfilled(result));
                } catch (e2) {
                  reject(e2);
                }
              }
            },
            function(reason) {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve2(onrejected(reason));
                } catch (e2) {
                  reject(e2);
                }
              }
            }
          ]);
          _this._executeHandlers();
        });
      };
      SyncPromise2.prototype.catch = function(onrejected) {
        return this.then(function(val) {
          return val;
        }, onrejected);
      };
      SyncPromise2.prototype.finally = function(onfinally) {
        var _this = this;
        return new SyncPromise2(function(resolve2, reject) {
          var val;
          var isRejected;
          return _this.then(function(value) {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          }, function(reason) {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }).then(function() {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve2(val);
          });
        });
      };
      return SyncPromise2;
    }();
    exports.SyncPromise = SyncPromise;
  }
});

// node_modules/@sentry/utils/dist/promisebuffer.js
var require_promisebuffer = __commonJS({
  "node_modules/@sentry/utils/dist/promisebuffer.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var error_1 = require_error();
    var syncpromise_1 = require_syncpromise();
    function makePromiseBuffer(limit) {
      var buffer = [];
      function isReady() {
        return limit === void 0 || buffer.length < limit;
      }
      function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
      }
      function add(taskProducer) {
        if (!isReady()) {
          return syncpromise_1.rejectedSyncPromise(new error_1.SentryError("Not adding Promise due to buffer limit reached."));
        }
        var task = taskProducer();
        if (buffer.indexOf(task) === -1) {
          buffer.push(task);
        }
        void task.then(function() {
          return remove(task);
        }).then(null, function() {
          return remove(task).then(null, function() {
          });
        });
        return task;
      }
      function drain(timeout) {
        return new syncpromise_1.SyncPromise(function(resolve2, reject) {
          var counter = buffer.length;
          if (!counter) {
            return resolve2(true);
          }
          var capturedSetTimeout = setTimeout(function() {
            if (timeout && timeout > 0) {
              resolve2(false);
            }
          }, timeout);
          buffer.forEach(function(item) {
            void syncpromise_1.resolvedSyncPromise(item).then(function() {
              if (!--counter) {
                clearTimeout(capturedSetTimeout);
                resolve2(true);
              }
            }, reject);
          });
        });
      }
      return {
        $: buffer,
        add,
        drain
      };
    }
    exports.makePromiseBuffer = makePromiseBuffer;
  }
});

// node_modules/@sentry/utils/dist/severity.js
var require_severity2 = __commonJS({
  "node_modules/@sentry/utils/dist/severity.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_dist();
    var enums_1 = require_enums();
    function isSupportedSeverity(level) {
      return enums_1.SeverityLevels.indexOf(level) !== -1;
    }
    function severityFromString(level) {
      if (level === "warn")
        return types_1.Severity.Warning;
      if (isSupportedSeverity(level)) {
        return level;
      }
      return types_1.Severity.Log;
    }
    exports.severityFromString = severityFromString;
  }
});

// node_modules/@sentry/utils/dist/status.js
var require_status = __commonJS({
  "node_modules/@sentry/utils/dist/status.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function eventStatusFromHttpCode(code) {
      if (code >= 200 && code < 300) {
        return "success";
      }
      if (code === 429) {
        return "rate_limit";
      }
      if (code >= 400 && code < 500) {
        return "invalid";
      }
      if (code >= 500) {
        return "failed";
      }
      return "unknown";
    }
    exports.eventStatusFromHttpCode = eventStatusFromHttpCode;
  }
});

// node_modules/@sentry/utils/dist/time.js
var require_time2 = __commonJS({
  "node_modules/@sentry/utils/dist/time.js"(exports, module2) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var global_1 = require_global();
    var node_1 = require_node25();
    var dateTimestampSource = {
      nowSeconds: function() {
        return Date.now() / 1e3;
      }
    };
    function getBrowserPerformance() {
      var performance2 = global_1.getGlobalObject().performance;
      if (!performance2 || !performance2.now) {
        return void 0;
      }
      var timeOrigin = Date.now() - performance2.now();
      return {
        now: function() {
          return performance2.now();
        },
        timeOrigin
      };
    }
    function getNodePerformance() {
      try {
        var perfHooks = node_1.dynamicRequire(module2, "perf_hooks");
        return perfHooks.performance;
      } catch (_) {
        return void 0;
      }
    }
    var platformPerformance = node_1.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
    var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
      nowSeconds: function() {
        return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
      }
    };
    exports.dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
    exports.timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
    exports.timestampWithMs = exports.timestampInSeconds;
    exports.usingPerformanceAPI = platformPerformance !== void 0;
    exports.browserPerformanceTimeOrigin = function() {
      var performance2 = global_1.getGlobalObject().performance;
      if (!performance2 || !performance2.now) {
        exports._browserPerformanceTimeOriginMode = "none";
        return void 0;
      }
      var threshold = 3600 * 1e3;
      var performanceNow = performance2.now();
      var dateNow = Date.now();
      var timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
      var timeOriginIsReliable = timeOriginDelta < threshold;
      var navigationStart = performance2.timing && performance2.timing.navigationStart;
      var hasNavigationStart = typeof navigationStart === "number";
      var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
      var navigationStartIsReliable = navigationStartDelta < threshold;
      if (timeOriginIsReliable || navigationStartIsReliable) {
        if (timeOriginDelta <= navigationStartDelta) {
          exports._browserPerformanceTimeOriginMode = "timeOrigin";
          return performance2.timeOrigin;
        } else {
          exports._browserPerformanceTimeOriginMode = "navigationStart";
          return navigationStart;
        }
      }
      exports._browserPerformanceTimeOriginMode = "dateNow";
      return dateNow;
    }();
  }
});

// node_modules/@sentry/utils/dist/envelope.js
var require_envelope = __commonJS({
  "node_modules/@sentry/utils/dist/envelope.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    function createEnvelope(headers, items) {
      if (items === void 0) {
        items = [];
      }
      return [headers, items];
    }
    exports.createEnvelope = createEnvelope;
    function addItemToEnvelope(envelope, newItem) {
      var _a4 = tslib_1.__read(envelope, 2), headers = _a4[0], items = _a4[1];
      return [headers, tslib_1.__spread(items, [newItem])];
    }
    exports.addItemToEnvelope = addItemToEnvelope;
    function serializeEnvelope(envelope) {
      var _a4 = tslib_1.__read(envelope, 2), headers = _a4[0], items = _a4[1];
      var serializedHeaders = JSON.stringify(headers);
      return items.reduce(function(acc, item) {
        var _a5 = tslib_1.__read(item, 2), itemHeaders = _a5[0], payload = _a5[1];
        return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + JSON.stringify(payload);
      }, serializedHeaders);
    }
    exports.serializeEnvelope = serializeEnvelope;
  }
});

// node_modules/@sentry/utils/dist/clientreport.js
var require_clientreport = __commonJS({
  "node_modules/@sentry/utils/dist/clientreport.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var envelope_1 = require_envelope();
    var time_1 = require_time2();
    function createClientReportEnvelope(discarded_events, dsn, timestamp) {
      var clientReportItem = [
        { type: "client_report" },
        {
          timestamp: timestamp || time_1.dateTimestampInSeconds(),
          discarded_events
        }
      ];
      return envelope_1.createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
    }
    exports.createClientReportEnvelope = createClientReportEnvelope;
  }
});

// node_modules/@sentry/utils/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@sentry/utils/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib4();
    tslib_1.__exportStar(require_async(), exports);
    tslib_1.__exportStar(require_browser4(), exports);
    tslib_1.__exportStar(require_dsn(), exports);
    tslib_1.__exportStar(require_enums(), exports);
    tslib_1.__exportStar(require_error(), exports);
    tslib_1.__exportStar(require_global(), exports);
    tslib_1.__exportStar(require_instrument(), exports);
    tslib_1.__exportStar(require_is(), exports);
    tslib_1.__exportStar(require_logger2(), exports);
    tslib_1.__exportStar(require_memo(), exports);
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_node25(), exports);
    tslib_1.__exportStar(require_object(), exports);
    tslib_1.__exportStar(require_path(), exports);
    tslib_1.__exportStar(require_promisebuffer(), exports);
    tslib_1.__exportStar(require_severity2(), exports);
    tslib_1.__exportStar(require_stacktrace(), exports);
    tslib_1.__exportStar(require_status(), exports);
    tslib_1.__exportStar(require_string2(), exports);
    tslib_1.__exportStar(require_supports(), exports);
    tslib_1.__exportStar(require_syncpromise(), exports);
    tslib_1.__exportStar(require_time2(), exports);
    tslib_1.__exportStar(require_env(), exports);
    tslib_1.__exportStar(require_envelope(), exports);
    tslib_1.__exportStar(require_clientreport(), exports);
  }
});

// node_modules/@sentry/hub/dist/scope.js
var require_scope = __commonJS({
  "node_modules/@sentry/hub/dist/scope.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib3();
    var utils_1 = require_dist2();
    var MAX_BREADCRUMBS = 100;
    var Scope = function() {
      function Scope2() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
      }
      Scope2.clone = function(scope) {
        var newScope = new Scope2();
        if (scope) {
          newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
          newScope._tags = tslib_1.__assign({}, scope._tags);
          newScope._extra = tslib_1.__assign({}, scope._extra);
          newScope._contexts = tslib_1.__assign({}, scope._contexts);
          newScope._user = scope._user;
          newScope._level = scope._level;
          newScope._span = scope._span;
          newScope._session = scope._session;
          newScope._transactionName = scope._transactionName;
          newScope._fingerprint = scope._fingerprint;
          newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
          newScope._requestSession = scope._requestSession;
        }
        return newScope;
      };
      Scope2.prototype.addScopeListener = function(callback) {
        this._scopeListeners.push(callback);
      };
      Scope2.prototype.addEventProcessor = function(callback) {
        this._eventProcessors.push(callback);
        return this;
      };
      Scope2.prototype.setUser = function(user) {
        this._user = user || {};
        if (this._session) {
          this._session.update({ user });
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getUser = function() {
        return this._user;
      };
      Scope2.prototype.getRequestSession = function() {
        return this._requestSession;
      };
      Scope2.prototype.setRequestSession = function(requestSession) {
        this._requestSession = requestSession;
        return this;
      };
      Scope2.prototype.setTags = function(tags) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTag = function(key2, value) {
        var _a4;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a4 = {}, _a4[key2] = value, _a4));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtras = function(extras) {
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtra = function(key2, extra) {
        var _a4;
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a4 = {}, _a4[key2] = extra, _a4));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setFingerprint = function(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setLevel = function(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransactionName = function(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransaction = function(name) {
        return this.setTransactionName(name);
      };
      Scope2.prototype.setContext = function(key2, context) {
        var _a4;
        if (context === null) {
          delete this._contexts[key2];
        } else {
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a4 = {}, _a4[key2] = context, _a4));
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setSpan = function(span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSpan = function() {
        return this._span;
      };
      Scope2.prototype.getTransaction = function() {
        var span = this.getSpan();
        return span && span.transaction;
      };
      Scope2.prototype.setSession = function(session) {
        if (!session) {
          delete this._session;
        } else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSession = function() {
        return this._session;
      };
      Scope2.prototype.update = function(captureContext) {
        if (!captureContext) {
          return this;
        }
        if (typeof captureContext === "function") {
          var updatedScope = captureContext(this);
          return updatedScope instanceof Scope2 ? updatedScope : this;
        }
        if (captureContext instanceof Scope2) {
          this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
          this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
          if (captureContext._user && Object.keys(captureContext._user).length) {
            this._user = captureContext._user;
          }
          if (captureContext._level) {
            this._level = captureContext._level;
          }
          if (captureContext._fingerprint) {
            this._fingerprint = captureContext._fingerprint;
          }
          if (captureContext._requestSession) {
            this._requestSession = captureContext._requestSession;
          }
        } else if (utils_1.isPlainObject(captureContext)) {
          captureContext = captureContext;
          this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
          this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
          if (captureContext.user) {
            this._user = captureContext.user;
          }
          if (captureContext.level) {
            this._level = captureContext.level;
          }
          if (captureContext.fingerprint) {
            this._fingerprint = captureContext.fingerprint;
          }
          if (captureContext.requestSession) {
            this._requestSession = captureContext.requestSession;
          }
        }
        return this;
      };
      Scope2.prototype.clear = function() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._span = void 0;
        this._session = void 0;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: utils_1.dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.clearBreadcrumbs = function() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.applyToEvent = function(event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
          event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
          event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
          event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
          event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
          event.level = this._level;
        }
        if (this._transactionName) {
          event.transaction = this._transactionName;
        }
        if (this._span) {
          event.contexts = tslib_1.__assign({ trace: this._span.getTraceContext() }, event.contexts);
          var transactionName = this._span.transaction && this._span.transaction.name;
          if (transactionName) {
            event.tags = tslib_1.__assign({ transaction: transactionName }, event.tags);
          }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = tslib_1.__spread(event.breadcrumbs || [], this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
      };
      Scope2.prototype.setSDKProcessingMetadata = function(newData) {
        this._sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, this._sdkProcessingMetadata), newData);
        return this;
      };
      Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
        var _this = this;
        if (index === void 0) {
          index = 0;
        }
        return new utils_1.SyncPromise(function(resolve2, reject) {
          var processor = processors[index];
          if (event === null || typeof processor !== "function") {
            resolve2(event);
          } else {
            var result = processor(tslib_1.__assign({}, event), hint);
            if (utils_1.isThenable(result)) {
              void result.then(function(final) {
                return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve2);
              }).then(null, reject);
            } else {
              void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve2).then(null, reject);
            }
          }
        });
      };
      Scope2.prototype._notifyScopeListeners = function() {
        var _this = this;
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(function(callback) {
            callback(_this);
          });
          this._notifyingListeners = false;
        }
      };
      Scope2.prototype._applyFingerprint = function(event) {
        event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
        if (this._fingerprint) {
          event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        if (event.fingerprint && !event.fingerprint.length) {
          delete event.fingerprint;
        }
      };
      return Scope2;
    }();
    exports.Scope = Scope;
    function getGlobalEventProcessors() {
      var global2 = utils_1.getGlobalObject();
      global2.__SENTRY__ = global2.__SENTRY__ || {};
      global2.__SENTRY__.globalEventProcessors = global2.__SENTRY__.globalEventProcessors || [];
      return global2.__SENTRY__.globalEventProcessors;
    }
    function addGlobalEventProcessor(callback) {
      getGlobalEventProcessors().push(callback);
    }
    exports.addGlobalEventProcessor = addGlobalEventProcessor;
  }
});

// node_modules/@sentry/hub/dist/session.js
var require_session = __commonJS({
  "node_modules/@sentry/hub/dist/session.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var Session = function() {
      function Session2(context) {
        this.errors = 0;
        this.sid = utils_1.uuid4();
        this.duration = 0;
        this.status = "ok";
        this.init = true;
        this.ignoreDuration = false;
        var startingTime = utils_1.timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
          this.update(context);
        }
      }
      Session2.prototype.update = function(context) {
        if (context === void 0) {
          context = {};
        }
        if (context.user) {
          if (!this.ipAddress && context.user.ip_address) {
            this.ipAddress = context.user.ip_address;
          }
          if (!this.did && !context.did) {
            this.did = context.user.id || context.user.email || context.user.username;
          }
        }
        this.timestamp = context.timestamp || utils_1.timestampInSeconds();
        if (context.ignoreDuration) {
          this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
          this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
        }
        if (context.init !== void 0) {
          this.init = context.init;
        }
        if (!this.did && context.did) {
          this.did = "" + context.did;
        }
        if (typeof context.started === "number") {
          this.started = context.started;
        }
        if (this.ignoreDuration) {
          this.duration = void 0;
        } else if (typeof context.duration === "number") {
          this.duration = context.duration;
        } else {
          var duration = this.timestamp - this.started;
          this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
          this.release = context.release;
        }
        if (context.environment) {
          this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
          this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
          this.userAgent = context.userAgent;
        }
        if (typeof context.errors === "number") {
          this.errors = context.errors;
        }
        if (context.status) {
          this.status = context.status;
        }
      };
      Session2.prototype.close = function(status) {
        if (status) {
          this.update({ status });
        } else if (this.status === "ok") {
          this.update({ status: "exited" });
        } else {
          this.update();
        }
      };
      Session2.prototype.toJSON = function() {
        return utils_1.dropUndefinedKeys({
          sid: "" + this.sid,
          init: this.init,
          started: new Date(this.started * 1e3).toISOString(),
          timestamp: new Date(this.timestamp * 1e3).toISOString(),
          status: this.status,
          errors: this.errors,
          did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
          duration: this.duration,
          attrs: {
            release: this.release,
            environment: this.environment,
            ip_address: this.ipAddress,
            user_agent: this.userAgent
          }
        });
      };
      return Session2;
    }();
    exports.Session = Session;
  }
});

// node_modules/@sentry/hub/dist/hub.js
var require_hub = __commonJS({
  "node_modules/@sentry/hub/dist/hub.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib3();
    var utils_1 = require_dist2();
    var scope_1 = require_scope();
    var session_1 = require_session();
    exports.API_VERSION = 4;
    var DEFAULT_BREADCRUMBS = 100;
    var Hub = function() {
      function Hub2(client, scope, _version) {
        if (scope === void 0) {
          scope = new scope_1.Scope();
        }
        if (_version === void 0) {
          _version = exports.API_VERSION;
        }
        this._version = _version;
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
          this.bindClient(client);
        }
      }
      Hub2.prototype.isOlderThan = function(version) {
        return this._version < version;
      };
      Hub2.prototype.bindClient = function(client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      };
      Hub2.prototype.pushScope = function() {
        var scope = scope_1.Scope.clone(this.getScope());
        this.getStack().push({
          client: this.getClient(),
          scope
        });
        return scope;
      };
      Hub2.prototype.popScope = function() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      };
      Hub2.prototype.withScope = function(callback) {
        var scope = this.pushScope();
        try {
          callback(scope);
        } finally {
          this.popScope();
        }
      };
      Hub2.prototype.getClient = function() {
        return this.getStackTop().client;
      };
      Hub2.prototype.getScope = function() {
        return this.getStackTop().scope;
      };
      Hub2.prototype.getStack = function() {
        return this._stack;
      };
      Hub2.prototype.getStackTop = function() {
        return this._stack[this._stack.length - 1];
      };
      Hub2.prototype.captureException = function(exception, hint) {
        var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error("Sentry syntheticException");
          } catch (exception2) {
            syntheticException = exception2;
          }
          finalHint = {
            originalException: exception,
            syntheticException
          };
        }
        this._invokeClient("captureException", exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureMessage = function(message, level, hint) {
        var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error(message);
          } catch (exception) {
            syntheticException = exception;
          }
          finalHint = {
            originalException: message,
            syntheticException
          };
        }
        this._invokeClient("captureMessage", message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureEvent = function(event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4();
        if (event.type !== "transaction") {
          this._lastEventId = eventId;
        }
        this._invokeClient("captureEvent", event, tslib_1.__assign(tslib_1.__assign({}, hint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.lastEventId = function() {
        return this._lastEventId;
      };
      Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
        var _a4 = this.getStackTop(), scope = _a4.scope, client = _a4.client;
        if (!scope || !client)
          return;
        var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d2 = _b.maxBreadcrumbs, maxBreadcrumbs = _d2 === void 0 ? DEFAULT_BREADCRUMBS : _d2;
        if (maxBreadcrumbs <= 0)
          return;
        var timestamp = utils_1.dateTimestampInSeconds();
        var mergedBreadcrumb = tslib_1.__assign({ timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb ? utils_1.consoleSandbox(function() {
          return beforeBreadcrumb(mergedBreadcrumb, hint);
        }) : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      };
      Hub2.prototype.setUser = function(user) {
        var scope = this.getScope();
        if (scope)
          scope.setUser(user);
      };
      Hub2.prototype.setTags = function(tags) {
        var scope = this.getScope();
        if (scope)
          scope.setTags(tags);
      };
      Hub2.prototype.setExtras = function(extras) {
        var scope = this.getScope();
        if (scope)
          scope.setExtras(extras);
      };
      Hub2.prototype.setTag = function(key2, value) {
        var scope = this.getScope();
        if (scope)
          scope.setTag(key2, value);
      };
      Hub2.prototype.setExtra = function(key2, extra) {
        var scope = this.getScope();
        if (scope)
          scope.setExtra(key2, extra);
      };
      Hub2.prototype.setContext = function(name, context) {
        var scope = this.getScope();
        if (scope)
          scope.setContext(name, context);
      };
      Hub2.prototype.configureScope = function(callback) {
        var _a4 = this.getStackTop(), scope = _a4.scope, client = _a4.client;
        if (scope && client) {
          callback(scope);
        }
      };
      Hub2.prototype.run = function(callback) {
        var oldHub = makeMain(this);
        try {
          callback(this);
        } finally {
          makeMain(oldHub);
        }
      };
      Hub2.prototype.getIntegration = function(integration) {
        var client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        } catch (_oO) {
          utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
          return null;
        }
      };
      Hub2.prototype.startSpan = function(context) {
        return this._callExtensionMethod("startSpan", context);
      };
      Hub2.prototype.startTransaction = function(context, customSamplingContext) {
        return this._callExtensionMethod("startTransaction", context, customSamplingContext);
      };
      Hub2.prototype.traceHeaders = function() {
        return this._callExtensionMethod("traceHeaders");
      };
      Hub2.prototype.captureSession = function(endSession) {
        if (endSession === void 0) {
          endSession = false;
        }
        if (endSession) {
          return this.endSession();
        }
        this._sendSessionUpdate();
      };
      Hub2.prototype.endSession = function() {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
          session.close();
        }
        this._sendSessionUpdate();
        if (scope) {
          scope.setSession();
        }
      };
      Hub2.prototype.startSession = function(context) {
        var _a4 = this.getStackTop(), scope = _a4.scope, client = _a4.client;
        var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
        var global2 = utils_1.getGlobalObject();
        var userAgent = (global2.navigator || {}).userAgent;
        var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({
          release,
          environment
        }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
        if (scope) {
          var currentSession = scope.getSession && scope.getSession();
          if (currentSession && currentSession.status === "ok") {
            currentSession.update({ status: "exited" });
          }
          this.endSession();
          scope.setSession(session);
        }
        return session;
      };
      Hub2.prototype._sendSessionUpdate = function() {
        var _a4 = this.getStackTop(), scope = _a4.scope, client = _a4.client;
        if (!scope)
          return;
        var session = scope.getSession && scope.getSession();
        if (session) {
          if (client && client.captureSession) {
            client.captureSession(session);
          }
        }
      };
      Hub2.prototype._invokeClient = function(method) {
        var _a4;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
          (_a4 = client)[method].apply(_a4, tslib_1.__spread(args, [scope]));
        }
      };
      Hub2.prototype._callExtensionMethod = function(method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
          return sentry.extensions[method].apply(this, args);
        }
        utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
      };
      return Hub2;
    }();
    exports.Hub = Hub;
    function getMainCarrier() {
      var carrier = utils_1.getGlobalObject();
      carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: void 0
      };
      return carrier;
    }
    exports.getMainCarrier = getMainCarrier;
    function makeMain(hub) {
      var registry = getMainCarrier();
      var oldHub = getHubFromCarrier(registry);
      setHubOnCarrier(registry, hub);
      return oldHub;
    }
    exports.makeMain = makeMain;
    function getCurrentHub() {
      var registry = getMainCarrier();
      if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports.API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
      }
      if (utils_1.isNodeEnv()) {
        return getHubFromActiveDomain(registry);
      }
      return getHubFromCarrier(registry);
    }
    exports.getCurrentHub = getCurrentHub;
    function getActiveDomain() {
      utils_1.logger.warn("Function `getActiveDomain` is deprecated and will be removed in a future version.");
      var sentry = getMainCarrier().__SENTRY__;
      return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
    }
    exports.getActiveDomain = getActiveDomain;
    function getHubFromActiveDomain(registry) {
      try {
        var sentry = getMainCarrier().__SENTRY__;
        var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
        if (!activeDomain) {
          return getHubFromCarrier(registry);
        }
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports.API_VERSION)) {
          var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
          setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
        }
        return getHubFromCarrier(activeDomain);
      } catch (_Oo) {
        return getHubFromCarrier(registry);
      }
    }
    function hasHubOnCarrier(carrier) {
      return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
    }
    function getHubFromCarrier(carrier) {
      if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub)
        return carrier.__SENTRY__.hub;
      carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      carrier.__SENTRY__.hub = new Hub();
      return carrier.__SENTRY__.hub;
    }
    exports.getHubFromCarrier = getHubFromCarrier;
    function setHubOnCarrier(carrier, hub) {
      if (!carrier)
        return false;
      carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      carrier.__SENTRY__.hub = hub;
      return true;
    }
    exports.setHubOnCarrier = setHubOnCarrier;
  }
});

// node_modules/@sentry/hub/dist/sessionflusher.js
var require_sessionflusher = __commonJS({
  "node_modules/@sentry/hub/dist/sessionflusher.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var hub_1 = require_hub();
    var SessionFlusher = function() {
      function SessionFlusher2(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        this._intervalId = setInterval(function() {
          return _this.flush();
        }, this.flushTimeout * 1e3);
        this._sessionAttrs = attrs;
      }
      SessionFlusher2.prototype.sendSessionAggregates = function(sessionAggregates) {
        if (!this._transport.sendSession) {
          utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
          return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function(reason) {
          utils_1.logger.error("Error while sending session: " + reason);
        });
      };
      SessionFlusher2.prototype.flush = function() {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
          return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
      };
      SessionFlusher2.prototype.getSessionAggregates = function() {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function(key2) {
          return _this._pendingAggregates[parseInt(key2)];
        });
        var sessionAggregates = {
          attrs: this._sessionAttrs,
          aggregates
        };
        return utils_1.dropUndefinedKeys(sessionAggregates);
      };
      SessionFlusher2.prototype.close = function() {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
      };
      SessionFlusher2.prototype.incrementSessionStatusCount = function() {
        if (!this._isEnabled) {
          return;
        }
        var scope = hub_1.getCurrentHub().getScope();
        var requestSession = scope && scope.getRequestSession();
        if (requestSession && requestSession.status) {
          this._incrementSessionStatusCount(requestSession.status, new Date());
          if (scope) {
            scope.setRequestSession(void 0);
          }
        }
      };
      SessionFlusher2.prototype._incrementSessionStatusCount = function(status, date) {
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
          aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
          case "errored":
            aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
            return aggregationCounts.errored;
          case "ok":
            aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
            return aggregationCounts.exited;
          default:
            aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
            return aggregationCounts.crashed;
        }
      };
      return SessionFlusher2;
    }();
    exports.SessionFlusher = SessionFlusher;
  }
});

// node_modules/@sentry/hub/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@sentry/hub/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var scope_1 = require_scope();
    exports.addGlobalEventProcessor = scope_1.addGlobalEventProcessor;
    exports.Scope = scope_1.Scope;
    var session_1 = require_session();
    exports.Session = session_1.Session;
    var sessionflusher_1 = require_sessionflusher();
    exports.SessionFlusher = sessionflusher_1.SessionFlusher;
    var hub_1 = require_hub();
    exports.getActiveDomain = hub_1.getActiveDomain;
    exports.getCurrentHub = hub_1.getCurrentHub;
    exports.getHubFromCarrier = hub_1.getHubFromCarrier;
    exports.getMainCarrier = hub_1.getMainCarrier;
    exports.Hub = hub_1.Hub;
    exports.makeMain = hub_1.makeMain;
    exports.setHubOnCarrier = hub_1.setHubOnCarrier;
  }
});

// node_modules/@sentry/minimal/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@sentry/minimal/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib2();
    var hub_1 = require_dist3();
    function callOnHub(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var hub = hub_1.getCurrentHub();
      if (hub && hub[method]) {
        return hub[method].apply(hub, tslib_1.__spread(args));
      }
      throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
    }
    function captureException(exception, captureContext) {
      var syntheticException;
      try {
        throw new Error("Sentry syntheticException");
      } catch (exception2) {
        syntheticException = exception2;
      }
      return callOnHub("captureException", exception, {
        captureContext,
        originalException: exception,
        syntheticException
      });
    }
    exports.captureException = captureException;
    function captureMessage(message, captureContext) {
      var syntheticException;
      try {
        throw new Error(message);
      } catch (exception) {
        syntheticException = exception;
      }
      var level = typeof captureContext === "string" ? captureContext : void 0;
      var context = typeof captureContext !== "string" ? { captureContext } : void 0;
      return callOnHub("captureMessage", message, level, tslib_1.__assign({ originalException: message, syntheticException }, context));
    }
    exports.captureMessage = captureMessage;
    function captureEvent(event) {
      return callOnHub("captureEvent", event);
    }
    exports.captureEvent = captureEvent;
    function configureScope(callback) {
      callOnHub("configureScope", callback);
    }
    exports.configureScope = configureScope;
    function addBreadcrumb(breadcrumb) {
      callOnHub("addBreadcrumb", breadcrumb);
    }
    exports.addBreadcrumb = addBreadcrumb;
    function setContext2(name, context) {
      callOnHub("setContext", name, context);
    }
    exports.setContext = setContext2;
    function setExtras(extras) {
      callOnHub("setExtras", extras);
    }
    exports.setExtras = setExtras;
    function setTags(tags) {
      callOnHub("setTags", tags);
    }
    exports.setTags = setTags;
    function setExtra(key2, extra) {
      callOnHub("setExtra", key2, extra);
    }
    exports.setExtra = setExtra;
    function setTag(key2, value) {
      callOnHub("setTag", key2, value);
    }
    exports.setTag = setTag;
    function setUser(user) {
      callOnHub("setUser", user);
    }
    exports.setUser = setUser;
    function withScope(callback) {
      callOnHub("withScope", callback);
    }
    exports.withScope = withScope;
    function _callOnClient(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callOnHub.apply(void 0, tslib_1.__spread(["_invokeClient", method], args));
    }
    exports._callOnClient = _callOnClient;
    function startTransaction(context, customSamplingContext) {
      return callOnHub("startTransaction", tslib_1.__assign({}, context), customSamplingContext);
    }
    exports.startTransaction = startTransaction;
  }
});

// node_modules/@sentry/core/dist/api.js
var require_api = __commonJS({
  "node_modules/@sentry/core/dist/api.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var SENTRY_API_VERSION = "7";
    var API = function() {
      function API2(dsn, metadata, tunnel) {
        if (metadata === void 0) {
          metadata = {};
        }
        this.dsn = dsn;
        this._dsnObject = utils_1.makeDsn(dsn);
        this.metadata = metadata;
        this._tunnel = tunnel;
      }
      API2.prototype.getDsn = function() {
        return this._dsnObject;
      };
      API2.prototype.forceEnvelope = function() {
        return !!this._tunnel;
      };
      API2.prototype.getBaseApiEndpoint = function() {
        return getBaseApiEndpoint(this._dsnObject);
      };
      API2.prototype.getStoreEndpoint = function() {
        return getStoreEndpoint(this._dsnObject);
      };
      API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
        return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
      };
      API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
        return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
      };
      return API2;
    }();
    exports.API = API;
    function initAPIDetails(dsn, metadata, tunnel) {
      return {
        initDsn: dsn,
        metadata: metadata || {},
        dsn: utils_1.makeDsn(dsn),
        tunnel
      };
    }
    exports.initAPIDetails = initAPIDetails;
    function getBaseApiEndpoint(dsn) {
      var protocol = dsn.protocol ? dsn.protocol + ":" : "";
      var port = dsn.port ? ":" + dsn.port : "";
      return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
    }
    function _getIngestEndpoint(dsn, target) {
      return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
    }
    function _encodedAuth(dsn) {
      return utils_1.urlEncode({
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION
      });
    }
    function getStoreEndpoint(dsn) {
      return _getIngestEndpoint(dsn, "store");
    }
    function getStoreEndpointWithUrlEncodedAuth(dsn) {
      return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
    }
    exports.getStoreEndpointWithUrlEncodedAuth = getStoreEndpointWithUrlEncodedAuth;
    function _getEnvelopeEndpoint(dsn) {
      return _getIngestEndpoint(dsn, "envelope");
    }
    function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
      return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
    }
    exports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;
    function getRequestHeaders(dsn, clientName, clientVersion) {
      var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
      header.push("sentry_client=" + clientName + "/" + clientVersion);
      header.push("sentry_key=" + dsn.publicKey);
      if (dsn.pass) {
        header.push("sentry_secret=" + dsn.pass);
      }
      return {
        "Content-Type": "application/json",
        "X-Sentry-Auth": header.join(", ")
      };
    }
    exports.getRequestHeaders = getRequestHeaders;
    function getReportDialogEndpoint(dsnLike, dialogOptions) {
      var dsn = utils_1.makeDsn(dsnLike);
      var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
      var encodedOptions = "dsn=" + utils_1.dsnToString(dsn);
      for (var key2 in dialogOptions) {
        if (key2 === "dsn") {
          continue;
        }
        if (key2 === "user") {
          if (!dialogOptions.user) {
            continue;
          }
          if (dialogOptions.user.name) {
            encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
          }
          if (dialogOptions.user.email) {
            encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
          }
        } else {
          encodedOptions += "&" + encodeURIComponent(key2) + "=" + encodeURIComponent(dialogOptions[key2]);
        }
      }
      return endpoint + "?" + encodedOptions;
    }
    exports.getReportDialogEndpoint = getReportDialogEndpoint;
  }
});

// node_modules/@sentry/core/node_modules/tslib/tslib.js
var require_tslib5 = __commonJS({
  "node_modules/@sentry/core/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory2(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key2, r2) : d(target, key2)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f3 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __exportStar = function(m2, exports2) {
        for (var p in m2)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m2[p];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o[s3], i2 = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i2 = m2.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v) {
          if (f3(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f3) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f3 ? f3(v) : v;
          } : f3;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/core/dist/integration.js
var require_integration = __commonJS({
  "node_modules/@sentry/core/dist/integration.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    exports.installedIntegrations = [];
    function filterDuplicates(integrations) {
      return integrations.reduce(function(acc, integrations2) {
        if (acc.every(function(accIntegration) {
          return integrations2.name !== accIntegration.name;
        })) {
          acc.push(integrations2);
        }
        return acc;
      }, []);
    }
    function getIntegrationsToSetup(options) {
      var defaultIntegrations = options.defaultIntegrations && tslib_1.__spread(options.defaultIntegrations) || [];
      var userIntegrations = options.integrations;
      var integrations = tslib_1.__spread(filterDuplicates(defaultIntegrations));
      if (Array.isArray(userIntegrations)) {
        integrations = tslib_1.__spread(integrations.filter(function(integrations2) {
          return userIntegrations.every(function(userIntegration) {
            return userIntegration.name !== integrations2.name;
          });
        }), filterDuplicates(userIntegrations));
      } else if (typeof userIntegrations === "function") {
        integrations = userIntegrations(integrations);
        integrations = Array.isArray(integrations) ? integrations : [integrations];
      }
      var integrationsNames = integrations.map(function(i2) {
        return i2.name;
      });
      var alwaysLastToRun = "Debug";
      if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
        integrations.push.apply(integrations, tslib_1.__spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
      }
      return integrations;
    }
    exports.getIntegrationsToSetup = getIntegrationsToSetup;
    function setupIntegration(integration) {
      if (exports.installedIntegrations.indexOf(integration.name) !== -1) {
        return;
      }
      integration.setupOnce(hub_1.addGlobalEventProcessor, hub_1.getCurrentHub);
      exports.installedIntegrations.push(integration.name);
      utils_1.logger.log("Integration installed: " + integration.name);
    }
    exports.setupIntegration = setupIntegration;
    function setupIntegrations(options) {
      var integrations = {};
      getIntegrationsToSetup(options).forEach(function(integration) {
        integrations[integration.name] = integration;
        setupIntegration(integration);
      });
      utils_1.addNonEnumerableProperty(integrations, "initialized", true);
      return integrations;
    }
    exports.setupIntegrations = setupIntegrations;
  }
});

// node_modules/@sentry/core/dist/baseclient.js
var require_baseclient = __commonJS({
  "node_modules/@sentry/core/dist/baseclient.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    var integration_1 = require_integration();
    var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    var BaseClient = function() {
      function BaseClient2(backendClass, options) {
        this._integrations = {};
        this._numProcessing = 0;
        this._backend = new backendClass(options);
        this._options = options;
        if (options.dsn) {
          this._dsn = utils_1.makeDsn(options.dsn);
        }
      }
      BaseClient2.prototype.captureException = function(exception, hint, scope) {
        var _this = this;
        if (utils_1.checkOrSetAlreadyCaught(exception)) {
          utils_1.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
          return _this._captureEvent(event, hint, scope);
        }).then(function(result) {
          eventId = result;
        }));
        return eventId;
      };
      BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
        var _this = this;
        var eventId = hint && hint.event_id;
        var promisedEvent = utils_1.isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
        this._process(promisedEvent.then(function(event) {
          return _this._captureEvent(event, hint, scope);
        }).then(function(result) {
          eventId = result;
        }));
        return eventId;
      };
      BaseClient2.prototype.captureEvent = function(event, hint, scope) {
        if (hint && hint.originalException && utils_1.checkOrSetAlreadyCaught(hint.originalException)) {
          utils_1.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._captureEvent(event, hint, scope).then(function(result) {
          eventId = result;
        }));
        return eventId;
      };
      BaseClient2.prototype.captureSession = function(session) {
        if (!this._isEnabled()) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("SDK not enabled, will not capture session.");
          }
          return;
        }
        if (!(typeof session.release === "string")) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Discarded session because of missing or non-string release");
          }
        } else {
          this._sendSession(session);
          session.update({ init: false });
        }
      };
      BaseClient2.prototype.getDsn = function() {
        return this._dsn;
      };
      BaseClient2.prototype.getOptions = function() {
        return this._options;
      };
      BaseClient2.prototype.getTransport = function() {
        return this._getBackend().getTransport();
      };
      BaseClient2.prototype.flush = function(timeout) {
        var _this = this;
        return this._isClientDoneProcessing(timeout).then(function(clientFinished) {
          return _this.getTransport().close(timeout).then(function(transportFlushed) {
            return clientFinished && transportFlushed;
          });
        });
      };
      BaseClient2.prototype.close = function(timeout) {
        var _this = this;
        return this.flush(timeout).then(function(result) {
          _this.getOptions().enabled = false;
          return result;
        });
      };
      BaseClient2.prototype.setupIntegrations = function() {
        if (this._isEnabled() && !this._integrations.initialized) {
          this._integrations = integration_1.setupIntegrations(this._options);
        }
      };
      BaseClient2.prototype.getIntegration = function(integration) {
        try {
          return this._integrations[integration.id] || null;
        } catch (_oO) {
          utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
          return null;
        }
      };
      BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
        var e_1, _a4;
        var crashed = false;
        var errored = false;
        var exceptions = event.exception && event.exception.values;
        if (exceptions) {
          errored = true;
          try {
            for (var exceptions_1 = tslib_1.__values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
              var ex = exceptions_1_1.value;
              var mechanism = ex.mechanism;
              if (mechanism && mechanism.handled === false) {
                crashed = true;
                break;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (exceptions_1_1 && !exceptions_1_1.done && (_a4 = exceptions_1.return))
                _a4.call(exceptions_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        var sessionNonTerminal = session.status === "ok";
        var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
        if (shouldUpdateAndSend) {
          session.update(tslib_1.__assign(tslib_1.__assign({}, crashed && { status: "crashed" }), { errors: session.errors || Number(errored || crashed) }));
          this.captureSession(session);
        }
      };
      BaseClient2.prototype._sendSession = function(session) {
        this._getBackend().sendSession(session);
      };
      BaseClient2.prototype._isClientDoneProcessing = function(timeout) {
        var _this = this;
        return new utils_1.SyncPromise(function(resolve2) {
          var ticked = 0;
          var tick = 1;
          var interval = setInterval(function() {
            if (_this._numProcessing == 0) {
              clearInterval(interval);
              resolve2(true);
            } else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve2(false);
              }
            }
          }, tick);
        });
      };
      BaseClient2.prototype._getBackend = function() {
        return this._backend;
      };
      BaseClient2.prototype._isEnabled = function() {
        return this.getOptions().enabled !== false && this._dsn !== void 0;
      };
      BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
        var _this = this;
        var _a4 = this.getOptions().normalizeDepth, normalizeDepth = _a4 === void 0 ? 3 : _a4;
        var prepared = tslib_1.__assign(tslib_1.__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : utils_1.uuid4()), timestamp: event.timestamp || utils_1.dateTimestampInSeconds() });
        this._applyClientOptions(prepared);
        this._applyIntegrationsMetadata(prepared);
        var finalScope = scope;
        if (hint && hint.captureContext) {
          finalScope = hub_1.Scope.clone(finalScope).update(hint.captureContext);
        }
        var result = utils_1.resolvedSyncPromise(prepared);
        if (finalScope) {
          result = finalScope.applyToEvent(prepared, hint);
        }
        return result.then(function(evt) {
          if (evt) {
            evt.sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, evt.sdkProcessingMetadata), { normalizeDepth: utils_1.normalize(normalizeDepth) });
          }
          if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
            return _this._normalizeEvent(evt, normalizeDepth);
          }
          return evt;
        });
      };
      BaseClient2.prototype._normalizeEvent = function(event, depth) {
        if (!event) {
          return null;
        }
        var normalized = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, event), event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map(function(b) {
            return tslib_1.__assign(tslib_1.__assign({}, b), b.data && {
              data: utils_1.normalize(b.data, depth)
            });
          })
        }), event.user && {
          user: utils_1.normalize(event.user, depth)
        }), event.contexts && {
          contexts: utils_1.normalize(event.contexts, depth)
        }), event.extra && {
          extra: utils_1.normalize(event.extra, depth)
        });
        if (event.contexts && event.contexts.trace) {
          normalized.contexts.trace = event.contexts.trace;
        }
        event.sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, event.sdkProcessingMetadata), { baseClientNormalized: true });
        return normalized;
      };
      BaseClient2.prototype._applyClientOptions = function(event) {
        var options = this.getOptions();
        var environment = options.environment, release = options.release, dist = options.dist, _a4 = options.maxValueLength, maxValueLength = _a4 === void 0 ? 250 : _a4;
        if (!("environment" in event)) {
          event.environment = "environment" in options ? environment : "production";
        }
        if (event.release === void 0 && release !== void 0) {
          event.release = release;
        }
        if (event.dist === void 0 && dist !== void 0) {
          event.dist = dist;
        }
        if (event.message) {
          event.message = utils_1.truncate(event.message, maxValueLength);
        }
        var exception = event.exception && event.exception.values && event.exception.values[0];
        if (exception && exception.value) {
          exception.value = utils_1.truncate(exception.value, maxValueLength);
        }
        var request = event.request;
        if (request && request.url) {
          request.url = utils_1.truncate(request.url, maxValueLength);
        }
      };
      BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
        var integrationsArray = Object.keys(this._integrations);
        if (integrationsArray.length > 0) {
          event.sdk = event.sdk || {};
          event.sdk.integrations = tslib_1.__spread(event.sdk.integrations || [], integrationsArray);
        }
      };
      BaseClient2.prototype._sendEvent = function(event) {
        this._getBackend().sendEvent(event);
      };
      BaseClient2.prototype._captureEvent = function(event, hint, scope) {
        return this._processEvent(event, hint, scope).then(function(finalEvent) {
          return finalEvent.event_id;
        }, function(reason) {
          utils_1.logger.error(reason);
          return void 0;
        });
      };
      BaseClient2.prototype._processEvent = function(event, hint, scope) {
        var _this = this;
        var _a4 = this.getOptions(), beforeSend = _a4.beforeSend, sampleRate = _a4.sampleRate;
        var transport = this.getTransport();
        function recordLostEvent(outcome, category) {
          if (transport.recordLostEvent) {
            transport.recordLostEvent(outcome, category);
          }
        }
        if (!this._isEnabled()) {
          return utils_1.rejectedSyncPromise(new utils_1.SentryError("SDK not enabled, will not capture event."));
        }
        var isTransaction = event.type === "transaction";
        if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
          recordLostEvent("sample_rate", "event");
          return utils_1.rejectedSyncPromise(new utils_1.SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
        }
        return this._prepareEvent(event, scope, hint).then(function(prepared) {
          if (prepared === null) {
            recordLostEvent("event_processor", event.type || "event");
            throw new utils_1.SentryError("An event processor returned null, will not send event.");
          }
          var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
          if (isInternalException || isTransaction || !beforeSend) {
            return prepared;
          }
          var beforeSendResult = beforeSend(prepared, hint);
          return _ensureBeforeSendRv(beforeSendResult);
        }).then(function(processedEvent) {
          if (processedEvent === null) {
            recordLostEvent("before_send", event.type || "event");
            throw new utils_1.SentryError("`beforeSend` returned `null`, will not send event.");
          }
          var session = scope && scope.getSession && scope.getSession();
          if (!isTransaction && session) {
            _this._updateSessionFromEvent(session, processedEvent);
          }
          _this._sendEvent(processedEvent);
          return processedEvent;
        }).then(null, function(reason) {
          if (reason instanceof utils_1.SentryError) {
            throw reason;
          }
          _this.captureException(reason, {
            data: {
              __sentry__: true
            },
            originalException: reason
          });
          throw new utils_1.SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
        });
      };
      BaseClient2.prototype._process = function(promise) {
        var _this = this;
        this._numProcessing += 1;
        void promise.then(function(value) {
          _this._numProcessing -= 1;
          return value;
        }, function(reason) {
          _this._numProcessing -= 1;
          return reason;
        });
      };
      return BaseClient2;
    }();
    exports.BaseClient = BaseClient;
    function _ensureBeforeSendRv(rv) {
      var nullErr = "`beforeSend` method has to return `null` or a valid event.";
      if (utils_1.isThenable(rv)) {
        return rv.then(function(event) {
          if (!(utils_1.isPlainObject(event) || event === null)) {
            throw new utils_1.SentryError(nullErr);
          }
          return event;
        }, function(e2) {
          throw new utils_1.SentryError("beforeSend rejected with " + e2);
        });
      } else if (!(utils_1.isPlainObject(rv) || rv === null)) {
        throw new utils_1.SentryError(nullErr);
      }
      return rv;
    }
  }
});

// node_modules/@sentry/core/dist/transports/noop.js
var require_noop = __commonJS({
  "node_modules/@sentry/core/dist/transports/noop.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var NoopTransport = function() {
      function NoopTransport2() {
      }
      NoopTransport2.prototype.sendEvent = function(_) {
        return utils_1.resolvedSyncPromise({
          reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
          status: "skipped"
        });
      };
      NoopTransport2.prototype.close = function(_) {
        return utils_1.resolvedSyncPromise(true);
      };
      return NoopTransport2;
    }();
    exports.NoopTransport = NoopTransport;
  }
});

// node_modules/@sentry/core/dist/basebackend.js
var require_basebackend = __commonJS({
  "node_modules/@sentry/core/dist/basebackend.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var noop_1 = require_noop();
    var BaseBackend = function() {
      function BaseBackend2(options) {
        this._options = options;
        if (!this._options.dsn) {
          utils_1.logger.warn("No DSN provided, backend will not do anything.");
        }
        this._transport = this._setupTransport();
      }
      BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
        throw new utils_1.SentryError("Backend has to implement `eventFromException` method");
      };
      BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
        throw new utils_1.SentryError("Backend has to implement `eventFromMessage` method");
      };
      BaseBackend2.prototype.sendEvent = function(event) {
        void this._transport.sendEvent(event).then(null, function(reason) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.error("Error while sending event: " + reason);
          }
        });
      };
      BaseBackend2.prototype.sendSession = function(session) {
        if (!this._transport.sendSession) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
          }
          return;
        }
        void this._transport.sendSession(session).then(null, function(reason) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.error("Error while sending session: " + reason);
          }
        });
      };
      BaseBackend2.prototype.getTransport = function() {
        return this._transport;
      };
      BaseBackend2.prototype._setupTransport = function() {
        return new noop_1.NoopTransport();
      };
      return BaseBackend2;
    }();
    exports.BaseBackend = BaseBackend;
  }
});

// node_modules/@sentry/core/dist/request.js
var require_request2 = __commonJS({
  "node_modules/@sentry/core/dist/request.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    var utils_1 = require_dist2();
    var api_1 = require_api();
    function getSdkMetadataForEnvelopeHeader(api) {
      if (!api.metadata || !api.metadata.sdk) {
        return;
      }
      var _a4 = api.metadata.sdk, name = _a4.name, version = _a4.version;
      return { name, version };
    }
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = tslib_1.__spread(event.sdk.integrations || [], sdkInfo.integrations || []);
      event.sdk.packages = tslib_1.__spread(event.sdk.packages || [], sdkInfo.packages || []);
      return event;
    }
    function sessionToSentryRequest(session, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var envelopeHeaders = JSON.stringify(tslib_1.__assign(tslib_1.__assign({ sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
      var type = "aggregates" in session ? "sessions" : "session";
      var itemHeaders = JSON.stringify({
        type
      });
      return {
        body: envelopeHeaders + "\n" + itemHeaders + "\n" + JSON.stringify(session),
        type,
        url: api_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
      };
    }
    exports.sessionToSentryRequest = sessionToSentryRequest;
    function eventToSentryRequest(event, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var eventType = event.type || "event";
      var useEnvelope = eventType === "transaction" || !!api.tunnel;
      var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
      var _a4 = transactionSampling || {}, samplingMethod = _a4.method, sampleRate = _a4.rate;
      enhanceEventWithSdkInfo(event, api.metadata.sdk);
      event.tags = event.tags || {};
      event.extra = event.extra || {};
      if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
      }
      delete event.sdkProcessingMetadata;
      var body;
      try {
        body = JSON.stringify(event);
      } catch (err) {
        event.tags.JSONStringifyError = true;
        event.extra.JSONStringifyError = err;
        try {
          body = JSON.stringify(utils_1.normalize(event));
        } catch (newErr) {
          var innerErr = newErr;
          body = JSON.stringify({
            message: "JSON.stringify error after renormalization",
            extra: { message: innerErr.message, stack: innerErr.stack }
          });
        }
      }
      var req = {
        body,
        type: eventType,
        url: useEnvelope ? api_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel) : api_1.getStoreEndpointWithUrlEncodedAuth(api.dsn)
      };
      if (useEnvelope) {
        var envelopeHeaders = JSON.stringify(tslib_1.__assign(tslib_1.__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
        var itemHeaders = JSON.stringify({
          type: eventType,
          sample_rates: [{ id: samplingMethod, rate: sampleRate }]
        });
        var envelope = envelopeHeaders + "\n" + itemHeaders + "\n" + req.body;
        req.body = envelope;
      }
      return req;
    }
    exports.eventToSentryRequest = eventToSentryRequest;
  }
});

// node_modules/@sentry/core/dist/sdk.js
var require_sdk = __commonJS({
  "node_modules/@sentry/core/dist/sdk.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    function initAndBind(clientClass, options) {
      if (options.debug === true) {
        utils_1.logger.enable();
      }
      var hub = hub_1.getCurrentHub();
      var scope = hub.getScope();
      if (scope) {
        scope.update(options.initialScope);
      }
      var client = new clientClass(options);
      hub.bindClient(client);
    }
    exports.initAndBind = initAndBind;
  }
});

// node_modules/@sentry/core/dist/version.js
var require_version8 = __commonJS({
  "node_modules/@sentry/core/dist/version.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_VERSION = "6.18.1";
  }
});

// node_modules/@sentry/core/dist/integrations/functiontostring.js
var require_functiontostring = __commonJS({
  "node_modules/@sentry/core/dist/integrations/functiontostring.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var originalFunctionToString;
    var FunctionToString = function() {
      function FunctionToString2() {
        this.name = FunctionToString2.id;
      }
      FunctionToString2.prototype.setupOnce = function() {
        originalFunctionToString = Function.prototype.toString;
        Function.prototype.toString = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var context = utils_1.getOriginalFunction(this) || this;
          return originalFunctionToString.apply(context, args);
        };
      };
      FunctionToString2.id = "FunctionToString";
      return FunctionToString2;
    }();
    exports.FunctionToString = FunctionToString;
  }
});

// node_modules/@sentry/core/dist/integrations/inboundfilters.js
var require_inboundfilters = __commonJS({
  "node_modules/@sentry/core/dist/integrations/inboundfilters.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    var InboundFilters = function() {
      function InboundFilters2(_options) {
        if (_options === void 0) {
          _options = {};
        }
        this._options = _options;
        this.name = InboundFilters2.id;
      }
      InboundFilters2.prototype.setupOnce = function() {
        hub_1.addGlobalEventProcessor(function(event) {
          var hub = hub_1.getCurrentHub();
          if (!hub) {
            return event;
          }
          var self2 = hub.getIntegration(InboundFilters2);
          if (self2) {
            var client = hub.getClient();
            var clientOptions = client ? client.getOptions() : {};
            var options = typeof self2._mergeOptions === "function" ? self2._mergeOptions(clientOptions) : {};
            if (typeof self2._shouldDropEvent !== "function") {
              return event;
            }
            return self2._shouldDropEvent(event, options) ? null : event;
          }
          return event;
        });
      };
      InboundFilters2.prototype._shouldDropEvent = function(event, options) {
        if (this._isSentryError(event, options)) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + utils_1.getEventDescription(event));
          }
          return true;
        }
        if (this._isIgnoredError(event, options)) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + utils_1.getEventDescription(event));
          }
          return true;
        }
        if (this._isDeniedUrl(event, options)) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
          }
          return true;
        }
        if (!this._isAllowedUrl(event, options)) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
          }
          return true;
        }
        return false;
      };
      InboundFilters2.prototype._isSentryError = function(event, options) {
        if (!options.ignoreInternal) {
          return false;
        }
        try {
          return event.exception.values[0].type === "SentryError";
        } catch (e2) {
        }
        return false;
      };
      InboundFilters2.prototype._isIgnoredError = function(event, options) {
        if (!options.ignoreErrors || !options.ignoreErrors.length) {
          return false;
        }
        return this._getPossibleEventMessages(event).some(function(message) {
          return options.ignoreErrors.some(function(pattern) {
            return utils_1.isMatchingPattern(message, pattern);
          });
        });
      };
      InboundFilters2.prototype._isDeniedUrl = function(event, options) {
        if (!options.denyUrls || !options.denyUrls.length) {
          return false;
        }
        var url = this._getEventFilterUrl(event);
        return !url ? false : options.denyUrls.some(function(pattern) {
          return utils_1.isMatchingPattern(url, pattern);
        });
      };
      InboundFilters2.prototype._isAllowedUrl = function(event, options) {
        if (!options.allowUrls || !options.allowUrls.length) {
          return true;
        }
        var url = this._getEventFilterUrl(event);
        return !url ? true : options.allowUrls.some(function(pattern) {
          return utils_1.isMatchingPattern(url, pattern);
        });
      };
      InboundFilters2.prototype._mergeOptions = function(clientOptions) {
        if (clientOptions === void 0) {
          clientOptions = {};
        }
        return {
          allowUrls: tslib_1.__spread(this._options.whitelistUrls || [], this._options.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
          denyUrls: tslib_1.__spread(this._options.blacklistUrls || [], this._options.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
          ignoreErrors: tslib_1.__spread(this._options.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
          ignoreInternal: typeof this._options.ignoreInternal !== "undefined" ? this._options.ignoreInternal : true
        };
      };
      InboundFilters2.prototype._getPossibleEventMessages = function(event) {
        if (event.message) {
          return [event.message];
        }
        if (event.exception) {
          try {
            var _a4 = event.exception.values && event.exception.values[0] || {}, _b = _a4.type, type = _b === void 0 ? "" : _b, _c = _a4.value, value = _c === void 0 ? "" : _c;
            return ["" + value, type + ": " + value];
          } catch (oO) {
            if (utils_1.isDebugBuild()) {
              utils_1.logger.error("Cannot extract message for event " + utils_1.getEventDescription(event));
            }
            return [];
          }
        }
        return [];
      };
      InboundFilters2.prototype._getLastValidUrl = function(frames) {
        if (frames === void 0) {
          frames = [];
        }
        for (var i2 = frames.length - 1; i2 >= 0; i2--) {
          var frame = frames[i2];
          if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
            return frame.filename || null;
          }
        }
        return null;
      };
      InboundFilters2.prototype._getEventFilterUrl = function(event) {
        try {
          if (event.stacktrace) {
            return this._getLastValidUrl(event.stacktrace.frames);
          }
          var frames_1;
          try {
            frames_1 = event.exception.values[0].stacktrace.frames;
          } catch (e2) {
          }
          return frames_1 ? this._getLastValidUrl(frames_1) : null;
        } catch (oO) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.error("Cannot extract url for event " + utils_1.getEventDescription(event));
          }
          return null;
        }
      };
      InboundFilters2.id = "InboundFilters";
      return InboundFilters2;
    }();
    exports.InboundFilters = InboundFilters;
  }
});

// node_modules/@sentry/core/dist/integrations/index.js
var require_integrations = __commonJS({
  "node_modules/@sentry/core/dist/integrations/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var functiontostring_1 = require_functiontostring();
    exports.FunctionToString = functiontostring_1.FunctionToString;
    var inboundfilters_1 = require_inboundfilters();
    exports.InboundFilters = inboundfilters_1.InboundFilters;
  }
});

// node_modules/@sentry/core/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@sentry/core/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var minimal_1 = require_dist4();
    exports.addBreadcrumb = minimal_1.addBreadcrumb;
    exports.captureException = minimal_1.captureException;
    exports.captureEvent = minimal_1.captureEvent;
    exports.captureMessage = minimal_1.captureMessage;
    exports.configureScope = minimal_1.configureScope;
    exports.startTransaction = minimal_1.startTransaction;
    exports.setContext = minimal_1.setContext;
    exports.setExtra = minimal_1.setExtra;
    exports.setExtras = minimal_1.setExtras;
    exports.setTag = minimal_1.setTag;
    exports.setTags = minimal_1.setTags;
    exports.setUser = minimal_1.setUser;
    exports.withScope = minimal_1.withScope;
    var hub_1 = require_dist3();
    exports.addGlobalEventProcessor = hub_1.addGlobalEventProcessor;
    exports.getCurrentHub = hub_1.getCurrentHub;
    exports.getHubFromCarrier = hub_1.getHubFromCarrier;
    exports.Hub = hub_1.Hub;
    exports.makeMain = hub_1.makeMain;
    exports.Scope = hub_1.Scope;
    exports.Session = hub_1.Session;
    var api_1 = require_api();
    exports.API = api_1.API;
    exports.getEnvelopeEndpointWithUrlEncodedAuth = api_1.getEnvelopeEndpointWithUrlEncodedAuth;
    exports.getStoreEndpointWithUrlEncodedAuth = api_1.getStoreEndpointWithUrlEncodedAuth;
    exports.getRequestHeaders = api_1.getRequestHeaders;
    exports.initAPIDetails = api_1.initAPIDetails;
    exports.getReportDialogEndpoint = api_1.getReportDialogEndpoint;
    var baseclient_1 = require_baseclient();
    exports.BaseClient = baseclient_1.BaseClient;
    var basebackend_1 = require_basebackend();
    exports.BaseBackend = basebackend_1.BaseBackend;
    var request_1 = require_request2();
    exports.eventToSentryRequest = request_1.eventToSentryRequest;
    exports.sessionToSentryRequest = request_1.sessionToSentryRequest;
    var sdk_1 = require_sdk();
    exports.initAndBind = sdk_1.initAndBind;
    var noop_1 = require_noop();
    exports.NoopTransport = noop_1.NoopTransport;
    var version_1 = require_version8();
    exports.SDK_VERSION = version_1.SDK_VERSION;
    var Integrations2 = require_integrations();
    exports.Integrations = Integrations2;
  }
});

// node_modules/@sentry/browser/dist/stack-parsers.js
var require_stack_parsers = __commonJS({
  "node_modules/@sentry/browser/dist/stack-parsers.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var UNKNOWN_FUNCTION = "?";
    function createFrame(filename, func, lineno, colno) {
      var frame = {
        filename,
        function: func,
        in_app: true
      };
      if (lineno !== void 0) {
        frame.lineno = lineno;
      }
      if (colno !== void 0) {
        frame.colno = colno;
      }
      return frame;
    }
    var chromeRegex = /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    exports.chrome = function(line) {
      var parts = chromeRegex.exec(line);
      if (parts) {
        var isEval = parts[2] && parts[2].indexOf("eval") === 0;
        if (isEval) {
          var subMatch = chromeEvalRegex.exec(parts[2]);
          if (subMatch) {
            parts[2] = subMatch[1];
            parts[3] = subMatch[2];
            parts[4] = subMatch[3];
          }
        }
        var _a4 = tslib_1.__read(extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]), 2), func = _a4[0], filename = _a4[1];
        return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
      }
      return;
    };
    var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
    var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    exports.gecko = function(line) {
      var _a4;
      var parts = geckoREgex.exec(line);
      if (parts) {
        var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
        if (isEval) {
          var subMatch = geckoEvalRegex.exec(parts[3]);
          if (subMatch) {
            parts[1] = parts[1] || "eval";
            parts[3] = subMatch[1];
            parts[4] = subMatch[2];
            parts[5] = "";
          }
        }
        var filename = parts[3];
        var func = parts[1] || UNKNOWN_FUNCTION;
        _a4 = tslib_1.__read(extractSafariExtensionDetails(func, filename), 2), func = _a4[0], filename = _a4[1];
        return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
      }
      return;
    };
    var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    exports.winjs = function(line) {
      var parts = winjsRegex.exec(line);
      return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
    };
    var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
    exports.opera10 = function(line) {
      var parts = opera10Regex.exec(line);
      return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : void 0;
    };
    var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;
    exports.opera11 = function(line) {
      var parts = opera11Regex.exec(line);
      return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : void 0;
    };
    var extractSafariExtensionDetails = function(func, filename) {
      var isSafariExtension = func.indexOf("safari-extension") !== -1;
      var isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
      return isSafariExtension || isSafariWebExtension ? [
        func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
        isSafariExtension ? "safari-extension:" + filename : "safari-web-extension:" + filename
      ] : [func, filename];
    };
  }
});

// node_modules/@sentry/browser/dist/parsers.js
var require_parsers = __commonJS({
  "node_modules/@sentry/browser/dist/parsers.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var stack_parsers_1 = require_stack_parsers();
    function exceptionFromError(ex) {
      var frames = parseStackFrames(ex);
      var exception = {
        type: ex && ex.name,
        value: extractMessage(ex)
      };
      if (frames && frames.length) {
        exception.stacktrace = { frames };
      }
      if (exception.type === void 0 && exception.value === "") {
        exception.value = "Unrecoverable error caught";
      }
      return exception;
    }
    exports.exceptionFromError = exceptionFromError;
    function eventFromPlainObject(exception, syntheticException, rejection) {
      var event = {
        exception: {
          values: [
            {
              type: utils_1.isEvent(exception) ? exception.constructor.name : rejection ? "UnhandledRejection" : "Error",
              value: "Non-Error " + (rejection ? "promise rejection" : "exception") + " captured with keys: " + utils_1.extractExceptionKeysForMessage(exception)
            }
          ]
        },
        extra: {
          __serialized__: utils_1.normalizeToSize(exception)
        }
      };
      if (syntheticException) {
        var frames_1 = parseStackFrames(syntheticException);
        if (frames_1.length) {
          event.stacktrace = { frames: frames_1 };
        }
      }
      return event;
    }
    exports.eventFromPlainObject = eventFromPlainObject;
    function eventFromError(ex) {
      return {
        exception: {
          values: [exceptionFromError(ex)]
        }
      };
    }
    exports.eventFromError = eventFromError;
    function parseStackFrames(ex) {
      var stacktrace = ex.stacktrace || ex.stack || "";
      var popSize = getPopSize(ex);
      try {
        return utils_1.createStackParser(stack_parsers_1.opera10, stack_parsers_1.opera11, stack_parsers_1.chrome, stack_parsers_1.winjs, stack_parsers_1.gecko)(stacktrace, popSize);
      } catch (e2) {
      }
      return [];
    }
    exports.parseStackFrames = parseStackFrames;
    var reactMinifiedRegexp = /Minified React error #\d+;/i;
    function getPopSize(ex) {
      if (ex) {
        if (typeof ex.framesToPop === "number") {
          return ex.framesToPop;
        }
        if (reactMinifiedRegexp.test(ex.message)) {
          return 1;
        }
      }
      return 0;
    }
    function extractMessage(ex) {
      var message = ex && ex.message;
      if (!message) {
        return "No error message";
      }
      if (message.error && typeof message.error.message === "string") {
        return message.error.message;
      }
      return message;
    }
  }
});

// node_modules/@sentry/browser/dist/eventbuilder.js
var require_eventbuilder = __commonJS({
  "node_modules/@sentry/browser/dist/eventbuilder.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var parsers_1 = require_parsers();
    function eventFromException(options, exception, hint) {
      var syntheticException = hint && hint.syntheticException || void 0;
      var event = eventFromUnknownInput(exception, syntheticException, {
        attachStacktrace: options.attachStacktrace
      });
      utils_1.addExceptionMechanism(event);
      event.level = types_1.Severity.Error;
      if (hint && hint.event_id) {
        event.event_id = hint.event_id;
      }
      return utils_1.resolvedSyncPromise(event);
    }
    exports.eventFromException = eventFromException;
    function eventFromMessage(options, message, level, hint) {
      if (level === void 0) {
        level = types_1.Severity.Info;
      }
      var syntheticException = hint && hint.syntheticException || void 0;
      var event = eventFromString(message, syntheticException, {
        attachStacktrace: options.attachStacktrace
      });
      event.level = level;
      if (hint && hint.event_id) {
        event.event_id = hint.event_id;
      }
      return utils_1.resolvedSyncPromise(event);
    }
    exports.eventFromMessage = eventFromMessage;
    function eventFromUnknownInput(exception, syntheticException, options) {
      if (options === void 0) {
        options = {};
      }
      var event;
      if (utils_1.isErrorEvent(exception) && exception.error) {
        var errorEvent = exception;
        return parsers_1.eventFromError(errorEvent.error);
      }
      if (utils_1.isDOMError(exception) || utils_1.isDOMException(exception)) {
        var domException = exception;
        if ("stack" in exception) {
          event = parsers_1.eventFromError(exception);
        } else {
          var name_1 = domException.name || (utils_1.isDOMError(domException) ? "DOMError" : "DOMException");
          var message = domException.message ? name_1 + ": " + domException.message : name_1;
          event = eventFromString(message, syntheticException, options);
          utils_1.addExceptionTypeValue(event, message);
        }
        if ("code" in domException) {
          event.tags = tslib_1.__assign(tslib_1.__assign({}, event.tags), { "DOMException.code": "" + domException.code });
        }
        return event;
      }
      if (utils_1.isError(exception)) {
        return parsers_1.eventFromError(exception);
      }
      if (utils_1.isPlainObject(exception) || utils_1.isEvent(exception)) {
        var objectException = exception;
        event = parsers_1.eventFromPlainObject(objectException, syntheticException, options.isRejection);
        utils_1.addExceptionMechanism(event, {
          synthetic: true
        });
        return event;
      }
      event = eventFromString(exception, syntheticException, options);
      utils_1.addExceptionTypeValue(event, "" + exception, void 0);
      utils_1.addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    exports.eventFromUnknownInput = eventFromUnknownInput;
    function eventFromString(input, syntheticException, options) {
      if (options === void 0) {
        options = {};
      }
      var event = {
        message: input
      };
      if (options.attachStacktrace && syntheticException) {
        var frames_1 = parsers_1.parseStackFrames(syntheticException);
        if (frames_1.length) {
          event.stacktrace = { frames: frames_1 };
        }
      }
      return event;
    }
    exports.eventFromString = eventFromString;
  }
});

// node_modules/@sentry/browser/dist/transports/utils.js
var require_utils7 = __commonJS({
  "node_modules/@sentry/browser/dist/transports/utils.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var global2 = utils_1.getGlobalObject();
    var cachedFetchImpl;
    function getNativeFetchImplementation() {
      if (cachedFetchImpl) {
        return cachedFetchImpl;
      }
      if (utils_1.isNativeFetch(global2.fetch)) {
        return cachedFetchImpl = global2.fetch.bind(global2);
      }
      var document2 = global2.document;
      var fetchImpl = global2.fetch;
      if (document2 && typeof document2.createElement === "function") {
        try {
          var sandbox = document2.createElement("iframe");
          sandbox.hidden = true;
          document2.head.appendChild(sandbox);
          var contentWindow = sandbox.contentWindow;
          if (contentWindow && contentWindow.fetch) {
            fetchImpl = contentWindow.fetch;
          }
          document2.head.removeChild(sandbox);
        } catch (e2) {
          if (utils_1.isDebugBuild()) {
            utils_1.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e2);
          }
        }
      }
      return cachedFetchImpl = fetchImpl.bind(global2);
    }
    exports.getNativeFetchImplementation = getNativeFetchImplementation;
    function sendReport(url, body) {
      var isRealNavigator = Object.prototype.toString.call(global2 && global2.navigator) === "[object Navigator]";
      var hasSendBeacon = isRealNavigator && typeof global2.navigator.sendBeacon === "function";
      if (hasSendBeacon) {
        var sendBeacon = global2.navigator.sendBeacon.bind(global2.navigator);
        return sendBeacon(url, body);
      }
      if (utils_1.supportsFetch()) {
        var fetch_1 = getNativeFetchImplementation();
        return utils_1.forget(fetch_1(url, {
          body,
          method: "POST",
          credentials: "omit",
          keepalive: true
        }));
      }
    }
    exports.sendReport = sendReport;
  }
});

// node_modules/@sentry/browser/dist/transports/base.js
var require_base = __commonJS({
  "node_modules/@sentry/browser/dist/transports/base.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var utils_2 = require_utils7();
    function requestTypeToCategory(ty) {
      var tyStr = ty;
      return tyStr === "event" ? "error" : tyStr;
    }
    var global2 = utils_1.getGlobalObject();
    var BaseTransport = function() {
      function BaseTransport2(options) {
        var _this = this;
        this.options = options;
        this._buffer = utils_1.makePromiseBuffer(30);
        this._rateLimits = {};
        this._outcomes = {};
        this._api = core_1.initAPIDetails(options.dsn, options._metadata, options.tunnel);
        this.url = core_1.getStoreEndpointWithUrlEncodedAuth(this._api.dsn);
        if (this.options.sendClientReports && global2.document) {
          global2.document.addEventListener("visibilitychange", function() {
            if (global2.document.visibilityState === "hidden") {
              _this._flushOutcomes();
            }
          });
        }
      }
      BaseTransport2.prototype.sendEvent = function(event) {
        return this._sendRequest(core_1.eventToSentryRequest(event, this._api), event);
      };
      BaseTransport2.prototype.sendSession = function(session) {
        return this._sendRequest(core_1.sessionToSentryRequest(session, this._api), session);
      };
      BaseTransport2.prototype.close = function(timeout) {
        return this._buffer.drain(timeout);
      };
      BaseTransport2.prototype.recordLostEvent = function(reason, category) {
        var _a4;
        if (!this.options.sendClientReports) {
          return;
        }
        var key2 = requestTypeToCategory(category) + ":" + reason;
        utils_1.logger.log("Adding outcome: " + key2);
        this._outcomes[key2] = (_a4 = this._outcomes[key2], _a4 !== null && _a4 !== void 0 ? _a4 : 0) + 1;
      };
      BaseTransport2.prototype._flushOutcomes = function() {
        if (!this.options.sendClientReports) {
          return;
        }
        var outcomes = this._outcomes;
        this._outcomes = {};
        if (!Object.keys(outcomes).length) {
          utils_1.logger.log("No outcomes to flush");
          return;
        }
        utils_1.logger.log("Flushing outcomes:\n" + JSON.stringify(outcomes, null, 2));
        var url = core_1.getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);
        var discardedEvents = Object.keys(outcomes).map(function(key2) {
          var _a4 = tslib_1.__read(key2.split(":"), 2), category = _a4[0], reason = _a4[1];
          return {
            reason,
            category,
            quantity: outcomes[key2]
          };
        });
        var envelope = utils_1.createClientReportEnvelope(discardedEvents, this._api.tunnel && utils_1.dsnToString(this._api.dsn));
        try {
          utils_2.sendReport(url, utils_1.serializeEnvelope(envelope));
        } catch (e2) {
          utils_1.logger.error(e2);
        }
      };
      BaseTransport2.prototype._handleResponse = function(_a4) {
        var requestType = _a4.requestType, response = _a4.response, headers = _a4.headers, resolve2 = _a4.resolve, reject = _a4.reject;
        var status = utils_1.eventStatusFromHttpCode(response.status);
        var limited = this._handleRateLimit(headers);
        if (limited && utils_1.isDebugBuild()) {
          utils_1.logger.warn("Too many " + requestType + " requests, backing off until: " + this._disabledUntil(requestType));
        }
        if (status === "success") {
          resolve2({ status });
          return;
        }
        reject(response);
      };
      BaseTransport2.prototype._disabledUntil = function(requestType) {
        var category = requestTypeToCategory(requestType);
        return this._rateLimits[category] || this._rateLimits.all;
      };
      BaseTransport2.prototype._isRateLimited = function(requestType) {
        return this._disabledUntil(requestType) > new Date(Date.now());
      };
      BaseTransport2.prototype._handleRateLimit = function(headers) {
        var e_1, _a4, e_2, _b;
        var now = Date.now();
        var rlHeader = headers["x-sentry-rate-limits"];
        var raHeader = headers["retry-after"];
        if (rlHeader) {
          try {
            for (var _c = tslib_1.__values(rlHeader.trim().split(",")), _d2 = _c.next(); !_d2.done; _d2 = _c.next()) {
              var limit = _d2.value;
              var parameters = limit.split(":", 2);
              var headerDelay = parseInt(parameters[0], 10);
              var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
              try {
                for (var _e = (e_2 = void 0, tslib_1.__values(parameters[1].split(";"))), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var category = _f.value;
                  this._rateLimits[category || "all"] = new Date(now + delay);
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return))
                    _b.call(_e);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_d2 && !_d2.done && (_a4 = _c.return))
                _a4.call(_c);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return true;
        } else if (raHeader) {
          this._rateLimits.all = new Date(now + utils_1.parseRetryAfterHeader(now, raHeader));
          return true;
        }
        return false;
      };
      return BaseTransport2;
    }();
    exports.BaseTransport = BaseTransport;
  }
});

// node_modules/@sentry/browser/dist/transports/fetch.js
var require_fetch3 = __commonJS({
  "node_modules/@sentry/browser/dist/transports/fetch.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var base_1 = require_base();
    var utils_2 = require_utils7();
    var FetchTransport = function(_super) {
      tslib_1.__extends(FetchTransport2, _super);
      function FetchTransport2(options, fetchImpl) {
        if (fetchImpl === void 0) {
          fetchImpl = utils_2.getNativeFetchImplementation();
        }
        var _this = _super.call(this, options) || this;
        _this._fetch = fetchImpl;
        return _this;
      }
      FetchTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
        var _this = this;
        if (this._isRateLimited(sentryRequest.type)) {
          this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
          return Promise.reject({
            event: originalPayload,
            type: sentryRequest.type,
            reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
            status: 429
          });
        }
        var options = {
          body: sentryRequest.body,
          method: "POST",
          referrerPolicy: utils_1.supportsReferrerPolicy() ? "origin" : ""
        };
        if (this.options.fetchParameters !== void 0) {
          Object.assign(options, this.options.fetchParameters);
        }
        if (this.options.headers !== void 0) {
          options.headers = this.options.headers;
        }
        return this._buffer.add(function() {
          return new utils_1.SyncPromise(function(resolve2, reject) {
            void _this._fetch(sentryRequest.url, options).then(function(response) {
              var headers = {
                "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
                "retry-after": response.headers.get("Retry-After")
              };
              _this._handleResponse({
                requestType: sentryRequest.type,
                response,
                headers,
                resolve: resolve2,
                reject
              });
            }).catch(reject);
          });
        }).then(void 0, function(reason) {
          if (reason instanceof utils_1.SentryError) {
            _this.recordLostEvent("queue_overflow", sentryRequest.type);
          } else {
            _this.recordLostEvent("network_error", sentryRequest.type);
          }
          throw reason;
        });
      };
      return FetchTransport2;
    }(base_1.BaseTransport);
    exports.FetchTransport = FetchTransport;
  }
});

// node_modules/@sentry/browser/dist/transports/xhr.js
var require_xhr = __commonJS({
  "node_modules/@sentry/browser/dist/transports/xhr.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var base_1 = require_base();
    var XHRTransport = function(_super) {
      tslib_1.__extends(XHRTransport2, _super);
      function XHRTransport2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      XHRTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
        var _this = this;
        if (this._isRateLimited(sentryRequest.type)) {
          this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
          return Promise.reject({
            event: originalPayload,
            type: sentryRequest.type,
            reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
            status: 429
          });
        }
        return this._buffer.add(function() {
          return new utils_1.SyncPromise(function(resolve2, reject) {
            var request = new XMLHttpRequest();
            request.onreadystatechange = function() {
              if (request.readyState === 4) {
                var headers = {
                  "x-sentry-rate-limits": request.getResponseHeader("X-Sentry-Rate-Limits"),
                  "retry-after": request.getResponseHeader("Retry-After")
                };
                _this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve: resolve2, reject });
              }
            };
            request.open("POST", sentryRequest.url);
            for (var header in _this.options.headers) {
              if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {
                request.setRequestHeader(header, _this.options.headers[header]);
              }
            }
            request.send(sentryRequest.body);
          });
        }).then(void 0, function(reason) {
          if (reason instanceof utils_1.SentryError) {
            _this.recordLostEvent("queue_overflow", sentryRequest.type);
          } else {
            _this.recordLostEvent("network_error", sentryRequest.type);
          }
          throw reason;
        });
      };
      return XHRTransport2;
    }(base_1.BaseTransport);
    exports.XHRTransport = XHRTransport;
  }
});

// node_modules/@sentry/browser/dist/transports/index.js
var require_transports = __commonJS({
  "node_modules/@sentry/browser/dist/transports/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    exports.BaseTransport = base_1.BaseTransport;
    var fetch_1 = require_fetch3();
    exports.FetchTransport = fetch_1.FetchTransport;
    var xhr_1 = require_xhr();
    exports.XHRTransport = xhr_1.XHRTransport;
  }
});

// node_modules/@sentry/browser/dist/backend.js
var require_backend = __commonJS({
  "node_modules/@sentry/browser/dist/backend.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var eventbuilder_1 = require_eventbuilder();
    var transports_1 = require_transports();
    var BrowserBackend = function(_super) {
      tslib_1.__extends(BrowserBackend2, _super);
      function BrowserBackend2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      BrowserBackend2.prototype.eventFromException = function(exception, hint) {
        return eventbuilder_1.eventFromException(this._options, exception, hint);
      };
      BrowserBackend2.prototype.eventFromMessage = function(message, level, hint) {
        if (level === void 0) {
          level = types_1.Severity.Info;
        }
        return eventbuilder_1.eventFromMessage(this._options, message, level, hint);
      };
      BrowserBackend2.prototype._setupTransport = function() {
        if (!this._options.dsn) {
          return _super.prototype._setupTransport.call(this);
        }
        var transportOptions = tslib_1.__assign(tslib_1.__assign({}, this._options.transportOptions), { dsn: this._options.dsn, tunnel: this._options.tunnel, sendClientReports: this._options.sendClientReports, _metadata: this._options._metadata });
        if (this._options.transport) {
          return new this._options.transport(transportOptions);
        }
        if (utils_1.supportsFetch()) {
          return new transports_1.FetchTransport(transportOptions);
        }
        return new transports_1.XHRTransport(transportOptions);
      };
      return BrowserBackend2;
    }(core_1.BaseBackend);
    exports.BrowserBackend = BrowserBackend;
  }
});

// node_modules/@sentry/browser/dist/helpers.js
var require_helpers4 = __commonJS({
  "node_modules/@sentry/browser/dist/helpers.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var global2 = utils_1.getGlobalObject();
    var ignoreOnError = 0;
    function shouldIgnoreOnError() {
      return ignoreOnError > 0;
    }
    exports.shouldIgnoreOnError = shouldIgnoreOnError;
    function ignoreNextOnError() {
      ignoreOnError += 1;
      setTimeout(function() {
        ignoreOnError -= 1;
      });
    }
    exports.ignoreNextOnError = ignoreNextOnError;
    function wrap(fn, options, before) {
      if (options === void 0) {
        options = {};
      }
      if (typeof fn !== "function") {
        return fn;
      }
      try {
        var wrapper = fn.__sentry_wrapped__;
        if (wrapper) {
          return wrapper;
        }
        if (utils_1.getOriginalFunction(fn)) {
          return fn;
        }
      } catch (e2) {
        return fn;
      }
      var sentryWrapped = function() {
        var args = Array.prototype.slice.call(arguments);
        try {
          if (before && typeof before === "function") {
            before.apply(this, arguments);
          }
          var wrappedArguments = args.map(function(arg) {
            return wrap(arg, options);
          });
          return fn.apply(this, wrappedArguments);
        } catch (ex) {
          ignoreNextOnError();
          core_1.withScope(function(scope) {
            scope.addEventProcessor(function(event) {
              if (options.mechanism) {
                utils_1.addExceptionTypeValue(event, void 0, void 0);
                utils_1.addExceptionMechanism(event, options.mechanism);
              }
              event.extra = tslib_1.__assign(tslib_1.__assign({}, event.extra), { arguments: args });
              return event;
            });
            core_1.captureException(ex);
          });
          throw ex;
        }
      };
      try {
        for (var property in fn) {
          if (Object.prototype.hasOwnProperty.call(fn, property)) {
            sentryWrapped[property] = fn[property];
          }
        }
      } catch (_oO) {
      }
      utils_1.markFunctionWrapped(sentryWrapped, fn);
      utils_1.addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
      try {
        var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
        if (descriptor.configurable) {
          Object.defineProperty(sentryWrapped, "name", {
            get: function() {
              return fn.name;
            }
          });
        }
      } catch (_oO) {
      }
      return sentryWrapped;
    }
    exports.wrap = wrap;
    function injectReportDialog(options) {
      if (options === void 0) {
        options = {};
      }
      if (!global2.document) {
        return;
      }
      if (!options.eventId) {
        if (utils_1.isDebugBuild()) {
          utils_1.logger.error("Missing eventId option in showReportDialog call");
        }
        return;
      }
      if (!options.dsn) {
        if (utils_1.isDebugBuild()) {
          utils_1.logger.error("Missing dsn option in showReportDialog call");
        }
        return;
      }
      var script = global2.document.createElement("script");
      script.async = true;
      script.src = core_1.getReportDialogEndpoint(options.dsn, options);
      if (options.onLoad) {
        script.onload = options.onLoad;
      }
      var injectionPoint = global2.document.head || global2.document.body;
      if (injectionPoint) {
        injectionPoint.appendChild(script);
      }
    }
    exports.injectReportDialog = injectReportDialog;
  }
});

// node_modules/@sentry/browser/dist/integrations/globalhandlers.js
var require_globalhandlers = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/globalhandlers.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var eventbuilder_1 = require_eventbuilder();
    var helpers_1 = require_helpers4();
    var GlobalHandlers = function() {
      function GlobalHandlers2(options) {
        this.name = GlobalHandlers2.id;
        this._installFunc = {
          onerror: _installGlobalOnErrorHandler,
          onunhandledrejection: _installGlobalOnUnhandledRejectionHandler
        };
        this._options = tslib_1.__assign({ onerror: true, onunhandledrejection: true }, options);
      }
      GlobalHandlers2.prototype.setupOnce = function() {
        Error.stackTraceLimit = 50;
        var options = this._options;
        for (var key2 in options) {
          var installFunc = this._installFunc[key2];
          if (installFunc && options[key2]) {
            globalHandlerLog(key2);
            installFunc();
            this._installFunc[key2] = void 0;
          }
        }
      };
      GlobalHandlers2.id = "GlobalHandlers";
      return GlobalHandlers2;
    }();
    exports.GlobalHandlers = GlobalHandlers;
    function _installGlobalOnErrorHandler() {
      utils_1.addInstrumentationHandler("error", function(data) {
        var _a4 = tslib_1.__read(getHubAndAttachStacktrace(), 2), hub = _a4[0], attachStacktrace = _a4[1];
        if (!hub.getIntegration(GlobalHandlers)) {
          return;
        }
        var msg = data.msg, url = data.url, line = data.line, column = data.column, error2 = data.error;
        if (helpers_1.shouldIgnoreOnError() || error2 && error2.__sentry_own_request__) {
          return;
        }
        var event = error2 === void 0 && utils_1.isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventbuilder_1.eventFromUnknownInput(error2 || msg, void 0, {
          attachStacktrace,
          isRejection: false
        }), url, line, column);
        event.level = types_1.Severity.Error;
        addMechanismAndCapture(hub, error2, event, "onerror");
      });
    }
    function _installGlobalOnUnhandledRejectionHandler() {
      utils_1.addInstrumentationHandler("unhandledrejection", function(e2) {
        var _a4 = tslib_1.__read(getHubAndAttachStacktrace(), 2), hub = _a4[0], attachStacktrace = _a4[1];
        if (!hub.getIntegration(GlobalHandlers)) {
          return;
        }
        var error2 = e2;
        try {
          if ("reason" in e2) {
            error2 = e2.reason;
          } else if ("detail" in e2 && "reason" in e2.detail) {
            error2 = e2.detail.reason;
          }
        } catch (_oO) {
        }
        if (helpers_1.shouldIgnoreOnError() || error2 && error2.__sentry_own_request__) {
          return true;
        }
        var event = utils_1.isPrimitive(error2) ? _eventFromRejectionWithPrimitive(error2) : eventbuilder_1.eventFromUnknownInput(error2, void 0, {
          attachStacktrace,
          isRejection: true
        });
        event.level = types_1.Severity.Error;
        addMechanismAndCapture(hub, error2, event, "onunhandledrejection");
        return;
      });
    }
    function _eventFromRejectionWithPrimitive(reason) {
      return {
        exception: {
          values: [
            {
              type: "UnhandledRejection",
              value: "Non-Error promise rejection captured with value: " + String(reason)
            }
          ]
        }
      };
    }
    function _eventFromIncompleteOnError(msg, url, line, column) {
      var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
      var message = utils_1.isErrorEvent(msg) ? msg.message : msg;
      var name = "Error";
      var groups = message.match(ERROR_TYPES_RE);
      if (groups) {
        name = groups[1];
        message = groups[2];
      }
      var event = {
        exception: {
          values: [
            {
              type: name,
              value: message
            }
          ]
        }
      };
      return _enhanceEventWithInitialFrame(event, url, line, column);
    }
    function _enhanceEventWithInitialFrame(event, url, line, column) {
      var e2 = event.exception = event.exception || {};
      var ev = e2.values = e2.values || [];
      var ev0 = ev[0] = ev[0] || {};
      var ev0s = ev0.stacktrace = ev0.stacktrace || {};
      var ev0sf = ev0s.frames = ev0s.frames || [];
      var colno = isNaN(parseInt(column, 10)) ? void 0 : column;
      var lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
      var filename = utils_1.isString(url) && url.length > 0 ? url : utils_1.getLocationHref();
      if (ev0sf.length === 0) {
        ev0sf.push({
          colno,
          filename,
          function: "?",
          in_app: true,
          lineno
        });
      }
      return event;
    }
    function globalHandlerLog(type) {
      if (utils_1.isDebugBuild()) {
        utils_1.logger.log("Global Handler attached: " + type);
      }
    }
    function addMechanismAndCapture(hub, error2, event, type) {
      utils_1.addExceptionMechanism(event, {
        handled: false,
        type
      });
      hub.captureEvent(event, {
        originalException: error2
      });
    }
    function getHubAndAttachStacktrace() {
      var hub = core_1.getCurrentHub();
      var client = hub.getClient();
      var attachStacktrace = client && client.getOptions().attachStacktrace;
      return [hub, attachStacktrace];
    }
  }
});

// node_modules/@sentry/browser/dist/integrations/trycatch.js
var require_trycatch = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/trycatch.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_dist2();
    var helpers_1 = require_helpers4();
    var DEFAULT_EVENT_TARGET = [
      "EventTarget",
      "Window",
      "Node",
      "ApplicationCache",
      "AudioTrackList",
      "ChannelMergerNode",
      "CryptoOperation",
      "EventSource",
      "FileReader",
      "HTMLUnknownElement",
      "IDBDatabase",
      "IDBRequest",
      "IDBTransaction",
      "KeyOperation",
      "MediaController",
      "MessagePort",
      "ModalWindow",
      "Notification",
      "SVGElementInstance",
      "Screen",
      "TextTrack",
      "TextTrackCue",
      "TextTrackList",
      "WebSocket",
      "WebSocketWorker",
      "Worker",
      "XMLHttpRequest",
      "XMLHttpRequestEventTarget",
      "XMLHttpRequestUpload"
    ];
    var TryCatch = function() {
      function TryCatch2(options) {
        this.name = TryCatch2.id;
        this._options = tslib_1.__assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
      }
      TryCatch2.prototype.setupOnce = function() {
        var global2 = utils_1.getGlobalObject();
        if (this._options.setTimeout) {
          utils_1.fill(global2, "setTimeout", _wrapTimeFunction);
        }
        if (this._options.setInterval) {
          utils_1.fill(global2, "setInterval", _wrapTimeFunction);
        }
        if (this._options.requestAnimationFrame) {
          utils_1.fill(global2, "requestAnimationFrame", _wrapRAF);
        }
        if (this._options.XMLHttpRequest && "XMLHttpRequest" in global2) {
          utils_1.fill(XMLHttpRequest.prototype, "send", _wrapXHR);
        }
        var eventTargetOption = this._options.eventTarget;
        if (eventTargetOption) {
          var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
          eventTarget.forEach(_wrapEventTarget);
        }
      };
      TryCatch2.id = "TryCatch";
      return TryCatch2;
    }();
    exports.TryCatch = TryCatch;
    function _wrapTimeFunction(original) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var originalCallback = args[0];
        args[0] = helpers_1.wrap(originalCallback, {
          mechanism: {
            data: { function: utils_1.getFunctionName(original) },
            handled: true,
            type: "instrument"
          }
        });
        return original.apply(this, args);
      };
    }
    function _wrapRAF(original) {
      return function(callback) {
        return original.call(this, helpers_1.wrap(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: utils_1.getFunctionName(original)
            },
            handled: true,
            type: "instrument"
          }
        }));
      };
    }
    function _wrapXHR(originalSend) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var xhr = this;
        var xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
        xmlHttpRequestProps.forEach(function(prop) {
          if (prop in xhr && typeof xhr[prop] === "function") {
            utils_1.fill(xhr, prop, function(original) {
              var wrapOptions = {
                mechanism: {
                  data: {
                    function: prop,
                    handler: utils_1.getFunctionName(original)
                  },
                  handled: true,
                  type: "instrument"
                }
              };
              var originalFunction = utils_1.getOriginalFunction(original);
              if (originalFunction) {
                wrapOptions.mechanism.data.handler = utils_1.getFunctionName(originalFunction);
              }
              return helpers_1.wrap(original, wrapOptions);
            });
          }
        });
        return originalSend.apply(this, args);
      };
    }
    function _wrapEventTarget(target) {
      var global2 = utils_1.getGlobalObject();
      var proto = global2[target] && global2[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      utils_1.fill(proto, "addEventListener", function(original) {
        return function(eventName, fn, options) {
          try {
            if (typeof fn.handleEvent === "function") {
              fn.handleEvent = helpers_1.wrap(fn.handleEvent.bind(fn), {
                mechanism: {
                  data: {
                    function: "handleEvent",
                    handler: utils_1.getFunctionName(fn),
                    target
                  },
                  handled: true,
                  type: "instrument"
                }
              });
            }
          } catch (err) {
          }
          return original.call(this, eventName, helpers_1.wrap(fn, {
            mechanism: {
              data: {
                function: "addEventListener",
                handler: utils_1.getFunctionName(fn),
                target
              },
              handled: true,
              type: "instrument"
            }
          }), options);
        };
      });
      utils_1.fill(proto, "removeEventListener", function(originalRemoveEventListener) {
        return function(eventName, fn, options) {
          var wrappedEventHandler = fn;
          try {
            var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          } catch (e2) {
          }
          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
        };
      });
    }
  }
});

// node_modules/@sentry/browser/dist/integrations/breadcrumbs.js
var require_breadcrumbs = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/breadcrumbs.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var types_1 = require_dist();
    var utils_1 = require_dist2();
    var Breadcrumbs = function() {
      function Breadcrumbs2(options) {
        this.name = Breadcrumbs2.id;
        this._options = tslib_1.__assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
      }
      Breadcrumbs2.prototype.addSentryBreadcrumb = function(event) {
        if (!this._options.sentry) {
          return;
        }
        core_1.getCurrentHub().addBreadcrumb({
          category: "sentry." + (event.type === "transaction" ? "transaction" : "event"),
          event_id: event.event_id,
          level: event.level,
          message: utils_1.getEventDescription(event)
        }, {
          event
        });
      };
      Breadcrumbs2.prototype.setupOnce = function() {
        if (this._options.console) {
          utils_1.addInstrumentationHandler("console", _consoleBreadcrumb);
        }
        if (this._options.dom) {
          utils_1.addInstrumentationHandler("dom", _domBreadcrumb(this._options.dom));
        }
        if (this._options.xhr) {
          utils_1.addInstrumentationHandler("xhr", _xhrBreadcrumb);
        }
        if (this._options.fetch) {
          utils_1.addInstrumentationHandler("fetch", _fetchBreadcrumb);
        }
        if (this._options.history) {
          utils_1.addInstrumentationHandler("history", _historyBreadcrumb);
        }
      };
      Breadcrumbs2.id = "Breadcrumbs";
      return Breadcrumbs2;
    }();
    exports.Breadcrumbs = Breadcrumbs;
    function _domBreadcrumb(dom) {
      function _innerDomBreadcrumb(handlerData) {
        var target;
        var keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
        if (typeof keyAttrs === "string") {
          keyAttrs = [keyAttrs];
        }
        try {
          target = handlerData.event.target ? utils_1.htmlTreeAsString(handlerData.event.target, keyAttrs) : utils_1.htmlTreeAsString(handlerData.event, keyAttrs);
        } catch (e2) {
          target = "<unknown>";
        }
        if (target.length === 0) {
          return;
        }
        core_1.getCurrentHub().addBreadcrumb({
          category: "ui." + handlerData.name,
          message: target
        }, {
          event: handlerData.event,
          name: handlerData.name,
          global: handlerData.global
        });
      }
      return _innerDomBreadcrumb;
    }
    function _consoleBreadcrumb(handlerData) {
      var breadcrumb = {
        category: "console",
        data: {
          arguments: handlerData.args,
          logger: "console"
        },
        level: utils_1.severityFromString(handlerData.level),
        message: utils_1.safeJoin(handlerData.args, " ")
      };
      if (handlerData.level === "assert") {
        if (handlerData.args[0] === false) {
          breadcrumb.message = "Assertion failed: " + (utils_1.safeJoin(handlerData.args.slice(1), " ") || "console.assert");
          breadcrumb.data.arguments = handlerData.args.slice(1);
        } else {
          return;
        }
      }
      core_1.getCurrentHub().addBreadcrumb(breadcrumb, {
        input: handlerData.args,
        level: handlerData.level
      });
    }
    function _xhrBreadcrumb(handlerData) {
      if (handlerData.endTimestamp) {
        if (handlerData.xhr.__sentry_own_request__) {
          return;
        }
        var _a4 = handlerData.xhr.__sentry_xhr__ || {}, method = _a4.method, url = _a4.url, status_code = _a4.status_code, body = _a4.body;
        core_1.getCurrentHub().addBreadcrumb({
          category: "xhr",
          data: {
            method,
            url,
            status_code
          },
          type: "http"
        }, {
          xhr: handlerData.xhr,
          input: body
        });
        return;
      }
    }
    function _fetchBreadcrumb(handlerData) {
      if (!handlerData.endTimestamp) {
        return;
      }
      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
        return;
      }
      if (handlerData.error) {
        core_1.getCurrentHub().addBreadcrumb({
          category: "fetch",
          data: handlerData.fetchData,
          level: types_1.Severity.Error,
          type: "http"
        }, {
          data: handlerData.error,
          input: handlerData.args
        });
      } else {
        core_1.getCurrentHub().addBreadcrumb({
          category: "fetch",
          data: tslib_1.__assign(tslib_1.__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
          type: "http"
        }, {
          input: handlerData.args,
          response: handlerData.response
        });
      }
    }
    function _historyBreadcrumb(handlerData) {
      var global2 = utils_1.getGlobalObject();
      var from = handlerData.from;
      var to = handlerData.to;
      var parsedLoc = utils_1.parseUrl(global2.location.href);
      var parsedFrom = utils_1.parseUrl(from);
      var parsedTo = utils_1.parseUrl(to);
      if (!parsedFrom.path) {
        parsedFrom = parsedLoc;
      }
      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
        to = parsedTo.relative;
      }
      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
        from = parsedFrom.relative;
      }
      core_1.getCurrentHub().addBreadcrumb({
        category: "navigation",
        data: {
          from,
          to
        }
      });
    }
  }
});

// node_modules/@sentry/browser/dist/integrations/linkederrors.js
var require_linkederrors = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/linkederrors.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var parsers_1 = require_parsers();
    var DEFAULT_KEY = "cause";
    var DEFAULT_LIMIT = 5;
    var LinkedErrors = function() {
      function LinkedErrors2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = LinkedErrors2.id;
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
      }
      LinkedErrors2.prototype.setupOnce = function() {
        core_1.addGlobalEventProcessor(function(event, hint) {
          var self2 = core_1.getCurrentHub().getIntegration(LinkedErrors2);
          return self2 ? _handler(self2._key, self2._limit, event, hint) : event;
        });
      };
      LinkedErrors2.id = "LinkedErrors";
      return LinkedErrors2;
    }();
    exports.LinkedErrors = LinkedErrors;
    function _handler(key2, limit, event, hint) {
      if (!event.exception || !event.exception.values || !hint || !utils_1.isInstanceOf(hint.originalException, Error)) {
        return event;
      }
      var linkedErrors = _walkErrorTree(limit, hint.originalException, key2);
      event.exception.values = tslib_1.__spread(linkedErrors, event.exception.values);
      return event;
    }
    exports._handler = _handler;
    function _walkErrorTree(limit, error2, key2, stack) {
      if (stack === void 0) {
        stack = [];
      }
      if (!utils_1.isInstanceOf(error2[key2], Error) || stack.length + 1 >= limit) {
        return stack;
      }
      var exception = parsers_1.exceptionFromError(error2[key2]);
      return _walkErrorTree(limit, error2[key2], key2, tslib_1.__spread([exception], stack));
    }
    exports._walkErrorTree = _walkErrorTree;
  }
});

// node_modules/@sentry/browser/dist/integrations/useragent.js
var require_useragent = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/useragent.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var global2 = utils_1.getGlobalObject();
    var UserAgent = function() {
      function UserAgent2() {
        this.name = UserAgent2.id;
      }
      UserAgent2.prototype.setupOnce = function() {
        core_1.addGlobalEventProcessor(function(event) {
          if (core_1.getCurrentHub().getIntegration(UserAgent2)) {
            if (!global2.navigator && !global2.location && !global2.document) {
              return event;
            }
            var url = event.request && event.request.url || global2.location && global2.location.href;
            var referrer = (global2.document || {}).referrer;
            var userAgent = (global2.navigator || {}).userAgent;
            var headers = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, event.request && event.request.headers), referrer && { Referer: referrer }), userAgent && { "User-Agent": userAgent });
            var request = tslib_1.__assign(tslib_1.__assign({}, url && { url }), { headers });
            return tslib_1.__assign(tslib_1.__assign({}, event), { request });
          }
          return event;
        });
      };
      UserAgent2.id = "UserAgent";
      return UserAgent2;
    }();
    exports.UserAgent = UserAgent;
  }
});

// node_modules/@sentry/browser/dist/integrations/dedupe.js
var require_dedupe = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/dedupe.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var Dedupe = function() {
      function Dedupe2() {
        this.name = Dedupe2.id;
      }
      Dedupe2.prototype.setupOnce = function(addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor(function(currentEvent) {
          var self2 = getCurrentHub().getIntegration(Dedupe2);
          if (self2) {
            try {
              if (_shouldDropEvent(currentEvent, self2._previousEvent)) {
                utils_1.logger.warn("Event dropped due to being a duplicate of previously captured event.");
                return null;
              }
            } catch (_oO) {
              return self2._previousEvent = currentEvent;
            }
            return self2._previousEvent = currentEvent;
          }
          return currentEvent;
        });
      };
      Dedupe2.id = "Dedupe";
      return Dedupe2;
    }();
    exports.Dedupe = Dedupe;
    function _shouldDropEvent(currentEvent, previousEvent) {
      if (!previousEvent) {
        return false;
      }
      if (_isSameMessageEvent(currentEvent, previousEvent)) {
        return true;
      }
      if (_isSameExceptionEvent(currentEvent, previousEvent)) {
        return true;
      }
      return false;
    }
    function _isSameMessageEvent(currentEvent, previousEvent) {
      var currentMessage = currentEvent.message;
      var previousMessage = previousEvent.message;
      if (!currentMessage && !previousMessage) {
        return false;
      }
      if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
        return false;
      }
      if (currentMessage !== previousMessage) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    function _isSameExceptionEvent(currentEvent, previousEvent) {
      var previousException = _getExceptionFromEvent(previousEvent);
      var currentException = _getExceptionFromEvent(currentEvent);
      if (!previousException || !currentException) {
        return false;
      }
      if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    function _isSameStacktrace(currentEvent, previousEvent) {
      var currentFrames = _getFramesFromEvent(currentEvent);
      var previousFrames = _getFramesFromEvent(previousEvent);
      if (!currentFrames && !previousFrames) {
        return true;
      }
      if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
        return false;
      }
      currentFrames = currentFrames;
      previousFrames = previousFrames;
      if (previousFrames.length !== currentFrames.length) {
        return false;
      }
      for (var i2 = 0; i2 < previousFrames.length; i2++) {
        var frameA = previousFrames[i2];
        var frameB = currentFrames[i2];
        if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
          return false;
        }
      }
      return true;
    }
    function _isSameFingerprint(currentEvent, previousEvent) {
      var currentFingerprint = currentEvent.fingerprint;
      var previousFingerprint = previousEvent.fingerprint;
      if (!currentFingerprint && !previousFingerprint) {
        return true;
      }
      if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
        return false;
      }
      currentFingerprint = currentFingerprint;
      previousFingerprint = previousFingerprint;
      try {
        return !!(currentFingerprint.join("") === previousFingerprint.join(""));
      } catch (_oO) {
        return false;
      }
    }
    function _getExceptionFromEvent(event) {
      return event.exception && event.exception.values && event.exception.values[0];
    }
    function _getFramesFromEvent(event) {
      var exception = event.exception;
      if (exception) {
        try {
          return exception.values[0].stacktrace.frames;
        } catch (_oO) {
          return void 0;
        }
      } else if (event.stacktrace) {
        return event.stacktrace.frames;
      }
      return void 0;
    }
  }
});

// node_modules/@sentry/browser/dist/integrations/index.js
var require_integrations2 = __commonJS({
  "node_modules/@sentry/browser/dist/integrations/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var globalhandlers_1 = require_globalhandlers();
    exports.GlobalHandlers = globalhandlers_1.GlobalHandlers;
    var trycatch_1 = require_trycatch();
    exports.TryCatch = trycatch_1.TryCatch;
    var breadcrumbs_1 = require_breadcrumbs();
    exports.Breadcrumbs = breadcrumbs_1.Breadcrumbs;
    var linkederrors_1 = require_linkederrors();
    exports.LinkedErrors = linkederrors_1.LinkedErrors;
    var useragent_1 = require_useragent();
    exports.UserAgent = useragent_1.UserAgent;
    var dedupe_1 = require_dedupe();
    exports.Dedupe = dedupe_1.Dedupe;
  }
});

// node_modules/@sentry/browser/dist/client.js
var require_client2 = __commonJS({
  "node_modules/@sentry/browser/dist/client.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var backend_1 = require_backend();
    var helpers_1 = require_helpers4();
    var integrations_1 = require_integrations2();
    var BrowserClient = function(_super) {
      tslib_1.__extends(BrowserClient2, _super);
      function BrowserClient2(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = this;
        options._metadata = options._metadata || {};
        options._metadata.sdk = options._metadata.sdk || {
          name: "sentry.javascript.browser",
          packages: [
            {
              name: "npm:@sentry/browser",
              version: core_1.SDK_VERSION
            }
          ],
          version: core_1.SDK_VERSION
        };
        _this = _super.call(this, backend_1.BrowserBackend, options) || this;
        return _this;
      }
      BrowserClient2.prototype.showReportDialog = function(options) {
        if (options === void 0) {
          options = {};
        }
        var document2 = utils_1.getGlobalObject().document;
        if (!document2) {
          return;
        }
        if (!this._isEnabled()) {
          utils_1.logger.error("Trying to call showReportDialog with Sentry Client disabled");
          return;
        }
        helpers_1.injectReportDialog(tslib_1.__assign(tslib_1.__assign({}, options), { dsn: options.dsn || this.getDsn() }));
      };
      BrowserClient2.prototype._prepareEvent = function(event, scope, hint) {
        event.platform = event.platform || "javascript";
        return _super.prototype._prepareEvent.call(this, event, scope, hint);
      };
      BrowserClient2.prototype._sendEvent = function(event) {
        var integration = this.getIntegration(integrations_1.Breadcrumbs);
        if (integration) {
          integration.addSentryBreadcrumb(event);
        }
        _super.prototype._sendEvent.call(this, event);
      };
      return BrowserClient2;
    }(core_1.BaseClient);
    exports.BrowserClient = BrowserClient;
  }
});

// node_modules/@sentry/browser/dist/sdk.js
var require_sdk2 = __commonJS({
  "node_modules/@sentry/browser/dist/sdk.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var client_1 = require_client2();
    var helpers_1 = require_helpers4();
    var integrations_1 = require_integrations2();
    exports.defaultIntegrations = [
      new core_1.Integrations.InboundFilters(),
      new core_1.Integrations.FunctionToString(),
      new integrations_1.TryCatch(),
      new integrations_1.Breadcrumbs(),
      new integrations_1.GlobalHandlers(),
      new integrations_1.LinkedErrors(),
      new integrations_1.Dedupe(),
      new integrations_1.UserAgent()
    ];
    function init3(options) {
      if (options === void 0) {
        options = {};
      }
      if (options.defaultIntegrations === void 0) {
        options.defaultIntegrations = exports.defaultIntegrations;
      }
      if (options.release === void 0) {
        var window_1 = utils_1.getGlobalObject();
        if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
          options.release = window_1.SENTRY_RELEASE.id;
        }
      }
      if (options.autoSessionTracking === void 0) {
        options.autoSessionTracking = true;
      }
      if (options.sendClientReports === void 0) {
        options.sendClientReports = true;
      }
      core_1.initAndBind(client_1.BrowserClient, options);
      if (options.autoSessionTracking) {
        startSessionTracking();
      }
    }
    exports.init = init3;
    function showReportDialog(options) {
      if (options === void 0) {
        options = {};
      }
      var hub = core_1.getCurrentHub();
      var scope = hub.getScope();
      if (scope) {
        options.user = tslib_1.__assign(tslib_1.__assign({}, scope.getUser()), options.user);
      }
      if (!options.eventId) {
        options.eventId = hub.lastEventId();
      }
      var client = hub.getClient();
      if (client) {
        client.showReportDialog(options);
      }
    }
    exports.showReportDialog = showReportDialog;
    function lastEventId() {
      return core_1.getCurrentHub().lastEventId();
    }
    exports.lastEventId = lastEventId;
    function forceLoad() {
    }
    exports.forceLoad = forceLoad;
    function onLoad(callback) {
      callback();
    }
    exports.onLoad = onLoad;
    function flush(timeout) {
      var client = core_1.getCurrentHub().getClient();
      if (client) {
        return client.flush(timeout);
      }
      if (utils_1.isDebugBuild()) {
        utils_1.logger.warn("Cannot flush events. No client defined.");
      }
      return utils_1.resolvedSyncPromise(false);
    }
    exports.flush = flush;
    function close(timeout) {
      var client = core_1.getCurrentHub().getClient();
      if (client) {
        return client.close(timeout);
      }
      if (utils_1.isDebugBuild()) {
        utils_1.logger.warn("Cannot flush events and disable SDK. No client defined.");
      }
      return utils_1.resolvedSyncPromise(false);
    }
    exports.close = close;
    function wrap(fn) {
      return helpers_1.wrap(fn)();
    }
    exports.wrap = wrap;
    function startSessionOnHub(hub) {
      hub.startSession({ ignoreDuration: true });
      hub.captureSession();
    }
    function startSessionTracking() {
      var window2 = utils_1.getGlobalObject();
      var document2 = window2.document;
      if (typeof document2 === "undefined") {
        if (utils_1.isDebugBuild()) {
          utils_1.logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
        }
        return;
      }
      var hub = core_1.getCurrentHub();
      if (!hub.captureSession) {
        return;
      }
      startSessionOnHub(hub);
      utils_1.addInstrumentationHandler("history", function(_a4) {
        var from = _a4.from, to = _a4.to;
        if (!(from === void 0 || from === to)) {
          startSessionOnHub(core_1.getCurrentHub());
        }
      });
    }
  }
});

// node_modules/@sentry/browser/dist/version.js
var require_version9 = __commonJS({
  "node_modules/@sentry/browser/dist/version.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_NAME = "sentry.javascript.browser";
  }
});

// node_modules/@sentry/browser/dist/exports.js
var require_exports = __commonJS({
  "node_modules/@sentry/browser/dist/exports.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_dist();
    exports.Severity = types_1.Severity;
    var core_1 = require_dist5();
    exports.addGlobalEventProcessor = core_1.addGlobalEventProcessor;
    exports.addBreadcrumb = core_1.addBreadcrumb;
    exports.captureException = core_1.captureException;
    exports.captureEvent = core_1.captureEvent;
    exports.captureMessage = core_1.captureMessage;
    exports.configureScope = core_1.configureScope;
    exports.getHubFromCarrier = core_1.getHubFromCarrier;
    exports.getCurrentHub = core_1.getCurrentHub;
    exports.Hub = core_1.Hub;
    exports.makeMain = core_1.makeMain;
    exports.Scope = core_1.Scope;
    exports.Session = core_1.Session;
    exports.startTransaction = core_1.startTransaction;
    exports.SDK_VERSION = core_1.SDK_VERSION;
    exports.setContext = core_1.setContext;
    exports.setExtra = core_1.setExtra;
    exports.setExtras = core_1.setExtras;
    exports.setTag = core_1.setTag;
    exports.setTags = core_1.setTags;
    exports.setUser = core_1.setUser;
    exports.withScope = core_1.withScope;
    var client_1 = require_client2();
    exports.BrowserClient = client_1.BrowserClient;
    var helpers_1 = require_helpers4();
    exports.injectReportDialog = helpers_1.injectReportDialog;
    var eventbuilder_1 = require_eventbuilder();
    exports.eventFromException = eventbuilder_1.eventFromException;
    exports.eventFromMessage = eventbuilder_1.eventFromMessage;
    var sdk_1 = require_sdk2();
    exports.defaultIntegrations = sdk_1.defaultIntegrations;
    exports.forceLoad = sdk_1.forceLoad;
    exports.init = sdk_1.init;
    exports.lastEventId = sdk_1.lastEventId;
    exports.onLoad = sdk_1.onLoad;
    exports.showReportDialog = sdk_1.showReportDialog;
    exports.flush = sdk_1.flush;
    exports.close = sdk_1.close;
    exports.wrap = sdk_1.wrap;
    var version_1 = require_version9();
    exports.SDK_NAME = version_1.SDK_NAME;
  }
});

// node_modules/@sentry/browser/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@sentry/browser/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_exports(), exports);
    var core_1 = require_dist5();
    var utils_1 = require_dist2();
    var BrowserIntegrations = require_integrations2();
    var Transports = require_transports();
    exports.Transports = Transports;
    var windowIntegrations = {};
    var _window = utils_1.getGlobalObject();
    if (_window.Sentry && _window.Sentry.Integrations) {
      windowIntegrations = _window.Sentry.Integrations;
    }
    var INTEGRATIONS = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, windowIntegrations), core_1.Integrations), BrowserIntegrations);
    exports.Integrations = INTEGRATIONS;
  }
});

// node_modules/@sentry/tracing/node_modules/tslib/tslib.js
var require_tslib6 = __commonJS({
  "node_modules/@sentry/tracing/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory2(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key2, r2) : d(target, key2)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f3, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f3 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o, m2, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m2[k];
      };
      __exportStar = function(m2, exports2) {
        for (var p in m2)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m2[p];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o[s3], i2 = 0;
        if (m2)
          return m2.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m2 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m2)
          return o;
        var i2 = m2.call(o), r2, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v) {
          if (f3(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f3) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f3 ? f3(v) : v;
          } : f3;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@sentry/tracing/dist/utils.js
var require_utils8 = __commonJS({
  "node_modules/@sentry/tracing/dist/utils.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub_1 = require_dist3();
    exports.TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
    function hasTracingEnabled(maybeOptions) {
      var client = hub_1.getCurrentHub().getClient();
      var options = maybeOptions || client && client.getOptions();
      return !!options && ("tracesSampleRate" in options || "tracesSampler" in options);
    }
    exports.hasTracingEnabled = hasTracingEnabled;
    function extractTraceparentData(traceparent) {
      var matches = traceparent.match(exports.TRACEPARENT_REGEXP);
      if (matches) {
        var parentSampled = void 0;
        if (matches[3] === "1") {
          parentSampled = true;
        } else if (matches[3] === "0") {
          parentSampled = false;
        }
        return {
          traceId: matches[1],
          parentSampled,
          parentSpanId: matches[2]
        };
      }
      return void 0;
    }
    exports.extractTraceparentData = extractTraceparentData;
    function getActiveTransaction(maybeHub) {
      var hub = maybeHub || hub_1.getCurrentHub();
      var scope = hub.getScope();
      return scope && scope.getTransaction();
    }
    exports.getActiveTransaction = getActiveTransaction;
    function msToSec(time) {
      return time / 1e3;
    }
    exports.msToSec = msToSec;
    function secToMs(time) {
      return time * 1e3;
    }
    exports.secToMs = secToMs;
    var utils_1 = require_dist2();
    exports.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
  }
});

// node_modules/@sentry/tracing/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/@sentry/tracing/dist/errors.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var utils_2 = require_utils8();
    function registerErrorInstrumentation() {
      utils_1.addInstrumentationHandler("error", errorCallback);
      utils_1.addInstrumentationHandler("unhandledrejection", errorCallback);
    }
    exports.registerErrorInstrumentation = registerErrorInstrumentation;
    function errorCallback() {
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var status_1 = "internal_error";
        utils_1.logger.log("[Tracing] Transaction: " + status_1 + " -> Global error occured");
        activeTransaction.setStatus(status_1);
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/constants.js
var require_constants10 = __commonJS({
  "node_modules/@sentry/tracing/dist/constants.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FINISH_REASON_TAG = "finishReason";
    exports.IDLE_TRANSACTION_FINISH_REASONS = ["heartbeatFailed", "idleTimeout", "documentHidden"];
  }
});

// node_modules/@sentry/tracing/dist/span.js
var require_span = __commonJS({
  "node_modules/@sentry/tracing/dist/span.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var SpanRecorder = function() {
      function SpanRecorder2(maxlen) {
        if (maxlen === void 0) {
          maxlen = 1e3;
        }
        this.spans = [];
        this._maxlen = maxlen;
      }
      SpanRecorder2.prototype.add = function(span) {
        if (this.spans.length > this._maxlen) {
          span.spanRecorder = void 0;
        } else {
          this.spans.push(span);
        }
      };
      return SpanRecorder2;
    }();
    exports.SpanRecorder = SpanRecorder;
    var Span = function() {
      function Span2(spanContext) {
        this.traceId = utils_1.uuid4();
        this.spanId = utils_1.uuid4().substring(16);
        this.startTimestamp = utils_1.timestampWithMs();
        this.tags = {};
        this.data = {};
        if (!spanContext) {
          return this;
        }
        if (spanContext.traceId) {
          this.traceId = spanContext.traceId;
        }
        if (spanContext.spanId) {
          this.spanId = spanContext.spanId;
        }
        if (spanContext.parentSpanId) {
          this.parentSpanId = spanContext.parentSpanId;
        }
        if ("sampled" in spanContext) {
          this.sampled = spanContext.sampled;
        }
        if (spanContext.op) {
          this.op = spanContext.op;
        }
        if (spanContext.description) {
          this.description = spanContext.description;
        }
        if (spanContext.data) {
          this.data = spanContext.data;
        }
        if (spanContext.tags) {
          this.tags = spanContext.tags;
        }
        if (spanContext.status) {
          this.status = spanContext.status;
        }
        if (spanContext.startTimestamp) {
          this.startTimestamp = spanContext.startTimestamp;
        }
        if (spanContext.endTimestamp) {
          this.endTimestamp = spanContext.endTimestamp;
        }
      }
      Span2.prototype.child = function(spanContext) {
        return this.startChild(spanContext);
      };
      Span2.prototype.startChild = function(spanContext) {
        var childSpan = new Span2(tslib_1.__assign(tslib_1.__assign({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
        childSpan.spanRecorder = this.spanRecorder;
        if (childSpan.spanRecorder) {
          childSpan.spanRecorder.add(childSpan);
        }
        childSpan.transaction = this.transaction;
        return childSpan;
      };
      Span2.prototype.setTag = function(key2, value) {
        var _a4;
        this.tags = tslib_1.__assign(tslib_1.__assign({}, this.tags), (_a4 = {}, _a4[key2] = value, _a4));
        return this;
      };
      Span2.prototype.setData = function(key2, value) {
        var _a4;
        this.data = tslib_1.__assign(tslib_1.__assign({}, this.data), (_a4 = {}, _a4[key2] = value, _a4));
        return this;
      };
      Span2.prototype.setStatus = function(value) {
        this.status = value;
        return this;
      };
      Span2.prototype.setHttpStatus = function(httpStatus) {
        this.setTag("http.status_code", String(httpStatus));
        var spanStatus = spanStatusfromHttpCode(httpStatus);
        if (spanStatus !== "unknown_error") {
          this.setStatus(spanStatus);
        }
        return this;
      };
      Span2.prototype.isSuccess = function() {
        return this.status === "ok";
      };
      Span2.prototype.finish = function(endTimestamp) {
        this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils_1.timestampWithMs();
      };
      Span2.prototype.toTraceparent = function() {
        var sampledString = "";
        if (this.sampled !== void 0) {
          sampledString = this.sampled ? "-1" : "-0";
        }
        return this.traceId + "-" + this.spanId + sampledString;
      };
      Span2.prototype.toContext = function() {
        return utils_1.dropUndefinedKeys({
          data: this.data,
          description: this.description,
          endTimestamp: this.endTimestamp,
          op: this.op,
          parentSpanId: this.parentSpanId,
          sampled: this.sampled,
          spanId: this.spanId,
          startTimestamp: this.startTimestamp,
          status: this.status,
          tags: this.tags,
          traceId: this.traceId
        });
      };
      Span2.prototype.updateWithContext = function(spanContext) {
        var _a4, _b, _c, _d2, _e;
        this.data = (_a4 = spanContext.data, _a4 !== null && _a4 !== void 0 ? _a4 : {});
        this.description = spanContext.description;
        this.endTimestamp = spanContext.endTimestamp;
        this.op = spanContext.op;
        this.parentSpanId = spanContext.parentSpanId;
        this.sampled = spanContext.sampled;
        this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
        this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
        this.status = spanContext.status;
        this.tags = (_d2 = spanContext.tags, _d2 !== null && _d2 !== void 0 ? _d2 : {});
        this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
        return this;
      };
      Span2.prototype.getTraceContext = function() {
        return utils_1.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          trace_id: this.traceId
        });
      };
      Span2.prototype.toJSON = function() {
        return utils_1.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          start_timestamp: this.startTimestamp,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          timestamp: this.endTimestamp,
          trace_id: this.traceId
        });
      };
      return Span2;
    }();
    exports.Span = Span;
    function spanStatusfromHttpCode(httpStatus) {
      if (httpStatus < 400 && httpStatus >= 100) {
        return "ok";
      }
      if (httpStatus >= 400 && httpStatus < 500) {
        switch (httpStatus) {
          case 401:
            return "unauthenticated";
          case 403:
            return "permission_denied";
          case 404:
            return "not_found";
          case 409:
            return "already_exists";
          case 413:
            return "failed_precondition";
          case 429:
            return "resource_exhausted";
          default:
            return "invalid_argument";
        }
      }
      if (httpStatus >= 500 && httpStatus < 600) {
        switch (httpStatus) {
          case 501:
            return "unimplemented";
          case 503:
            return "unavailable";
          case 504:
            return "deadline_exceeded";
          default:
            return "internal_error";
        }
      }
      return "unknown_error";
    }
    exports.spanStatusfromHttpCode = spanStatusfromHttpCode;
  }
});

// node_modules/@sentry/tracing/dist/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/@sentry/tracing/dist/transaction.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    var span_1 = require_span();
    var Transaction = function(_super) {
      tslib_1.__extends(Transaction2, _super);
      function Transaction2(transactionContext, hub) {
        var _this = _super.call(this, transactionContext) || this;
        _this._measurements = {};
        _this._hub = hub_1.getCurrentHub();
        if (utils_1.isInstanceOf(hub, hub_1.Hub)) {
          _this._hub = hub;
        }
        _this.name = transactionContext.name || "";
        _this.metadata = transactionContext.metadata || {};
        _this._trimEnd = transactionContext.trimEnd;
        _this.transaction = _this;
        return _this;
      }
      Transaction2.prototype.setName = function(name) {
        this.name = name;
      };
      Transaction2.prototype.initSpanRecorder = function(maxlen) {
        if (maxlen === void 0) {
          maxlen = 1e3;
        }
        if (!this.spanRecorder) {
          this.spanRecorder = new span_1.SpanRecorder(maxlen);
        }
        this.spanRecorder.add(this);
      };
      Transaction2.prototype.setMeasurements = function(measurements) {
        this._measurements = tslib_1.__assign({}, measurements);
      };
      Transaction2.prototype.setMetadata = function(newMetadata) {
        this.metadata = tslib_1.__assign(tslib_1.__assign({}, this.metadata), newMetadata);
      };
      Transaction2.prototype.finish = function(endTimestamp) {
        var _this = this;
        if (this.endTimestamp !== void 0) {
          return void 0;
        }
        if (!this.name) {
          utils_1.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
          this.name = "<unlabeled transaction>";
        }
        _super.prototype.finish.call(this, endTimestamp);
        if (this.sampled !== true) {
          utils_1.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
          var client = this._hub.getClient();
          var transport = client && client.getTransport && client.getTransport();
          if (transport && transport.recordLostEvent) {
            transport.recordLostEvent("sample_rate", "transaction");
          }
          return void 0;
        }
        var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function(s3) {
          return s3 !== _this && s3.endTimestamp;
        }) : [];
        if (this._trimEnd && finishedSpans.length > 0) {
          this.endTimestamp = finishedSpans.reduce(function(prev, current) {
            if (prev.endTimestamp && current.endTimestamp) {
              return prev.endTimestamp > current.endTimestamp ? prev : current;
            }
            return prev;
          }).endTimestamp;
        }
        var transaction = {
          contexts: {
            trace: this.getTraceContext()
          },
          spans: finishedSpans,
          start_timestamp: this.startTimestamp,
          tags: this.tags,
          timestamp: this.endTimestamp,
          transaction: this.name,
          type: "transaction",
          sdkProcessingMetadata: this.metadata
        };
        var hasMeasurements = Object.keys(this._measurements).length > 0;
        if (hasMeasurements) {
          utils_1.logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
          transaction.measurements = this._measurements;
        }
        utils_1.logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
        return this._hub.captureEvent(transaction);
      };
      Transaction2.prototype.toContext = function() {
        var spanContext = _super.prototype.toContext.call(this);
        return utils_1.dropUndefinedKeys(tslib_1.__assign(tslib_1.__assign({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
      };
      Transaction2.prototype.updateWithContext = function(transactionContext) {
        var _a4;
        _super.prototype.updateWithContext.call(this, transactionContext);
        this.name = (_a4 = transactionContext.name, _a4 !== null && _a4 !== void 0 ? _a4 : "");
        this._trimEnd = transactionContext.trimEnd;
        return this;
      };
      return Transaction2;
    }(span_1.Span);
    exports.Transaction = Transaction;
  }
});

// node_modules/@sentry/tracing/dist/idletransaction.js
var require_idletransaction = __commonJS({
  "node_modules/@sentry/tracing/dist/idletransaction.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var constants_1 = require_constants10();
    var span_1 = require_span();
    var transaction_1 = require_transaction2();
    exports.DEFAULT_IDLE_TIMEOUT = 1e3;
    exports.HEARTBEAT_INTERVAL = 5e3;
    var IdleTransactionSpanRecorder = function(_super) {
      tslib_1.__extends(IdleTransactionSpanRecorder2, _super);
      function IdleTransactionSpanRecorder2(_pushActivity, _popActivity, transactionSpanId, maxlen) {
        if (transactionSpanId === void 0) {
          transactionSpanId = "";
        }
        var _this = _super.call(this, maxlen) || this;
        _this._pushActivity = _pushActivity;
        _this._popActivity = _popActivity;
        _this.transactionSpanId = transactionSpanId;
        return _this;
      }
      IdleTransactionSpanRecorder2.prototype.add = function(span) {
        var _this = this;
        if (span.spanId !== this.transactionSpanId) {
          span.finish = function(endTimestamp) {
            span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : utils_1.timestampWithMs();
            _this._popActivity(span.spanId);
          };
          if (span.endTimestamp === void 0) {
            this._pushActivity(span.spanId);
          }
        }
        _super.prototype.add.call(this, span);
      };
      return IdleTransactionSpanRecorder2;
    }(span_1.SpanRecorder);
    exports.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
    var IdleTransaction = function(_super) {
      tslib_1.__extends(IdleTransaction2, _super);
      function IdleTransaction2(transactionContext, _idleHub, _idleTimeout, _onScope) {
        if (_idleTimeout === void 0) {
          _idleTimeout = exports.DEFAULT_IDLE_TIMEOUT;
        }
        if (_onScope === void 0) {
          _onScope = false;
        }
        var _this = _super.call(this, transactionContext, _idleHub) || this;
        _this._idleHub = _idleHub;
        _this._idleTimeout = _idleTimeout;
        _this._onScope = _onScope;
        _this.activities = {};
        _this._heartbeatCounter = 0;
        _this._finished = false;
        _this._beforeFinishCallbacks = [];
        if (_idleHub && _onScope) {
          clearActiveTransaction(_idleHub);
          utils_1.logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
          _idleHub.configureScope(function(scope) {
            return scope.setSpan(_this);
          });
        }
        _this._initTimeout = setTimeout(function() {
          if (!_this._finished) {
            _this.finish();
          }
        }, _this._idleTimeout);
        return _this;
      }
      IdleTransaction2.prototype.finish = function(endTimestamp) {
        var e_1, _a4;
        var _this = this;
        if (endTimestamp === void 0) {
          endTimestamp = utils_1.timestampWithMs();
        }
        this._finished = true;
        this.activities = {};
        if (this.spanRecorder) {
          utils_1.logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
          try {
            for (var _b = tslib_1.__values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
              var callback = _c.value;
              callback(this, endTimestamp);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a4 = _b.return))
                _a4.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this.spanRecorder.spans = this.spanRecorder.spans.filter(function(span) {
            if (span.spanId === _this.spanId) {
              return true;
            }
            if (!span.endTimestamp) {
              span.endTimestamp = endTimestamp;
              span.setStatus("cancelled");
              utils_1.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
            }
            var keepSpan = span.startTimestamp < endTimestamp;
            if (!keepSpan) {
              utils_1.logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
            }
            return keepSpan;
          });
          utils_1.logger.log("[Tracing] flushing IdleTransaction");
        } else {
          utils_1.logger.log("[Tracing] No active IdleTransaction");
        }
        if (this._onScope) {
          clearActiveTransaction(this._idleHub);
        }
        return _super.prototype.finish.call(this, endTimestamp);
      };
      IdleTransaction2.prototype.registerBeforeFinishCallback = function(callback) {
        this._beforeFinishCallbacks.push(callback);
      };
      IdleTransaction2.prototype.initSpanRecorder = function(maxlen) {
        var _this = this;
        if (!this.spanRecorder) {
          var pushActivity = function(id) {
            if (_this._finished) {
              return;
            }
            _this._pushActivity(id);
          };
          var popActivity = function(id) {
            if (_this._finished) {
              return;
            }
            _this._popActivity(id);
          };
          this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
          utils_1.logger.log("Starting heartbeat");
          this._pingHeartbeat();
        }
        this.spanRecorder.add(this);
      };
      IdleTransaction2.prototype._pushActivity = function(spanId) {
        if (this._initTimeout) {
          clearTimeout(this._initTimeout);
          this._initTimeout = void 0;
        }
        utils_1.logger.log("[Tracing] pushActivity: " + spanId);
        this.activities[spanId] = true;
        utils_1.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      };
      IdleTransaction2.prototype._popActivity = function(spanId) {
        var _this = this;
        if (this.activities[spanId]) {
          utils_1.logger.log("[Tracing] popActivity " + spanId);
          delete this.activities[spanId];
          utils_1.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
        }
        if (Object.keys(this.activities).length === 0) {
          var timeout = this._idleTimeout;
          var end_1 = utils_1.timestampWithMs() + timeout / 1e3;
          setTimeout(function() {
            if (!_this._finished) {
              _this.setTag(constants_1.FINISH_REASON_TAG, constants_1.IDLE_TRANSACTION_FINISH_REASONS[1]);
              _this.finish(end_1);
            }
          }, timeout);
        }
      };
      IdleTransaction2.prototype._beat = function() {
        if (this._finished) {
          return;
        }
        var heartbeatString = Object.keys(this.activities).join("");
        if (heartbeatString === this._prevHeartbeatString) {
          this._heartbeatCounter += 1;
        } else {
          this._heartbeatCounter = 1;
        }
        this._prevHeartbeatString = heartbeatString;
        if (this._heartbeatCounter >= 3) {
          utils_1.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
          this.setStatus("deadline_exceeded");
          this.setTag(constants_1.FINISH_REASON_TAG, constants_1.IDLE_TRANSACTION_FINISH_REASONS[0]);
          this.finish();
        } else {
          this._pingHeartbeat();
        }
      };
      IdleTransaction2.prototype._pingHeartbeat = function() {
        var _this = this;
        utils_1.logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
        setTimeout(function() {
          _this._beat();
        }, exports.HEARTBEAT_INTERVAL);
      };
      return IdleTransaction2;
    }(transaction_1.Transaction);
    exports.IdleTransaction = IdleTransaction;
    function clearActiveTransaction(hub) {
      if (hub) {
        var scope = hub.getScope();
        if (scope) {
          var transaction = scope.getTransaction();
          if (transaction) {
            scope.setSpan(void 0);
          }
        }
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/hubextensions.js
var require_hubextensions = __commonJS({
  "node_modules/@sentry/tracing/dist/hubextensions.js"(exports, module2) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var hub_1 = require_dist3();
    var utils_1 = require_dist2();
    var errors_1 = require_errors2();
    var idletransaction_1 = require_idletransaction();
    var transaction_1 = require_transaction2();
    var utils_2 = require_utils8();
    function traceHeaders() {
      var scope = this.getScope();
      if (scope) {
        var span = scope.getSpan();
        if (span) {
          return {
            "sentry-trace": span.toTraceparent()
          };
        }
      }
      return {};
    }
    function sample(transaction, options, samplingContext) {
      if (!utils_2.hasTracingEnabled(options)) {
        transaction.sampled = false;
        return transaction;
      }
      if (transaction.sampled !== void 0) {
        transaction.setMetadata({
          transactionSampling: { method: "explicitly_set" }
        });
        return transaction;
      }
      var sampleRate;
      if (typeof options.tracesSampler === "function") {
        sampleRate = options.tracesSampler(samplingContext);
        transaction.setMetadata({
          transactionSampling: {
            method: "client_sampler",
            rate: Number(sampleRate)
          }
        });
      } else if (samplingContext.parentSampled !== void 0) {
        sampleRate = samplingContext.parentSampled;
        transaction.setMetadata({
          transactionSampling: { method: "inheritance" }
        });
      } else {
        sampleRate = options.tracesSampleRate;
        transaction.setMetadata({
          transactionSampling: {
            method: "client_rate",
            rate: Number(sampleRate)
          }
        });
      }
      if (!isValidSampleRate(sampleRate)) {
        utils_1.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
        transaction.sampled = false;
        return transaction;
      }
      if (!sampleRate) {
        utils_1.logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
        transaction.sampled = false;
        return transaction;
      }
      transaction.sampled = Math.random() < sampleRate;
      if (!transaction.sampled) {
        utils_1.logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
        return transaction;
      }
      utils_1.logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
      return transaction;
    }
    function isValidSampleRate(rate) {
      if (isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
        utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
        return false;
      }
      if (rate < 0 || rate > 1) {
        utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
        return false;
      }
      return true;
    }
    function _startTransaction(transactionContext, customSamplingContext) {
      var client = this.getClient();
      var options = client && client.getOptions() || {};
      var transaction = new transaction_1.Transaction(transactionContext, this);
      transaction = sample(transaction, options, tslib_1.__assign({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
      if (transaction.sampled) {
        transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      return transaction;
    }
    function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
      var client = hub.getClient();
      var options = client && client.getOptions() || {};
      var transaction = new idletransaction_1.IdleTransaction(transactionContext, hub, idleTimeout, onScope);
      transaction = sample(transaction, options, tslib_1.__assign({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
      if (transaction.sampled) {
        transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      return transaction;
    }
    exports.startIdleTransaction = startIdleTransaction;
    function _addTracingExtensions() {
      var carrier = hub_1.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      if (!carrier.__SENTRY__.extensions.startTransaction) {
        carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
      }
      if (!carrier.__SENTRY__.extensions.traceHeaders) {
        carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
      }
    }
    exports._addTracingExtensions = _addTracingExtensions;
    function _autoloadDatabaseIntegrations() {
      var carrier = hub_1.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      var packageToIntegrationMapping = {
        mongodb: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/mongo");
          return new integration.Mongo();
        },
        mongoose: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/mongo");
          return new integration.Mongo({ mongoose: true });
        },
        mysql: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/mysql");
          return new integration.Mysql();
        },
        pg: function() {
          var integration = utils_1.dynamicRequire(module2, "./integrations/node/postgres");
          return new integration.Postgres();
        }
      };
      var mappedPackages = Object.keys(packageToIntegrationMapping).filter(function(moduleName) {
        return !!utils_1.loadModule(moduleName);
      }).map(function(pkg) {
        try {
          return packageToIntegrationMapping[pkg]();
        } catch (e2) {
          return void 0;
        }
      }).filter(function(p) {
        return p;
      });
      if (mappedPackages.length > 0) {
        carrier.__SENTRY__.integrations = tslib_1.__spread(carrier.__SENTRY__.integrations || [], mappedPackages);
      }
    }
    function addExtensionMethods() {
      _addTracingExtensions();
      if (utils_1.isNodeEnv()) {
        _autoloadDatabaseIntegrations();
      }
      errors_1.registerErrorInstrumentation();
    }
    exports.addExtensionMethods = addExtensionMethods;
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/express.js
var require_express = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/express.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var Express = function() {
      function Express2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Express2.id;
        this._router = options.router || options.app;
        this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
      }
      Express2.prototype.setupOnce = function() {
        if (!this._router) {
          utils_1.logger.error("ExpressIntegration is missing an Express instance");
          return;
        }
        instrumentMiddlewares(this._router, this._methods);
      };
      Express2.id = "Express";
      return Express2;
    }();
    exports.Express = Express;
    function wrap(fn, method) {
      var arity = fn.length;
      switch (arity) {
        case 2: {
          return function(req, res) {
            var transaction = res.__sentry_transaction;
            if (transaction) {
              var span_1 = transaction.startChild({
                description: fn.name,
                op: "express.middleware." + method
              });
              res.once("finish", function() {
                span_1.finish();
              });
            }
            return fn.call(this, req, res);
          };
        }
        case 3: {
          return function(req, res, next) {
            var _a4;
            var transaction = res.__sentry_transaction;
            var span = (_a4 = transaction) === null || _a4 === void 0 ? void 0 : _a4.startChild({
              description: fn.name,
              op: "express.middleware." + method
            });
            fn.call(this, req, res, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var _a5;
              (_a5 = span) === null || _a5 === void 0 ? void 0 : _a5.finish();
              next.call.apply(next, tslib_1.__spread([this], args));
            });
          };
        }
        case 4: {
          return function(err, req, res, next) {
            var _a4;
            var transaction = res.__sentry_transaction;
            var span = (_a4 = transaction) === null || _a4 === void 0 ? void 0 : _a4.startChild({
              description: fn.name,
              op: "express.middleware." + method
            });
            fn.call(this, err, req, res, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var _a5;
              (_a5 = span) === null || _a5 === void 0 ? void 0 : _a5.finish();
              next.call.apply(next, tslib_1.__spread([this], args));
            });
          };
        }
        default: {
          throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
        }
      }
    }
    function wrapMiddlewareArgs(args, method) {
      return args.map(function(arg) {
        if (typeof arg === "function") {
          return wrap(arg, method);
        }
        if (Array.isArray(arg)) {
          return arg.map(function(a) {
            if (typeof a === "function") {
              return wrap(a, method);
            }
            return a;
          });
        }
        return arg;
      });
    }
    function patchMiddleware(router, method) {
      var originalCallback = router[method];
      router[method] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return originalCallback.call.apply(originalCallback, tslib_1.__spread([this], wrapMiddlewareArgs(args, method)));
      };
      return router;
    }
    function instrumentMiddlewares(router, methods) {
      if (methods === void 0) {
        methods = [];
      }
      methods.forEach(function(method) {
        return patchMiddleware(router, method);
      });
    }
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/postgres.js
var require_postgres = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/postgres.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var Postgres = function() {
      function Postgres2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Postgres2.id;
        this._usePgNative = !!options.usePgNative;
      }
      Postgres2.prototype.setupOnce = function(_, getCurrentHub) {
        var _a4;
        var pkg = utils_1.loadModule("pg");
        if (!pkg) {
          utils_1.logger.error("Postgres Integration was unable to require `pg` package.");
          return;
        }
        if (this._usePgNative && !((_a4 = pkg.native) === null || _a4 === void 0 ? void 0 : _a4.Client)) {
          utils_1.logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
          return;
        }
        var Client = (this._usePgNative ? pkg.native : pkg).Client;
        utils_1.fill(Client.prototype, "query", function(orig) {
          return function(config, values, callback) {
            var _a5, _b, _c;
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a5 = scope) === null || _a5 === void 0 ? void 0 : _a5.getSpan();
            var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
              description: typeof config === "string" ? config : config.text,
              op: "db"
            });
            if (typeof callback === "function") {
              return orig.call(this, config, values, function(err, result) {
                var _a6;
                (_a6 = span) === null || _a6 === void 0 ? void 0 : _a6.finish();
                callback(err, result);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, config, function(err, result) {
                var _a6;
                (_a6 = span) === null || _a6 === void 0 ? void 0 : _a6.finish();
                values(err, result);
              });
            }
            var rv = typeof values !== "undefined" ? orig.call(this, config, values) : orig.call(this, config);
            if (utils_1.isThenable(rv)) {
              return rv.then(function(res) {
                var _a6;
                (_a6 = span) === null || _a6 === void 0 ? void 0 : _a6.finish();
                return res;
              });
            }
            (_c = span) === null || _c === void 0 ? void 0 : _c.finish();
            return rv;
          };
        });
      };
      Postgres2.id = "Postgres";
      return Postgres2;
    }();
    exports.Postgres = Postgres;
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/mysql.js
var require_mysql = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/mysql.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var Mysql = function() {
      function Mysql2() {
        this.name = Mysql2.id;
      }
      Mysql2.prototype.setupOnce = function(_, getCurrentHub) {
        var pkg = utils_1.loadModule("mysql/lib/Connection.js");
        if (!pkg) {
          utils_1.logger.error("Mysql Integration was unable to require `mysql` package.");
          return;
        }
        utils_1.fill(pkg, "createQuery", function(orig) {
          return function(options, values, callback) {
            var _a4, _b;
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a4 = scope) === null || _a4 === void 0 ? void 0 : _a4.getSpan();
            var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
              description: typeof options === "string" ? options : options.sql,
              op: "db"
            });
            if (typeof callback === "function") {
              return orig.call(this, options, values, function(err, result, fields) {
                var _a5;
                (_a5 = span) === null || _a5 === void 0 ? void 0 : _a5.finish();
                callback(err, result, fields);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, options, function(err, result, fields) {
                var _a5;
                (_a5 = span) === null || _a5 === void 0 ? void 0 : _a5.finish();
                values(err, result, fields);
              });
            }
            return orig.call(this, options, values, callback);
          };
        });
      };
      Mysql2.id = "Mysql";
      return Mysql2;
    }();
    exports.Mysql = Mysql;
  }
});

// node_modules/@sentry/tracing/dist/integrations/node/mongo.js
var require_mongo = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/node/mongo.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var OPERATIONS = [
      "aggregate",
      "bulkWrite",
      "countDocuments",
      "createIndex",
      "createIndexes",
      "deleteMany",
      "deleteOne",
      "distinct",
      "drop",
      "dropIndex",
      "dropIndexes",
      "estimatedDocumentCount",
      "find",
      "findOne",
      "findOneAndDelete",
      "findOneAndReplace",
      "findOneAndUpdate",
      "indexes",
      "indexExists",
      "indexInformation",
      "initializeOrderedBulkOp",
      "insertMany",
      "insertOne",
      "isCapped",
      "mapReduce",
      "options",
      "parallelCollectionScan",
      "rename",
      "replaceOne",
      "stats",
      "updateMany",
      "updateOne"
    ];
    var OPERATION_SIGNATURES = {
      bulkWrite: ["operations"],
      countDocuments: ["query"],
      createIndex: ["fieldOrSpec"],
      createIndexes: ["indexSpecs"],
      deleteMany: ["filter"],
      deleteOne: ["filter"],
      distinct: ["key", "query"],
      dropIndex: ["indexName"],
      find: ["query"],
      findOne: ["query"],
      findOneAndDelete: ["filter"],
      findOneAndReplace: ["filter", "replacement"],
      findOneAndUpdate: ["filter", "update"],
      indexExists: ["indexes"],
      insertMany: ["docs"],
      insertOne: ["doc"],
      mapReduce: ["map", "reduce"],
      rename: ["newName"],
      replaceOne: ["filter", "doc"],
      updateMany: ["filter", "update"],
      updateOne: ["filter", "update"]
    };
    var Mongo = function() {
      function Mongo2(options) {
        if (options === void 0) {
          options = {};
        }
        this.name = Mongo2.id;
        this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
        this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
        this._useMongoose = !!options.useMongoose;
      }
      Mongo2.prototype.setupOnce = function(_, getCurrentHub) {
        var moduleName = this._useMongoose ? "mongoose" : "mongodb";
        var pkg = utils_1.loadModule(moduleName);
        if (!pkg) {
          utils_1.logger.error("Mongo Integration was unable to require `" + moduleName + "` package.");
          return;
        }
        this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);
      };
      Mongo2.prototype._instrumentOperations = function(collection, operations, getCurrentHub) {
        var _this = this;
        operations.forEach(function(operation) {
          return _this._patchOperation(collection, operation, getCurrentHub);
        });
      };
      Mongo2.prototype._patchOperation = function(collection, operation, getCurrentHub) {
        if (!(operation in collection.prototype))
          return;
        var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
        utils_1.fill(collection.prototype, operation, function(orig) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _a4, _b, _c, _d2;
            var lastArg = args[args.length - 1];
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a4 = scope) === null || _a4 === void 0 ? void 0 : _a4.getSpan();
            if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
              var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));
              var maybePromise = orig.call.apply(orig, tslib_1.__spread([this], args));
              if (utils_1.isThenable(maybePromise)) {
                return maybePromise.then(function(res) {
                  var _a5;
                  (_a5 = span_1) === null || _a5 === void 0 ? void 0 : _a5.finish();
                  return res;
                });
              } else {
                (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();
                return maybePromise;
              }
            }
            var span = (_d2 = parentSpan) === null || _d2 === void 0 ? void 0 : _d2.startChild(getSpanContext(this, operation, args.slice(0, -1)));
            return orig.call.apply(orig, tslib_1.__spread([this], args.slice(0, -1), [function(err, result) {
              var _a5;
              (_a5 = span) === null || _a5 === void 0 ? void 0 : _a5.finish();
              lastArg(err, result);
            }]));
          };
        });
      };
      Mongo2.prototype._getSpanContextFromOperationArguments = function(collection, operation, args) {
        var data = {
          collectionName: collection.collectionName,
          dbName: collection.dbName,
          namespace: collection.namespace
        };
        var spanContext = {
          op: "db",
          description: operation,
          data
        };
        var signature = OPERATION_SIGNATURES[operation];
        var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
        if (!signature || !shouldDescribe) {
          return spanContext;
        }
        try {
          if (operation === "mapReduce") {
            var _a4 = tslib_1.__read(args, 2), map = _a4[0], reduce = _a4[1];
            data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
            data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
          } else {
            for (var i2 = 0; i2 < signature.length; i2++) {
              data[signature[i2]] = JSON.stringify(args[i2]);
            }
          }
        } catch (_oO) {
        }
        return spanContext;
      };
      Mongo2.id = "Mongo";
      return Mongo2;
    }();
    exports.Mongo = Mongo;
  }
});

// node_modules/@sentry/tracing/dist/browser/backgroundtab.js
var require_backgroundtab = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/backgroundtab.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var constants_1 = require_constants10();
    var utils_2 = require_utils8();
    var global2 = utils_1.getGlobalObject();
    function registerBackgroundTabDetection() {
      if (global2 && global2.document) {
        global2.document.addEventListener("visibilitychange", function() {
          var activeTransaction = utils_2.getActiveTransaction();
          if (global2.document.hidden && activeTransaction) {
            var statusType = "cancelled";
            utils_1.logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op);
            if (!activeTransaction.status) {
              activeTransaction.setStatus(statusType);
            }
            activeTransaction.setTag("visibilitychange", "document.hidden");
            activeTransaction.setTag(constants_1.FINISH_REASON_TAG, constants_1.IDLE_TRANSACTION_FINISH_REASONS[2]);
            activeTransaction.finish();
          }
        });
      } else {
        utils_1.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
      }
    }
    exports.registerBackgroundTabDetection = registerBackgroundTabDetection;
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/bindReporter.js
var require_bindReporter = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/bindReporter.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindReporter = function(callback, metric, reportAllChanges) {
      var prevValue;
      return function(forceReport) {
        if (metric.value >= 0) {
          if (forceReport || reportAllChanges) {
            metric.delta = metric.value - (prevValue || 0);
            if (metric.delta || prevValue === void 0) {
              prevValue = metric.value;
              callback(metric);
            }
          }
        }
      };
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/generateUniqueID.js
var require_generateUniqueID = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/generateUniqueID.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateUniqueID = function() {
      return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/initMetric.js
var require_initMetric = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/initMetric.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var generateUniqueID_1 = require_generateUniqueID();
    exports.initMetric = function(name, value) {
      return {
        name,
        value: value !== null && value !== void 0 ? value : -1,
        delta: 0,
        entries: [],
        id: generateUniqueID_1.generateUniqueID()
      };
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/observe.js
var require_observe = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/observe.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = function(type, callback) {
      try {
        if (PerformanceObserver.supportedEntryTypes.includes(type)) {
          if (type === "first-input" && !("PerformanceEventTiming" in self)) {
            return;
          }
          var po = new PerformanceObserver(function(l) {
            return l.getEntries().map(callback);
          });
          po.observe({ type, buffered: true });
          return po;
        }
      } catch (e2) {
      }
      return;
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/onHidden.js
var require_onHidden = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/onHidden.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    exports.onHidden = function(cb, once) {
      var onHiddenOrPageHide = function(event) {
        if (event.type === "pagehide" || utils_1.getGlobalObject().document.visibilityState === "hidden") {
          cb(event);
          if (once) {
            removeEventListener("visibilitychange", onHiddenOrPageHide, true);
            removeEventListener("pagehide", onHiddenOrPageHide, true);
          }
        }
      };
      addEventListener("visibilitychange", onHiddenOrPageHide, true);
      addEventListener("pagehide", onHiddenOrPageHide, true);
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/getCLS.js
var require_getCLS = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/getCLS.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter_1 = require_bindReporter();
    var initMetric_1 = require_initMetric();
    var observe_1 = require_observe();
    var onHidden_1 = require_onHidden();
    exports.getCLS = function(onReport, reportAllChanges) {
      var metric = initMetric_1.initMetric("CLS", 0);
      var report;
      var sessionValue = 0;
      var sessionEntries = [];
      var entryHandler = function(entry6) {
        if (entry6 && !entry6.hadRecentInput) {
          var firstSessionEntry = sessionEntries[0];
          var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
          if (sessionValue && sessionEntries.length !== 0 && entry6.startTime - lastSessionEntry.startTime < 1e3 && entry6.startTime - firstSessionEntry.startTime < 5e3) {
            sessionValue += entry6.value;
            sessionEntries.push(entry6);
          } else {
            sessionValue = entry6.value;
            sessionEntries = [entry6];
          }
          if (sessionValue > metric.value) {
            metric.value = sessionValue;
            metric.entries = sessionEntries;
            if (report) {
              report();
            }
          }
        }
      };
      var po = observe_1.observe("layout-shift", entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        onHidden_1.onHidden(function() {
          po.takeRecords().map(entryHandler);
          report(true);
        });
      }
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/lib/getVisibilityWatcher.js
var require_getVisibilityWatcher = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/lib/getVisibilityWatcher.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var onHidden_1 = require_onHidden();
    var firstHiddenTime = -1;
    var initHiddenTime = function() {
      return utils_1.getGlobalObject().document.visibilityState === "hidden" ? 0 : Infinity;
    };
    var trackChanges = function() {
      onHidden_1.onHidden(function(_a4) {
        var timeStamp = _a4.timeStamp;
        firstHiddenTime = timeStamp;
      }, true);
    };
    exports.getVisibilityWatcher = function() {
      if (firstHiddenTime < 0) {
        firstHiddenTime = initHiddenTime();
        trackChanges();
      }
      return {
        get firstHiddenTime() {
          return firstHiddenTime;
        }
      };
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/getFID.js
var require_getFID = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/getFID.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter_1 = require_bindReporter();
    var getVisibilityWatcher_1 = require_getVisibilityWatcher();
    var initMetric_1 = require_initMetric();
    var observe_1 = require_observe();
    var onHidden_1 = require_onHidden();
    exports.getFID = function(onReport, reportAllChanges) {
      var visibilityWatcher = getVisibilityWatcher_1.getVisibilityWatcher();
      var metric = initMetric_1.initMetric("FID");
      var report;
      var entryHandler = function(entry6) {
        if (report && entry6.startTime < visibilityWatcher.firstHiddenTime) {
          metric.value = entry6.processingStart - entry6.startTime;
          metric.entries.push(entry6);
          report(true);
        }
      };
      var po = observe_1.observe("first-input", entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        onHidden_1.onHidden(function() {
          po.takeRecords().map(entryHandler);
          po.disconnect();
        }, true);
      }
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/web-vitals/getLCP.js
var require_getLCP = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/web-vitals/getLCP.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter_1 = require_bindReporter();
    var getVisibilityWatcher_1 = require_getVisibilityWatcher();
    var initMetric_1 = require_initMetric();
    var observe_1 = require_observe();
    var onHidden_1 = require_onHidden();
    var reportedMetricIDs = {};
    exports.getLCP = function(onReport, reportAllChanges) {
      var visibilityWatcher = getVisibilityWatcher_1.getVisibilityWatcher();
      var metric = initMetric_1.initMetric("LCP");
      var report;
      var entryHandler = function(entry6) {
        var value = entry6.startTime;
        if (value < visibilityWatcher.firstHiddenTime) {
          metric.value = value;
          metric.entries.push(entry6);
        }
        if (report) {
          report();
        }
      };
      var po = observe_1.observe("largest-contentful-paint", entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        var stopListening_1 = function() {
          if (!reportedMetricIDs[metric.id]) {
            po.takeRecords().map(entryHandler);
            po.disconnect();
            reportedMetricIDs[metric.id] = true;
            report(true);
          }
        };
        ["keydown", "click"].forEach(function(type) {
          addEventListener(type, stopListening_1, { once: true, capture: true });
        });
        onHidden_1.onHidden(stopListening_1, true);
      }
    };
  }
});

// node_modules/@sentry/tracing/dist/browser/metrics.js
var require_metrics3 = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/metrics.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var utils_2 = require_utils8();
    var getCLS_1 = require_getCLS();
    var getFID_1 = require_getFID();
    var getLCP_1 = require_getLCP();
    var getVisibilityWatcher_1 = require_getVisibilityWatcher();
    var global2 = utils_1.getGlobalObject();
    var MetricsInstrumentation = function() {
      function MetricsInstrumentation2(_reportAllChanges) {
        if (_reportAllChanges === void 0) {
          _reportAllChanges = false;
        }
        this._reportAllChanges = _reportAllChanges;
        this._measurements = {};
        this._performanceCursor = 0;
        if (!utils_1.isNodeEnv() && global2 && global2.performance && global2.document) {
          if (global2.performance.mark) {
            global2.performance.mark("sentry-tracing-init");
          }
          this._trackCLS();
          this._trackLCP();
          this._trackFID();
        }
      }
      MetricsInstrumentation2.prototype.addPerformanceEntries = function(transaction) {
        var _this = this;
        if (!global2 || !global2.performance || !global2.performance.getEntries || !utils_1.browserPerformanceTimeOrigin) {
          return;
        }
        utils_1.logger.log("[Tracing] Adding & adjusting spans using Performance API");
        var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
        var responseStartTimestamp;
        var requestStartTimestamp;
        global2.performance.getEntries().slice(this._performanceCursor).forEach(function(entry6) {
          var startTime = utils_2.msToSec(entry6.startTime);
          var duration = utils_2.msToSec(entry6.duration);
          if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
            return;
          }
          switch (entry6.entryType) {
            case "navigation": {
              addNavigationSpans(transaction, entry6, timeOrigin);
              responseStartTimestamp = timeOrigin + utils_2.msToSec(entry6.responseStart);
              requestStartTimestamp = timeOrigin + utils_2.msToSec(entry6.requestStart);
              break;
            }
            case "mark":
            case "paint":
            case "measure": {
              var startTimestamp = addMeasureSpans(transaction, entry6, startTime, duration, timeOrigin);
              var firstHidden = getVisibilityWatcher_1.getVisibilityWatcher();
              var shouldRecord = entry6.startTime < firstHidden.firstHiddenTime;
              if (entry6.name === "first-paint" && shouldRecord) {
                utils_1.logger.log("[Measurements] Adding FP");
                _this._measurements["fp"] = { value: entry6.startTime };
                _this._measurements["mark.fp"] = { value: startTimestamp };
              }
              if (entry6.name === "first-contentful-paint" && shouldRecord) {
                utils_1.logger.log("[Measurements] Adding FCP");
                _this._measurements["fcp"] = { value: entry6.startTime };
                _this._measurements["mark.fcp"] = { value: startTimestamp };
              }
              break;
            }
            case "resource": {
              var resourceName = entry6.name.replace(global2.location.origin, "");
              addResourceSpans(transaction, entry6, resourceName, startTime, duration, timeOrigin);
              break;
            }
            default:
          }
        });
        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
        this._trackNavigator(transaction);
        if (transaction.op === "pageload") {
          var timeOrigin_1 = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          if (typeof responseStartTimestamp === "number") {
            utils_1.logger.log("[Measurements] Adding TTFB");
            this._measurements["ttfb"] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1e3 };
            if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
              this._measurements["ttfb.requestTime"] = { value: (responseStartTimestamp - requestStartTimestamp) * 1e3 };
            }
          }
          ["fcp", "fp", "lcp"].forEach(function(name) {
            if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
              return;
            }
            var oldValue = _this._measurements[name].value;
            var measurementTimestamp = timeOrigin_1 + utils_2.msToSec(oldValue);
            var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
            var delta = normalizedValue - oldValue;
            utils_1.logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
            _this._measurements[name].value = normalizedValue;
          });
          if (this._measurements["mark.fid"] && this._measurements["fid"]) {
            _startChild(transaction, {
              description: "first input delay",
              endTimestamp: this._measurements["mark.fid"].value + utils_2.msToSec(this._measurements["fid"].value),
              op: "web.vitals",
              startTimestamp: this._measurements["mark.fid"].value
            });
          }
          if (!("fcp" in this._measurements)) {
            delete this._measurements.cls;
          }
          transaction.setMeasurements(this._measurements);
          tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
          transaction.setTag("sentry_reportAllChanges", this._reportAllChanges);
        }
      };
      MetricsInstrumentation2.prototype._trackNavigator = function(transaction) {
        var navigator2 = global2.navigator;
        if (!navigator2) {
          return;
        }
        var connection = navigator2.connection;
        if (connection) {
          if (connection.effectiveType) {
            transaction.setTag("effectiveConnectionType", connection.effectiveType);
          }
          if (connection.type) {
            transaction.setTag("connectionType", connection.type);
          }
          if (isMeasurementValue(connection.rtt)) {
            this._measurements["connection.rtt"] = { value: connection.rtt };
          }
          if (isMeasurementValue(connection.downlink)) {
            this._measurements["connection.downlink"] = { value: connection.downlink };
          }
        }
        if (isMeasurementValue(navigator2.deviceMemory)) {
          transaction.setTag("deviceMemory", String(navigator2.deviceMemory));
        }
        if (isMeasurementValue(navigator2.hardwareConcurrency)) {
          transaction.setTag("hardwareConcurrency", String(navigator2.hardwareConcurrency));
        }
      };
      MetricsInstrumentation2.prototype._trackCLS = function() {
        var _this = this;
        getCLS_1.getCLS(function(metric) {
          var entry6 = metric.entries.pop();
          if (!entry6) {
            return;
          }
          utils_1.logger.log("[Measurements] Adding CLS");
          _this._measurements["cls"] = { value: metric.value };
          _this._clsEntry = entry6;
        });
      };
      MetricsInstrumentation2.prototype._trackLCP = function() {
        var _this = this;
        getLCP_1.getLCP(function(metric) {
          var entry6 = metric.entries.pop();
          if (!entry6) {
            return;
          }
          var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          var startTime = utils_2.msToSec(entry6.startTime);
          utils_1.logger.log("[Measurements] Adding LCP");
          _this._measurements["lcp"] = { value: metric.value };
          _this._measurements["mark.lcp"] = { value: timeOrigin + startTime };
          _this._lcpEntry = entry6;
        }, this._reportAllChanges);
      };
      MetricsInstrumentation2.prototype._trackFID = function() {
        var _this = this;
        getFID_1.getFID(function(metric) {
          var entry6 = metric.entries.pop();
          if (!entry6) {
            return;
          }
          var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          var startTime = utils_2.msToSec(entry6.startTime);
          utils_1.logger.log("[Measurements] Adding FID");
          _this._measurements["fid"] = { value: metric.value };
          _this._measurements["mark.fid"] = { value: timeOrigin + startTime };
        });
      };
      return MetricsInstrumentation2;
    }();
    exports.MetricsInstrumentation = MetricsInstrumentation;
    function addNavigationSpans(transaction, entry6, timeOrigin) {
      ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(function(event) {
        addPerformanceNavigationTiming(transaction, entry6, event, timeOrigin);
      });
      addPerformanceNavigationTiming(transaction, entry6, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
      addPerformanceNavigationTiming(transaction, entry6, "fetch", timeOrigin, "cache", "domainLookupStart");
      addPerformanceNavigationTiming(transaction, entry6, "domainLookup", timeOrigin, "DNS");
      addRequest(transaction, entry6, timeOrigin);
    }
    function addMeasureSpans(transaction, entry6, startTime, duration, timeOrigin) {
      var measureStartTimestamp = timeOrigin + startTime;
      var measureEndTimestamp = measureStartTimestamp + duration;
      _startChild(transaction, {
        description: entry6.name,
        endTimestamp: measureEndTimestamp,
        op: entry6.entryType,
        startTimestamp: measureStartTimestamp
      });
      return measureStartTimestamp;
    }
    function addResourceSpans(transaction, entry6, resourceName, startTime, duration, timeOrigin) {
      if (entry6.initiatorType === "xmlhttprequest" || entry6.initiatorType === "fetch") {
        return;
      }
      var data = {};
      if ("transferSize" in entry6) {
        data["Transfer Size"] = entry6.transferSize;
      }
      if ("encodedBodySize" in entry6) {
        data["Encoded Body Size"] = entry6.encodedBodySize;
      }
      if ("decodedBodySize" in entry6) {
        data["Decoded Body Size"] = entry6.decodedBodySize;
      }
      var startTimestamp = timeOrigin + startTime;
      var endTimestamp = startTimestamp + duration;
      _startChild(transaction, {
        description: resourceName,
        endTimestamp,
        op: entry6.initiatorType ? "resource." + entry6.initiatorType : "resource",
        startTimestamp,
        data
      });
    }
    exports.addResourceSpans = addResourceSpans;
    function addPerformanceNavigationTiming(transaction, entry6, event, timeOrigin, description, eventEnd) {
      var end = eventEnd ? entry6[eventEnd] : entry6[event + "End"];
      var start = entry6[event + "Start"];
      if (!start || !end) {
        return;
      }
      _startChild(transaction, {
        op: "browser",
        description: description !== null && description !== void 0 ? description : event,
        startTimestamp: timeOrigin + utils_2.msToSec(start),
        endTimestamp: timeOrigin + utils_2.msToSec(end)
      });
    }
    function addRequest(transaction, entry6, timeOrigin) {
      _startChild(transaction, {
        op: "browser",
        description: "request",
        startTimestamp: timeOrigin + utils_2.msToSec(entry6.requestStart),
        endTimestamp: timeOrigin + utils_2.msToSec(entry6.responseEnd)
      });
      _startChild(transaction, {
        op: "browser",
        description: "response",
        startTimestamp: timeOrigin + utils_2.msToSec(entry6.responseStart),
        endTimestamp: timeOrigin + utils_2.msToSec(entry6.responseEnd)
      });
    }
    function _startChild(transaction, _a4) {
      var startTimestamp = _a4.startTimestamp, ctx = tslib_1.__rest(_a4, ["startTimestamp"]);
      if (startTimestamp && transaction.startTimestamp > startTimestamp) {
        transaction.startTimestamp = startTimestamp;
      }
      return transaction.startChild(tslib_1.__assign({ startTimestamp }, ctx));
    }
    exports._startChild = _startChild;
    function isMeasurementValue(value) {
      return typeof value === "number" && isFinite(value);
    }
    function tagMetricInfo(transaction, lcpEntry, clsEntry) {
      if (lcpEntry) {
        utils_1.logger.log("[Measurements] Adding LCP Data");
        if (lcpEntry.element) {
          transaction.setTag("lcp.element", utils_1.htmlTreeAsString(lcpEntry.element));
        }
        if (lcpEntry.id) {
          transaction.setTag("lcp.id", lcpEntry.id);
        }
        if (lcpEntry.url) {
          transaction.setTag("lcp.url", lcpEntry.url.trim().slice(0, 200));
        }
        transaction.setTag("lcp.size", lcpEntry.size);
      }
      if (clsEntry && clsEntry.sources) {
        utils_1.logger.log("[Measurements] Adding CLS Data");
        clsEntry.sources.forEach(function(source, index) {
          return transaction.setTag("cls.source." + (index + 1), utils_1.htmlTreeAsString(source.node));
        });
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/browser/request.js
var require_request3 = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/request.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var utils_2 = require_utils8();
    exports.DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
    exports.defaultRequestInstrumentationOptions = {
      traceFetch: true,
      traceXHR: true,
      tracingOrigins: exports.DEFAULT_TRACING_ORIGINS
    };
    function instrumentOutgoingRequests(_options) {
      var _a4 = tslib_1.__assign(tslib_1.__assign({}, exports.defaultRequestInstrumentationOptions), _options), traceFetch = _a4.traceFetch, traceXHR = _a4.traceXHR, tracingOrigins = _a4.tracingOrigins, shouldCreateSpanForRequest = _a4.shouldCreateSpanForRequest;
      var urlMap = {};
      var defaultShouldCreateSpan = function(url) {
        if (urlMap[url]) {
          return urlMap[url];
        }
        var origins = tracingOrigins;
        urlMap[url] = origins.some(function(origin) {
          return utils_1.isMatchingPattern(url, origin);
        }) && !utils_1.isMatchingPattern(url, "sentry_key");
        return urlMap[url];
      };
      var shouldCreateSpan = defaultShouldCreateSpan;
      if (typeof shouldCreateSpanForRequest === "function") {
        shouldCreateSpan = function(url) {
          return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
        };
      }
      var spans = {};
      if (traceFetch) {
        utils_1.addInstrumentationHandler("fetch", function(handlerData) {
          fetchCallback(handlerData, shouldCreateSpan, spans);
        });
      }
      if (traceXHR) {
        utils_1.addInstrumentationHandler("xhr", function(handlerData) {
          xhrCallback(handlerData, shouldCreateSpan, spans);
        });
      }
    }
    exports.instrumentOutgoingRequests = instrumentOutgoingRequests;
    function fetchCallback(handlerData, shouldCreateSpan, spans) {
      if (!utils_2.hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
        return;
      }
      if (handlerData.endTimestamp) {
        var spanId = handlerData.fetchData.__span;
        if (!spanId)
          return;
        var span = spans[spanId];
        if (span) {
          if (handlerData.response) {
            span.setHttpStatus(handlerData.response.status);
          } else if (handlerData.error) {
            span.setStatus("internal_error");
          }
          span.finish();
          delete spans[spanId];
        }
        return;
      }
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var span = activeTransaction.startChild({
          data: tslib_1.__assign(tslib_1.__assign({}, handlerData.fetchData), { type: "fetch" }),
          description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
          op: "http.client"
        });
        handlerData.fetchData.__span = span.spanId;
        spans[span.spanId] = span;
        var request = handlerData.args[0] = handlerData.args[0];
        var options = handlerData.args[1] = handlerData.args[1] || {};
        var headers = options.headers;
        if (utils_1.isInstanceOf(request, Request)) {
          headers = request.headers;
        }
        if (headers) {
          if (typeof headers.append === "function") {
            headers.append("sentry-trace", span.toTraceparent());
          } else if (Array.isArray(headers)) {
            headers = tslib_1.__spread(headers, [["sentry-trace", span.toTraceparent()]]);
          } else {
            headers = tslib_1.__assign(tslib_1.__assign({}, headers), { "sentry-trace": span.toTraceparent() });
          }
        } else {
          headers = { "sentry-trace": span.toTraceparent() };
        }
        options.headers = headers;
      }
    }
    exports.fetchCallback = fetchCallback;
    function xhrCallback(handlerData, shouldCreateSpan, spans) {
      if (!utils_2.hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
        return;
      }
      var xhr = handlerData.xhr.__sentry_xhr__;
      if (handlerData.endTimestamp) {
        var spanId = handlerData.xhr.__sentry_xhr_span_id__;
        if (!spanId)
          return;
        var span = spans[spanId];
        if (span) {
          span.setHttpStatus(xhr.status_code);
          span.finish();
          delete spans[spanId];
        }
        return;
      }
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var span = activeTransaction.startChild({
          data: tslib_1.__assign(tslib_1.__assign({}, xhr.data), { type: "xhr", method: xhr.method, url: xhr.url }),
          description: xhr.method + " " + xhr.url,
          op: "http.client"
        });
        handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
        spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
        if (handlerData.xhr.setRequestHeader) {
          try {
            handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
          } catch (_) {
          }
        }
      }
    }
    exports.xhrCallback = xhrCallback;
  }
});

// node_modules/@sentry/tracing/dist/browser/router.js
var require_router = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/router.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_dist2();
    var global2 = utils_1.getGlobalObject();
    function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
      if (startTransactionOnPageLoad === void 0) {
        startTransactionOnPageLoad = true;
      }
      if (startTransactionOnLocationChange === void 0) {
        startTransactionOnLocationChange = true;
      }
      if (!global2 || !global2.location) {
        utils_1.logger.warn("Could not initialize routing instrumentation due to invalid location");
        return;
      }
      var startingUrl = global2.location.href;
      var activeTransaction;
      if (startTransactionOnPageLoad) {
        activeTransaction = customStartTransaction({ name: global2.location.pathname, op: "pageload" });
      }
      if (startTransactionOnLocationChange) {
        utils_1.addInstrumentationHandler("history", function(_a4) {
          var to = _a4.to, from = _a4.from;
          if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
            startingUrl = void 0;
            return;
          }
          if (from !== to) {
            startingUrl = void 0;
            if (activeTransaction) {
              utils_1.logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
              activeTransaction.finish();
            }
            activeTransaction = customStartTransaction({ name: global2.location.pathname, op: "navigation" });
          }
        });
      }
    }
    exports.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;
  }
});

// node_modules/@sentry/tracing/dist/browser/browsertracing.js
var require_browsertracing = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/browsertracing.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib6();
    var utils_1 = require_dist2();
    var hubextensions_1 = require_hubextensions();
    var idletransaction_1 = require_idletransaction();
    var utils_2 = require_utils8();
    var backgroundtab_1 = require_backgroundtab();
    var metrics_1 = require_metrics3();
    var request_1 = require_request3();
    var router_1 = require_router();
    exports.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
    var DEFAULT_BROWSER_TRACING_OPTIONS = tslib_1.__assign({ idleTimeout: idletransaction_1.DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: exports.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: router_1.instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, request_1.defaultRequestInstrumentationOptions);
    var BrowserTracing = function() {
      function BrowserTracing2(_options) {
        this.name = BrowserTracing2.id;
        this._emitOptionsWarning = false;
        this._configuredIdleTimeout = void 0;
        var tracingOrigins = request_1.defaultRequestInstrumentationOptions.tracingOrigins;
        if (_options) {
          this._configuredIdleTimeout = _options.idleTimeout;
          if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
            tracingOrigins = _options.tracingOrigins;
          } else {
            this._emitOptionsWarning = true;
          }
        }
        this.options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins });
        var _metricOptions = this.options._metricOptions;
        this._metrics = new metrics_1.MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
      }
      BrowserTracing2.prototype.setupOnce = function(_, getCurrentHub) {
        var _this = this;
        this._getCurrentHub = getCurrentHub;
        if (this._emitOptionsWarning) {
          utils_1.logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
          utils_1.logger.warn("[Tracing] We added a reasonable default for you: " + request_1.defaultRequestInstrumentationOptions.tracingOrigins);
        }
        var _a4 = this.options, instrumentRouting = _a4.routingInstrumentation, startTransactionOnLocationChange = _a4.startTransactionOnLocationChange, startTransactionOnPageLoad = _a4.startTransactionOnPageLoad, markBackgroundTransactions = _a4.markBackgroundTransactions, traceFetch = _a4.traceFetch, traceXHR = _a4.traceXHR, tracingOrigins = _a4.tracingOrigins, shouldCreateSpanForRequest = _a4.shouldCreateSpanForRequest;
        instrumentRouting(function(context) {
          return _this._createRouteTransaction(context);
        }, startTransactionOnPageLoad, startTransactionOnLocationChange);
        if (markBackgroundTransactions) {
          backgroundtab_1.registerBackgroundTabDetection();
        }
        request_1.instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
      };
      BrowserTracing2.prototype._createRouteTransaction = function(context) {
        var _this = this;
        if (!this._getCurrentHub) {
          utils_1.logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
          return void 0;
        }
        var _a4 = this.options, beforeNavigate = _a4.beforeNavigate, idleTimeout = _a4.idleTimeout, maxTransactionDuration = _a4.maxTransactionDuration;
        var parentContextFromHeader = context.op === "pageload" ? getHeaderContext() : void 0;
        var expandedContext = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, context), parentContextFromHeader), { trimEnd: true });
        var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
        var finalContext = modifiedContext === void 0 ? tslib_1.__assign(tslib_1.__assign({}, expandedContext), { sampled: false }) : modifiedContext;
        if (finalContext.sampled === false) {
          utils_1.logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
        }
        utils_1.logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
        var hub = this._getCurrentHub();
        var location = utils_1.getGlobalObject().location;
        var idleTransaction = hubextensions_1.startIdleTransaction(hub, finalContext, idleTimeout, true, { location });
        idleTransaction.registerBeforeFinishCallback(function(transaction, endTimestamp) {
          _this._metrics.addPerformanceEntries(transaction);
          adjustTransactionDuration(utils_2.secToMs(maxTransactionDuration), transaction, endTimestamp);
        });
        idleTransaction.setTag("idleTimeout", this._configuredIdleTimeout);
        return idleTransaction;
      };
      BrowserTracing2.id = "BrowserTracing";
      return BrowserTracing2;
    }();
    exports.BrowserTracing = BrowserTracing;
    function getHeaderContext() {
      var header = getMetaContent("sentry-trace");
      if (header) {
        return utils_2.extractTraceparentData(header);
      }
      return void 0;
    }
    exports.getHeaderContext = getHeaderContext;
    function getMetaContent(metaName) {
      var el = utils_1.getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
      return el ? el.getAttribute("content") : null;
    }
    exports.getMetaContent = getMetaContent;
    function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
      var diff = endTimestamp - transaction.startTimestamp;
      var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
      if (isOutdatedTransaction) {
        transaction.setStatus("deadline_exceeded");
        transaction.setTag("maxTransactionDurationExceeded", "true");
      }
    }
  }
});

// node_modules/@sentry/tracing/dist/browser/index.js
var require_browser5 = __commonJS({
  "node_modules/@sentry/tracing/dist/browser/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var browsertracing_1 = require_browsertracing();
    exports.BrowserTracing = browsertracing_1.BrowserTracing;
    var request_1 = require_request3();
    exports.instrumentOutgoingRequests = request_1.instrumentOutgoingRequests;
    exports.defaultRequestInstrumentationOptions = request_1.defaultRequestInstrumentationOptions;
  }
});

// node_modules/@sentry/tracing/dist/integrations/index.js
var require_integrations3 = __commonJS({
  "node_modules/@sentry/tracing/dist/integrations/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var express_1 = require_express();
    exports.Express = express_1.Express;
    var postgres_1 = require_postgres();
    exports.Postgres = postgres_1.Postgres;
    var mysql_1 = require_mysql();
    exports.Mysql = mysql_1.Mysql;
    var mongo_1 = require_mongo();
    exports.Mongo = mongo_1.Mongo;
    var browser_1 = require_browser5();
    exports.BrowserTracing = browser_1.BrowserTracing;
  }
});

// node_modules/@sentry/tracing/dist/spanstatus.js
var require_spanstatus = __commonJS({
  "node_modules/@sentry/tracing/dist/spanstatus.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var SpanStatus;
    (function(SpanStatus2) {
      SpanStatus2["Ok"] = "ok";
      SpanStatus2["DeadlineExceeded"] = "deadline_exceeded";
      SpanStatus2["Unauthenticated"] = "unauthenticated";
      SpanStatus2["PermissionDenied"] = "permission_denied";
      SpanStatus2["NotFound"] = "not_found";
      SpanStatus2["ResourceExhausted"] = "resource_exhausted";
      SpanStatus2["InvalidArgument"] = "invalid_argument";
      SpanStatus2["Unimplemented"] = "unimplemented";
      SpanStatus2["Unavailable"] = "unavailable";
      SpanStatus2["InternalError"] = "internal_error";
      SpanStatus2["UnknownError"] = "unknown_error";
      SpanStatus2["Cancelled"] = "cancelled";
      SpanStatus2["AlreadyExists"] = "already_exists";
      SpanStatus2["FailedPrecondition"] = "failed_precondition";
      SpanStatus2["Aborted"] = "aborted";
      SpanStatus2["OutOfRange"] = "out_of_range";
      SpanStatus2["DataLoss"] = "data_loss";
    })(SpanStatus = exports.SpanStatus || (exports.SpanStatus = {}));
  }
});

// node_modules/@sentry/tracing/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@sentry/tracing/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var hubextensions_1 = require_hubextensions();
    exports.addExtensionMethods = hubextensions_1.addExtensionMethods;
    var Integrations2 = require_integrations3();
    exports.Integrations = Integrations2;
    var browser_1 = require_browser5();
    exports.BrowserTracing = browser_1.BrowserTracing;
    var span_1 = require_span();
    exports.Span = span_1.Span;
    exports.spanStatusfromHttpCode = span_1.spanStatusfromHttpCode;
    var spanstatus_1 = require_spanstatus();
    exports.SpanStatus = spanstatus_1.SpanStatus;
    var transaction_1 = require_transaction2();
    exports.Transaction = transaction_1.Transaction;
    var browser_2 = require_browser5();
    exports.registerRequestInstrumentation = browser_2.instrumentOutgoingRequests;
    exports.defaultRequestInstrumentationOptions = browser_2.defaultRequestInstrumentationOptions;
    var idletransaction_1 = require_idletransaction();
    exports.IdleTransaction = idletransaction_1.IdleTransaction;
    var hubextensions_2 = require_hubextensions();
    exports.startIdleTransaction = hubextensions_2.startIdleTransaction;
    hubextensions_1.addExtensionMethods();
    var utils_1 = require_utils8();
    exports.extractTraceparentData = utils_1.extractTraceparentData;
    exports.getActiveTransaction = utils_1.getActiveTransaction;
    exports.hasTracingEnabled = utils_1.hasTracingEnabled;
    exports.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
    exports.TRACEPARENT_REGEXP = utils_1.TRACEPARENT_REGEXP;
  }
});

// .svelte-kit/output/server/entries/pages/__layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
var import_logrocket, import_theme_change, import_qrcode, Sentry, import_tracing, import_splitio2, getStores, page, seo, Head, InboxIcon, KeyIcon, MailIcon, AzureIcon, BitbucketIcon, FacebookIcon, GithubIcon, GitlabIcon, GoogleIcon, TwitterIcon, Icon, css$5, SocialAuthView, css$4, Input, css$3, LinkButton, MagicLinkView, ForgottenPasswordView, css$2, EmailAuthView, css$1, Auth, AuthModal, css, BooleanOption, SettingsModal, Header, Nav, QRGenerator, ShareModal, _layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/__layout.svelte.js"() {
    init_index_d153bcdc();
    init_supabaseClient_772c11ee();
    init_SearchProviderSelect_577da9fc();
    init_Protected_4906baaa();
    import_logrocket = __toESM(require_build_umd(), 1);
    import_theme_change = __toESM(require_theme_change(), 1);
    import_qrcode = __toESM(require_lib6(), 1);
    Sentry = __toESM(require_dist6(), 1);
    import_tracing = __toESM(require_dist7(), 1);
    import_splitio2 = __toESM(require_lib4(), 1);
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        page: {
          subscribe: stores.page.subscribe
        },
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        get preloading() {
          console.error("stores.preloading is deprecated; use stores.navigating instead");
          return {
            subscribe: stores.navigating.subscribe
          };
        },
        session: stores.session,
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
    seo = writable2({
      title: "Pro-Search",
      description: "Advanced search query builder"
    });
    Head = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $seo, $$unsubscribe_seo;
      let $page, $$unsubscribe_page;
      $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      const { url: { pathname, host, protocol } } = $page;
      let description = $seo.description;
      let title = $seo.title;
      let unsubscribe;
      let url = `${protocol}//${host}${pathname}`;
      let image = `${protocol}//${host}/OG.png`;
      onDestroy(() => {
        unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
      });
      {
        {
          unsubscribe = seo.subscribe((value) => {
            description = value.description;
            title = value.title;
          });
        }
      }
      $$unsubscribe_seo();
      $$unsubscribe_page();
      return `${$$result.head += `${$$result.title = `<title>${escape($seo.title)}</title>`, ""}<link rel="${"canonical"}" href="${"https://pro-search.io"}" data-svelte="svelte-sytmgn"><meta name="${"description"}"${add_attribute("content", description, 0)} data-svelte="svelte-sytmgn"><meta property="${"og:type"}" content="${"website"}" data-svelte="svelte-sytmgn"><meta property="${"og:title"}"${add_attribute("content", title, 0)} data-svelte="svelte-sytmgn"><meta property="${"og:url"}"${add_attribute("content", url, 0)} data-svelte="svelte-sytmgn"><meta property="${"og:image"}"${add_attribute("content", image, 0)} data-svelte="svelte-sytmgn"><meta name="${"twitter:title"}"${add_attribute("content", title, 0)} data-svelte="svelte-sytmgn"><meta name="${"twitter:description"}"${add_attribute("content", description, 0)} data-svelte="svelte-sytmgn"><meta name="${"twitter:card"}" content="${"summary_large_image"}" data-svelte="svelte-sytmgn"><meta name="${"twitter:url"}"${add_attribute("content", url, 0)} data-svelte="svelte-sytmgn"><meta name="${"twitter:site"}" content="${"@bhekanik"}" data-svelte="svelte-sytmgn"><meta name="${"twitter:image"}"${add_attribute("content", image, 0)} data-svelte="svelte-sytmgn">${`<script data-svelte="svelte-sytmgn">(function (h, o, t, j, a, r) {
				h.hj =
					h.hj ||
					function () {
						(h.hj.q = h.hj.q || []).push(arguments);
					};
				h._hjSettings = { hjid: 2801982, hjsv: 6 };
				a = o.getElementsByTagName('head')[0];
				r = o.createElement('script');
				r.async = 1;
				r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
				a.appendChild(r);
			})(window, document, 'https://static.hotjar.com/c/hotjar-', '.js?sv=');
		<\/script>`}`, ""}`;
    });
    InboxIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = "100%" } = $$props;
      let { strokeWidth = 2 } = $$props;
      let { class: customClass = "" } = $$props;
      if (size !== "100%") {
        size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
      }
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      if ($$props.strokeWidth === void 0 && $$bindings.strokeWidth && strokeWidth !== void 0)
        $$bindings.strokeWidth(strokeWidth);
      if ($$props.class === void 0 && $$bindings.class && customClass !== void 0)
        $$bindings.class(customClass);
      return `<svg xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("width", size, 0)}${add_attribute("height", size, 0)} fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}"${add_attribute("stroke-width", strokeWidth, 0)} stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"feather feather-inbox " + escape(customClass)}"><polyline points="${"22 12 16 12 14 15 10 15 8 12 2 12"}"></polyline><path d="${"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"}"></path></svg>`;
    });
    KeyIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = "100%" } = $$props;
      let { strokeWidth = 2 } = $$props;
      let { class: customClass = "" } = $$props;
      if (size !== "100%") {
        size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
      }
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      if ($$props.strokeWidth === void 0 && $$bindings.strokeWidth && strokeWidth !== void 0)
        $$bindings.strokeWidth(strokeWidth);
      if ($$props.class === void 0 && $$bindings.class && customClass !== void 0)
        $$bindings.class(customClass);
      return `<svg xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("width", size, 0)}${add_attribute("height", size, 0)} fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}"${add_attribute("stroke-width", strokeWidth, 0)} stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"feather feather-key " + escape(customClass)}"><path d="${"M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"}"></path></svg>`;
    });
    MailIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = "100%" } = $$props;
      let { strokeWidth = 2 } = $$props;
      let { class: customClass = "" } = $$props;
      if (size !== "100%") {
        size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
      }
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      if ($$props.strokeWidth === void 0 && $$bindings.strokeWidth && strokeWidth !== void 0)
        $$bindings.strokeWidth(strokeWidth);
      if ($$props.class === void 0 && $$bindings.class && customClass !== void 0)
        $$bindings.class(customClass);
      return `<svg xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("width", size, 0)}${add_attribute("height", size, 0)} fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}"${add_attribute("stroke-width", strokeWidth, 0)} stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"feather feather-mail " + escape(customClass)}"><path d="${"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"}"></path><polyline points="${"22,6 12,13 2,6"}"></polyline></svg>`;
    });
    AzureIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 161.67 129"}"><path d="${"M88.33 0L40.67 41.33 0 114.33h36.67zm6.34 9.67L74.33 67l39 49-75.66 13h124z"}" fill="${"currentColor"}"></path></svg>`;
    });
    BitbucketIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 512 512"}"><path fill="${"currentColor"}" d="${"M22.2 32A16 16 0 0 0 6 47.8a26.35 26.35 0 0 0 .2 2.8l67.9 412.1a21.77 21.77 0 0 0 21.3 18.2h325.7a16 16 0 0 0 16-13.4L505 50.7a16 16 0 0 0-13.2-18.3 24.58 24.58 0 0 0-2.8-.2L22.2 32zm285.9 297.8h-104l-28.1-147h157.3l-25.2 147z"}"></path></svg>`;
    });
    FacebookIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 448 512"}"><path fill="${"currentColor"}" d="${"M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z"}"></path></svg>`;
    });
    GithubIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 496 512"}"><path fill="${"currentColor"}" d="${"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"}"></path></svg>`;
    });
    GitlabIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 512 512"}"><path fill="${"currentColor"}" d="${"M105.2 24.9c-3.1-8.9-15.7-8.9-18.9 0L29.8 199.7h132c-.1 0-56.6-174.8-56.6-174.8zM.9 287.7c-2.6 8 .3 16.9 7.1 22l247.9 184-226.2-294zm160.8-88l94.3 294 94.3-294zm349.4 88l-28.8-88-226.3 294 247.9-184c6.9-5.1 9.7-14 7.2-22zM425.7 24.9c-3.1-8.9-15.7-8.9-18.9 0l-56.6 174.8h132z"}"></path></svg>`;
    });
    GoogleIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 488 512"}"><path fill="${"currentColor"}" d="${"M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"}"></path></svg>`;
    });
    TwitterIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { size = 21 } = $$props;
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<svg${add_attribute("width", size, 0)} aria-hidden="${"true"}" focusable="${"false"}" role="${"img"}" xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 512 512"}"><path fill="${"currentColor"}" d="${"M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"}"></path></svg>`;
    });
    Icon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const map = {
        mail: MailIcon,
        key: KeyIcon,
        inbox: InboxIcon,
        google: GoogleIcon,
        facebook: FacebookIcon,
        twitter: TwitterIcon,
        github: GithubIcon,
        gitlab: GitlabIcon,
        bitbucket: BitbucketIcon,
        azure: AzureIcon
      };
      let { name } = $$props;
      let { size = 10 } = $$props;
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `${validate_component(map[name] || missing_component, "svelte:component").$$render($$result, {
        size: name === "mail" || name === "key" || name === "inbox" ? size.toString() : size
      }, {}, {})}`;
    });
    css$5 = {
      code: ".providers.svelte-fmtdhy.svelte-fmtdhy{display:flex;flex-direction:column;gap:10px}.providers.horizontal.svelte-fmtdhy.svelte-fmtdhy{flex-direction:row}.divider.svelte-fmtdhy.svelte-fmtdhy{color:rgb(187, 187, 187);margin:1rem 0;width:100%;display:flex;align-items:center;white-space:nowrap;font-size:0.9rem}.divider.svelte-fmtdhy span.svelte-fmtdhy{margin:1rem}.divider.svelte-fmtdhy.svelte-fmtdhy::before,.divider.svelte-fmtdhy.svelte-fmtdhy::after{border-bottom-style:solid;border-bottom-width:1px;top:50%;content:'';position:relative;display:inline-block;width:50%}.heading.svelte-fmtdhy.svelte-fmtdhy{font-weight:500;font-size:0.875rem;line-height:1.25rem;margin:0 0 0.5rem 0}",
      map: null
    };
    SocialAuthView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let hasProviders;
      let { supabaseClient } = $$props;
      let { providers = [] } = $$props;
      let { socialLayout = "vertical" } = $$props;
      let { view = "sign_in" } = $$props;
      let { redirectTo } = $$props;
      const buttonStyles = {
        google: {
          "background-color": "#ce4430",
          color: "white"
        },
        facebook: {
          "background-color": "#4267B2",
          color: "white"
        },
        twitter: { "background-color": "#1DA1F2" },
        gitlab: { "background-color": "#FC6D27" },
        github: {
          "background-color": "#333",
          color: "white"
        },
        bitbucket: {
          "background-color": "#205081",
          color: "white"
        },
        azure: {
          "background-color": "#0072c6",
          color: "white"
        }
      };
      if ($$props.supabaseClient === void 0 && $$bindings.supabaseClient && supabaseClient !== void 0)
        $$bindings.supabaseClient(supabaseClient);
      if ($$props.providers === void 0 && $$bindings.providers && providers !== void 0)
        $$bindings.providers(providers);
      if ($$props.socialLayout === void 0 && $$bindings.socialLayout && socialLayout !== void 0)
        $$bindings.socialLayout(socialLayout);
      if ($$props.view === void 0 && $$bindings.view && view !== void 0)
        $$bindings.view(view);
      if ($$props.redirectTo === void 0 && $$bindings.redirectTo && redirectTo !== void 0)
        $$bindings.redirectTo(redirectTo);
      $$result.css.add(css$5);
      hasProviders = providers && providers.length > 0;
      return `${hasProviders ? `<span class="${"heading svelte-fmtdhy"}">${escape(view == "sign_up" ? "Sign up" : "Sign in")} with</span>

	<div class="${["providers svelte-fmtdhy", socialLayout == "horizontal" ? "horizontal" : ""].join(" ").trim()}">${each(providers, (provider) => {
        return `<button class="${"btn btn-primary flex w-full"}"${add_attribute("style", Object.entries(buttonStyles[provider]).map(([key2, value]) => {
          return `${key2}: ${value}`;
        }).join(";"), 0)}><span class="${"flex mr-2"}">${validate_component(Icon, "Icon").$$render($$result, { name: provider, size: 21 }, {}, {})}</span>
				<span>${socialLayout == "vertical" ? `${escape(view == "sign_up" ? "Sign up" : "Sign in")} with ${escape(provider)}` : ``}</span>
			</button>`;
      })}</div>
	<div role="${"separator"}" class="${"divider svelte-fmtdhy"}"><span class="${"svelte-fmtdhy"}">or continue with</span></div>` : ``}

${``}`;
    });
    css$4 = {
      code: "label.svelte-jfgo2p{font-weight:500;font-size:0.875rem;line-height:1.25rem;display:flex;flex-direction:column;gap:5px;margin-bottom:1rem}input.svelte-jfgo2p{font-size:0.9rem;font-weight:300;background:transparent;border-radius:0.375rem;border-style:solid;border-width:1px;border-color:#ccc;box-sizing:border-box;display:flex;flex:1;padding:5px 3px 8px 40px}.icon.svelte-jfgo2p{position:absolute;color:#ccc;margin:12px 12px}.input.svelte-jfgo2p{position:relative;font-size:0.875rem;line-height:1.25rem;display:flex;padding:0}",
      map: null
    };
    Input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { name } = $$props;
      let { label } = $$props;
      let { placeholder = "" } = $$props;
      let { value } = $$props;
      let { icon = null } = $$props;
      let { type = "text" } = $$props;
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
        $$bindings.placeholder(placeholder);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.icon === void 0 && $$bindings.icon && icon !== void 0)
        $$bindings.icon(icon);
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      $$result.css.add(css$4);
      return `<label${add_attribute("for", name, 0)} class="${"svelte-jfgo2p"}">${escape(label)}

	<div class="${"input svelte-jfgo2p"}">${icon ? `<span class="${"icon svelte-jfgo2p"}">${validate_component(Icon, "Icon").$$render($$result, { name: icon, size: 21 }, {}, {})}</span>` : ``}

		${type == "text" ? `<input type="${"text"}"${add_attribute("name", name, 0)}${add_attribute("placeholder", placeholder || label, 0)} class="${"svelte-jfgo2p"}"${add_attribute("value", value, 0)}>` : `${type == "email" ? `<input type="${"email"}"${add_attribute("name", name, 0)}${add_attribute("placeholder", placeholder || label, 0)} class="${"svelte-jfgo2p"}"${add_attribute("value", value, 0)}>` : `${type == "password" ? `<input type="${"password"}"${add_attribute("name", name, 0)}${add_attribute("placeholder", placeholder || label, 0)} class="${"svelte-jfgo2p"}"${add_attribute("value", value, 0)}>` : ``}`}`}</div>
</label>`;
    });
    css$3 = {
      code: "button.svelte-say0m4{border:none;background:none;cursor:pointer;font-size:0.875rem;line-height:1.25rem;color:white;text-decoration:underline}",
      map: null
    };
    LinkButton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css$3);
      return `<button class="${"svelte-say0m4"}">${slots.default ? slots.default({}) : ``}</button>`;
    });
    MagicLinkView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { supabaseClient } = $$props;
      let { setView } = $$props;
      let email = "";
      if ($$props.supabaseClient === void 0 && $$bindings.supabaseClient && supabaseClient !== void 0)
        $$bindings.supabaseClient(supabaseClient);
      if ($$props.setView === void 0 && $$bindings.setView && setView !== void 0)
        $$bindings.setView(setView);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `<form>${validate_component(Input, "Input").$$render($$result, {
          name: "email",
          type: "email",
          label: "Email address",
          placeholder: "Your email address",
          icon: "mail",
          value: email
        }, {
          value: ($$value) => {
            email = $$value;
            $$settled = false;
          }
        }, {})}

	<button class="${"btn btn-primary w-full"}" ${""}>Send magic link</button>

	<div class="${"flex w-full mt-4 justify-center"}">${validate_component(LinkButton, "LinkButton").$$render($$result, {}, {}, {
          default: () => {
            return `Sign in with password`;
          }
        })}</div>

	${``}

	${``}</form>`;
      } while (!$$settled);
      return $$rendered;
    });
    ForgottenPasswordView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { supabaseClient } = $$props;
      let { setView } = $$props;
      let email = "";
      if ($$props.supabaseClient === void 0 && $$bindings.supabaseClient && supabaseClient !== void 0)
        $$bindings.supabaseClient(supabaseClient);
      if ($$props.setView === void 0 && $$bindings.setView && setView !== void 0)
        $$bindings.setView(setView);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `<form>${validate_component(Input, "Input").$$render($$result, {
          name: "email",
          type: "email",
          label: "Email address",
          placeholder: "Your email address",
          icon: "mail",
          value: email
        }, {
          value: ($$value) => {
            email = $$value;
            $$settled = false;
          }
        }, {})}
	<button class="${"btn btn-primary"}" ${""}>Send reset password instructions</button>

	${validate_component(LinkButton, "LinkButton").$$render($$result, {}, {}, {
          default: () => {
            return `Go back to sign in`;
          }
        })}

	${``}

	${``}</form>`;
      } while (!$$settled);
      return $$rendered;
    });
    css$2 = {
      code: "form.svelte-1ku972w{display:flex;flex-direction:column}.links.svelte-1ku972w{display:flex;flex-direction:column;margin:1rem 0;gap:0.5rem}",
      map: null
    };
    EmailAuthView = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { supabaseClient } = $$props;
      let { view } = $$props;
      let { setView } = $$props;
      let email = "", password = "";
      if ($$props.supabaseClient === void 0 && $$bindings.supabaseClient && supabaseClient !== void 0)
        $$bindings.supabaseClient(supabaseClient);
      if ($$props.view === void 0 && $$bindings.view && view !== void 0)
        $$bindings.view(view);
      if ($$props.setView === void 0 && $$bindings.setView && setView !== void 0)
        $$bindings.setView(setView);
      $$result.css.add(css$2);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `<form class="${"svelte-1ku972w"}">${validate_component(Input, "Input").$$render($$result, {
          name: "email",
          type: "email",
          label: "Email address",
          icon: "mail",
          value: email
        }, {
          value: ($$value) => {
            email = $$value;
            $$settled = false;
          }
        }, {})}
	${validate_component(Input, "Input").$$render($$result, {
          name: "password",
          type: "password",
          label: "Password",
          icon: "key",
          value: password
        }, {
          value: ($$value) => {
            password = $$value;
            $$settled = false;
          }
        }, {})}

	${view == "sign_up" ? `<button class="${"btn btn-primary"}" ${""}>Sign up</button>
		<div class="${"links svelte-1ku972w"}">${validate_component(LinkButton, "LinkButton").$$render($$result, {}, {}, {
          default: () => {
            return `Sign in with magic link`;
          }
        })}
			${validate_component(LinkButton, "LinkButton").$$render($$result, {}, {}, {
          default: () => {
            return `Do you have an account? Sign in`;
          }
        })}</div>` : `<button class="${"btn btn-primary"}" ${""}>Sign in</button>
		<div class="${"links svelte-1ku972w"}">${validate_component(LinkButton, "LinkButton").$$render($$result, {}, {}, {
          default: () => {
            return `Don&#39;t have an account? Sign up`;
          }
        })}</div>`}

	${``}

	${``}
</form>`;
      } while (!$$settled);
      return $$rendered;
    });
    css$1 = {
      code: ".component.svelte-vtvmio{width:100%}.container.svelte-vtvmio{display:flex;flex-direction:column}",
      map: null
    };
    Auth = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { class: classes = "" } = $$props;
      let { style = "" } = $$props;
      let { socialLayout = "vertical" } = $$props;
      let { providers = [] } = $$props;
      let { view = "sign_in" } = $$props;
      let { redirectTo = "" } = $$props;
      function setView(newView) {
        view = newView;
      }
      if ($$props.class === void 0 && $$bindings.class && classes !== void 0)
        $$bindings.class(classes);
      if ($$props.style === void 0 && $$bindings.style && style !== void 0)
        $$bindings.style(style);
      if ($$props.socialLayout === void 0 && $$bindings.socialLayout && socialLayout !== void 0)
        $$bindings.socialLayout(socialLayout);
      if ($$props.providers === void 0 && $$bindings.providers && providers !== void 0)
        $$bindings.providers(providers);
      if ($$props.view === void 0 && $$bindings.view && view !== void 0)
        $$bindings.view(view);
      if ($$props.redirectTo === void 0 && $$bindings.redirectTo && redirectTo !== void 0)
        $$bindings.redirectTo(redirectTo);
      $$result.css.add(css$1);
      return `<div class="${"component px-8 " + escape(classes) + " svelte-vtvmio"}"${add_attribute("style", style, 0)}><div class="${"container svelte-vtvmio"}">${validate_component(SocialAuthView, "SocialAuthView").$$render($$result, {
        supabaseClient: supabase,
        providers,
        socialLayout,
        view,
        redirectTo
      }, {}, {})}

		${view == "sign_in" || view == "sign_up" ? `${validate_component(EmailAuthView, "EmailAuthView").$$render($$result, { supabaseClient: supabase, view, setView }, {}, {})}` : `${view == "magic_link" ? `${validate_component(MagicLinkView, "MagicLinkView").$$render($$result, { supabaseClient: supabase, setView }, {}, {})}` : `${view == "forgotten_password" ? `${validate_component(ForgottenPasswordView, "ForgottenPasswordView").$$render($$result, { supabaseClient: supabase, setView }, {}, {})}` : ``}`}`}</div>
</div>`;
    });
    AuthModal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { closeModalButton = null } = $$props;
      let { redirectTo = "" } = $$props;
      if ($$props.closeModalButton === void 0 && $$bindings.closeModalButton && closeModalButton !== void 0)
        $$bindings.closeModalButton(closeModalButton);
      if ($$props.redirectTo === void 0 && $$bindings.redirectTo && redirectTo !== void 0)
        $$bindings.redirectTo(redirectTo);
      return `<input type="${"checkbox"}" id="${"auth-modal"}" class="${"modal-toggle"}">
<div class="${"modal"}"><div class="${"modal-box"}"><h3 class="${"font-bold text-lg p-8"}">Login/Register</h3>
		${validate_component(Auth, "Auth").$$render($$result, {
        providers: ["google", "github"],
        redirectTo
      }, {}, {})}
		<div class="${"modal-action px-8 pb-8"}"><label for="${"auth-modal"}" class="${"btn w-full"}"${add_attribute("this", closeModalButton, 0)}>Close</label></div></div></div>`;
    });
    css = {
      code: ".container.svelte-13ureke{display:grid;gap:1rem;margin:0.5rem 0}.input-label.svelte-13ureke{display:flex;align-items:center;gap:0.5rem}",
      map: null
    };
    BooleanOption = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { enabled = false } = $$props;
      let { label = "" } = $$props;
      let { name } = $$props;
      let { textInputPlaceholder = "" } = $$props;
      let { value } = $$props;
      let { handleCheckboxChange } = $$props;
      let { hasInput = false } = $$props;
      if ($$props.enabled === void 0 && $$bindings.enabled && enabled !== void 0)
        $$bindings.enabled(enabled);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.textInputPlaceholder === void 0 && $$bindings.textInputPlaceholder && textInputPlaceholder !== void 0)
        $$bindings.textInputPlaceholder(textInputPlaceholder);
      if ($$props.value === void 0 && $$bindings.value && value !== void 0)
        $$bindings.value(value);
      if ($$props.handleCheckboxChange === void 0 && $$bindings.handleCheckboxChange && handleCheckboxChange !== void 0)
        $$bindings.handleCheckboxChange(handleCheckboxChange);
      if ($$props.hasInput === void 0 && $$bindings.hasInput && hasInput !== void 0)
        $$bindings.hasInput(hasInput);
      $$result.css.add(css);
      return `<div class="${"container svelte-13ureke"}"><label class="${"input-label svelte-13ureke"}"><input type="${"checkbox"}" class="${"toggle toggle-primary"}"${add_attribute("name", name, 0)}${add_attribute("id", `${label}-checkbox`, 0)}${add_attribute("value", value, 0)}>
		${escape(label)}</label>

	${enabled && hasInput ? `<input class="${"input input-bordered"}" type="${"text"}"${add_attribute("name", `${label}-input`, 0)} id="${""}"${add_attribute("placeholder", textInputPlaceholder || label, 0)}${add_attribute("value", "some value", 0)}>` : ``}
</div>`;
    });
    SettingsModal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $searchProvidersStore, $$unsubscribe_searchProvidersStore;
      let $$unsubscribe_authStore;
      let $settingsStore, $$unsubscribe_settingsStore;
      $$unsubscribe_searchProvidersStore = subscribe(searchProvidersStore, (value) => $searchProvidersStore = value);
      $$unsubscribe_authStore = subscribe(authStore, (value) => value);
      $$unsubscribe_settingsStore = subscribe(settingsStore, (value) => $settingsStore = value);
      let newSettings = $settingsStore;
      function handleCheckboxChange(e2) {
        const { checked, name } = e2.target;
        newSettings = __spreadProps(__spreadValues({}, newSettings), { [name]: checked });
      }
      $$unsubscribe_searchProvidersStore();
      $$unsubscribe_authStore();
      $$unsubscribe_settingsStore();
      return `${validate_component(Protected, "Protected").$$render($$result, {}, {}, {
        default: () => {
          return `<input type="${"checkbox"}" id="${"my-modal-2"}" class="${"modal-toggle"}">

	<div class="${"modal"}"><div class="${"modal-box"}"><h3 class="${"font-bold text-xl mb-8"}">Settings</h3>
			${validate_component(BooleanOption, "BooleanOption").$$render($$result, {
            name: "autosave_queries",
            handleCheckboxChange,
            value: $settingsStore.autosave_queries,
            label: "Autosave Queries"
          }, {}, {})}
			${validate_component(BooleanOption, "BooleanOption").$$render($$result, {
            name: "query_preview",
            handleCheckboxChange,
            value: $settingsStore.query_preview,
            label: "Query URL Preview"
          }, {}, {})}
			<span class="${"input-label mr-4"}">Default Search Provider: </span>
			${validate_component(SearchProviderSelect, "SearchProviderSelect").$$render($$result, {
            value: $settingsStore.default_search_provider.id,
            searchProviders: $searchProvidersStore
          }, {}, {})}

			<div class="${"divider"}"></div>
			<div class="${"modal-action"}"><label for="${"my-modal-2"}" class="${"btn btn-primary"}">Accept</label>
				<label for="${"my-modal-2"}" class="${"btn"}">Cancel</label></div></div></div>`;
        }
      })}`;
    });
    Header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      var _a5, _b2, _c2, _d3, _e2, _f, _g, _h, _i, _j, _k, _l;
      let $authStore, $$unsubscribe_authStore;
      let $readiness, $$unsubscribe_readiness;
      $$unsubscribe_authStore = subscribe(authStore, (value) => $authStore = value);
      $$unsubscribe_readiness = subscribe(readiness, (value) => $readiness = value);
      var _a4, _b, _c, _d2, _e;
      {
        import_logrocket.default.init("uetpov/pro-search");
      }
      let closeModalButton = null;
      let redirectTo = "";
      let initial = ((_b = (_a4 = $authStore.user) === null || _a4 === void 0 ? void 0 : _a4.user_metadata) === null || _b === void 0 ? void 0 : _b.full_name.split(" ").map((n) => n.charAt(0)).join("").toUpperCase()) || ((_e = (_d2 = (_c = $authStore.user) === null || _c === void 0 ? void 0 : _c.user_metadata) === null || _d2 === void 0 ? void 0 : _d2.name) === null || _e === void 0 ? void 0 : _e.split(" ").map((n) => n.charAt(0)).join("").toUpperCase());
      onDestroy(() => {
        splitClient === null || splitClient === void 0 ? void 0 : splitClient.destroy();
        supabase.removeAllSubscriptions();
      });
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `<header class="${"flex justify-between align-center px-8 py-4"}"><div class="${"flex gap-2 items-center justify-center"}"><img class="${"w-10 h-10"}" src="${"/logo_512.png"}" alt="${"logo"}">
		<h1 class="${"text2xl md:text-4xl text-left bg-transparent font-medium"}">${escape("Pro-Search - Dev")}</h1></div>

	${validate_component(SettingsModal, "SettingsModal").$$render($$result, {}, {}, {})}
	${validate_component(AuthModal, "AuthModal").$$render($$result, { redirectTo, closeModalButton }, {
          closeModalButton: ($$value) => {
            closeModalButton = $$value;
            $$settled = false;
          }
        }, {})}
	<div class="${"flex gap-2 items-center"}">${$readiness ? `
			${$authStore.isLoggedIn ? `<label for="${"my-modal-2"}" class="${"btn btn-sm btn-ghost border modal-button"}">Settings</label>
				<div class="${"dropdown dropdown-end"}"><div tabindex="${"0"}" class="${[
          "avatar",
          !((_b2 = (_a5 = $authStore.user) == null ? void 0 : _a5.user_metadata) == null ? void 0 : _b2.photoURL) ? "placeholder" : ""
        ].join(" ").trim()}"><div class="${"rounded-full w-8 h-8 ring ring-primary"}">${((_d3 = (_c2 = $authStore.user) == null ? void 0 : _c2.user_metadata) == null ? void 0 : _d3.picture) || ((_f = (_e2 = $authStore.user) == null ? void 0 : _e2.user_metadata) == null ? void 0 : _f.avatar_url) ? `<img alt="${"profile"}"${add_attribute("src", ((_h = (_g = $authStore.user) == null ? void 0 : _g.user_metadata) == null ? void 0 : _h.picture) || ((_j = (_i = $authStore.user) == null ? void 0 : _i.user_metadata) == null ? void 0 : _j.avatar_url), 0)}>` : `<span class="${"text-s"}">${escape(initial)}</span>`}</div></div>

					<ul tabindex="${"0"}" class="${"menu dropdown-content rounded-box w-52 bordered shadow-lg bg-slate-600"}">${((_k = $authStore.user) == null ? void 0 : _k.email) ? `<li><span>${escape((_l = $authStore.user) == null ? void 0 : _l.email)}</span></li>` : ``}
						
						<li><span>Logout</span></li></ul></div>` : `<label for="${"auth-modal"}" class="${"btn btn-sm btn-ghost"}">Login / Sign Up</label>`}` : `<div class="${"btn btn-sm btn-circle btn-ghost btn-xl loading"}"></div>`}</div></header>`;
      } while (!$$settled);
      $$unsubscribe_authStore();
      $$unsubscribe_readiness();
      return $$rendered;
    });
    Nav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $page, $$unsubscribe_page;
      let $authStore, $$unsubscribe_authStore;
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      $$unsubscribe_authStore = subscribe(authStore, (value) => $authStore = value);
      $$unsubscribe_page();
      $$unsubscribe_authStore();
      return `<div class="${"tabs border-b px-8 border-b-gray-400"}"><a href="${"/"}" class="${["tab tab-bordered", $page.url.pathname === "/" ? "tab-active" : ""].join(" ").trim()}">Search</a>
	<a href="${"/recipes"}" class="${["tab tab-bordered", $page.url.pathname === "/recipes" ? "tab-active" : ""].join(" ").trim()}">Recipes</a>
	${$authStore.isLoggedIn ? `<a href="${"/saved-queries"}" class="${[
        "tab tab-bordered",
        $page.url.pathname === "/saved-queries" ? "tab-active" : ""
      ].join(" ").trim()}">Saved Queries</a>` : ``}</div>`;
    });
    QRGenerator = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let canvas = null;
      let { link } = $$props;
      if ($$props.link === void 0 && $$bindings.link && link !== void 0)
        $$bindings.link(link);
      return `<canvas${add_attribute("this", canvas, 0)}></canvas>`;
    });
    ShareModal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { query } = $$props;
      let link = "";
      let copiedText = "";
      if ($$props.query === void 0 && $$bindings.query && query !== void 0)
        $$bindings.query(query);
      return `<input type="${"checkbox"}"${add_attribute("id", `share-modal-btn-${query.id}`, 0)} class="${"modal-toggle"}">
<div class="${"modal"}"><div class="${"modal-box"}"><div class="${"flex gap-2"}">${validate_component(QRGenerator, "QrGenerator").$$render($$result, { link }, {}, {})}
			<div class="${"flex-1"}"><div class="${"w-full flex gap-2"}"><input type="${"text"}" class="${"input input-sm input-bordered w-full"}" readonly${add_attribute("value", link, 0)}>
					<button class="${"btn btn-outline btn-sm"}">Copy</button></div>
				<p class="${"text-sm w-full px-2"}">${escape(copiedText)}</p></div></div>

		<div class="${"modal-action"}"><button${add_attribute("for", `share-modal-btn-${query.id}`, 0)} class="${"btn btn-sm btn-primary"}">Share</button>
			<label${add_attribute("for", `share-modal-btn-${query.id}`, 0)} class="${"btn btn-sm"}">Close</label></div></div></div>`;
    });
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $queryToShareStore, $$unsubscribe_queryToShareStore;
      $$unsubscribe_queryToShareStore = subscribe(queryToShareStore, (value) => $queryToShareStore = value);
      {
        Sentry.init({
          dsn: "https://02775679838d495d91eacec805880d2a@o1115887.ingest.sentry.io/6148918",
          integrations: [new import_tracing.Integrations.BrowserTracing()],
          tracesSampleRate: 0.5
        });
      }
      onDestroy(() => splitClient === null || splitClient === void 0 ? void 0 : splitClient.destroy());
      $$unsubscribe_queryToShareStore();
      return `${validate_component(Head, "Head").$$render($$result, {}, {}, {})}
${validate_component(Header, "Header").$$render($$result, {}, {}, {})}
${validate_component(Nav, "Nav").$$render($$result, {}, {}, {})}
${slots.default ? slots.default({}) : ``}
${$queryToShareStore ? `${validate_component(ShareModal, "ShareModal").$$render($$result, { query: $queryToShareStore }, {}, {})}` : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  css: () => css2,
  entry: () => entry,
  js: () => js,
  module: () => layout_svelte_exports
});
var entry, js, css2;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_svelte();
    entry = "pages/__layout.svelte-1922302e.js";
    js = ["pages/__layout.svelte-1922302e.js", "chunks/vendor-739188d0.js", "chunks/supabaseClient-f98d745b.js", "chunks/generateQueryUrl-359b1f52.js", "chunks/Protected-cbec64e8.js"];
    css2 = ["assets/pages/__layout.svelte-0bf054f3.css"];
  }
});

// .svelte-kit/output/server/entries/pages/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/error.svelte.js"() {
    init_index_d153bcdc();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  css: () => css3,
  entry: () => entry2,
  js: () => js2,
  module: () => error_svelte_exports
});
var entry2, js2, css3;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_error_svelte();
    entry2 = "error.svelte-1468afc0.js";
    js2 = ["error.svelte-1468afc0.js", "chunks/vendor-739188d0.js"];
    css3 = [];
  }
});

// node_modules/case/dist/Case.js
var require_Case = __commonJS({
  "node_modules/case/dist/Case.js"(exports, module2) {
    (function() {
      "use strict";
      var unicodes = function(s3, prefix) {
        prefix = prefix || "";
        return s3.replace(/(^|-)/g, "$1\\u" + prefix).replace(/,/g, "\\u" + prefix);
      }, basicSymbols = unicodes("20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7", "00"), baseLowerCase = "a-z" + unicodes("DF-F6,F8-FF", "00"), baseUpperCase = "A-Z" + unicodes("C0-D6,D8-DE", "00"), improperInTitle = "A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via", regexps = function(symbols, lowers, uppers, impropers) {
        symbols = symbols || basicSymbols;
        lowers = lowers || baseLowerCase;
        uppers = uppers || baseUpperCase;
        impropers = impropers || improperInTitle;
        return {
          capitalize: new RegExp("(^|[" + symbols + "])([" + lowers + "])", "g"),
          pascal: new RegExp("(^|[" + symbols + "])+([" + lowers + uppers + "])", "g"),
          fill: new RegExp("[" + symbols + "]+(.|$)", "g"),
          sentence: new RegExp('(^\\s*|[\\?\\!\\.]+"?\\s+"?|,\\s+")([' + lowers + "])", "g"),
          improper: new RegExp("\\b(" + impropers + ")\\b", "g"),
          relax: new RegExp("([^" + uppers + "])([" + uppers + "]*)([" + uppers + "])(?=[^" + uppers + "]|$)", "g"),
          upper: new RegExp("^[^" + lowers + "]+$"),
          hole: /[^\s]\s[^\s]/,
          apostrophe: /'/g,
          room: new RegExp("[" + symbols + "]")
        };
      }, re = regexps(), _ = {
        re,
        unicodes,
        regexps,
        types: [],
        up: String.prototype.toUpperCase,
        low: String.prototype.toLowerCase,
        cap: function(s3) {
          return _.up.call(s3.charAt(0)) + s3.slice(1);
        },
        decap: function(s3) {
          return _.low.call(s3.charAt(0)) + s3.slice(1);
        },
        deapostrophe: function(s3) {
          return s3.replace(re.apostrophe, "");
        },
        fill: function(s3, fill, deapostrophe) {
          if (fill != null) {
            s3 = s3.replace(re.fill, function(m2, next) {
              return next ? fill + next : "";
            });
          }
          if (deapostrophe) {
            s3 = _.deapostrophe(s3);
          }
          return s3;
        },
        prep: function(s3, fill, pascal, upper) {
          s3 = s3 == null ? "" : s3 + "";
          if (!upper && re.upper.test(s3)) {
            s3 = _.low.call(s3);
          }
          if (!fill && !re.hole.test(s3)) {
            var holey = _.fill(s3, " ");
            if (re.hole.test(holey)) {
              s3 = holey;
            }
          }
          if (!pascal && !re.room.test(s3)) {
            s3 = s3.replace(re.relax, _.relax);
          }
          return s3;
        },
        relax: function(m2, before, acronym, caps) {
          return before + " " + (acronym ? acronym + " " : "") + caps;
        }
      }, Case2 = {
        _,
        of: function(s3) {
          for (var i2 = 0, m2 = _.types.length; i2 < m2; i2++) {
            if (Case2[_.types[i2]].apply(Case2, arguments) === s3) {
              return _.types[i2];
            }
          }
        },
        flip: function(s3) {
          return s3.replace(/\w/g, function(l) {
            return (l == _.up.call(l) ? _.low : _.up).call(l);
          });
        },
        random: function(s3) {
          return s3.replace(/\w/g, function(l) {
            return (Math.round(Math.random()) ? _.up : _.low).call(l);
          });
        },
        type: function(type2, fn) {
          Case2[type2] = fn;
          _.types.push(type2);
        }
      }, types2 = {
        lower: function(s3, fill, deapostrophe) {
          return _.fill(_.low.call(_.prep(s3, fill)), fill, deapostrophe);
        },
        snake: function(s3) {
          return Case2.lower(s3, "_", true);
        },
        constant: function(s3) {
          return Case2.upper(s3, "_", true);
        },
        camel: function(s3) {
          return _.decap(Case2.pascal(s3));
        },
        kebab: function(s3) {
          return Case2.lower(s3, "-", true);
        },
        upper: function(s3, fill, deapostrophe) {
          return _.fill(_.up.call(_.prep(s3, fill, false, true)), fill, deapostrophe);
        },
        capital: function(s3, fill, deapostrophe) {
          return _.fill(_.prep(s3).replace(re.capitalize, function(m2, border, letter) {
            return border + _.up.call(letter);
          }), fill, deapostrophe);
        },
        header: function(s3) {
          return Case2.capital(s3, "-", true);
        },
        pascal: function(s3) {
          return _.fill(_.prep(s3, false, true).replace(re.pascal, function(m2, border, letter) {
            return _.up.call(letter);
          }), "", true);
        },
        title: function(s3) {
          return Case2.capital(s3).replace(re.improper, function(small, p, i2, s4) {
            return i2 > 0 && i2 < s4.lastIndexOf(" ") ? _.low.call(small) : small;
          });
        },
        sentence: function(s3, names, abbreviations) {
          s3 = Case2.lower(s3).replace(re.sentence, function(m2, prelude, letter) {
            return prelude + _.up.call(letter);
          });
          if (names) {
            names.forEach(function(name) {
              s3 = s3.replace(new RegExp("\\b" + Case2.lower(name) + "\\b", "g"), _.cap);
            });
          }
          if (abbreviations) {
            abbreviations.forEach(function(abbr) {
              s3 = s3.replace(new RegExp("(\\b" + Case2.lower(abbr) + "\\. +)(\\w)"), function(m2, abbrAndSpace, letter) {
                return abbrAndSpace + _.low.call(letter);
              });
            });
          }
          return s3;
        }
      };
      types2.squish = types2.pascal;
      Case2.default = Case2;
      for (var type in types2) {
        Case2.type(type, types2[type]);
      }
      var define2 = typeof define2 === "function" ? define2 : function() {
      };
      define2(typeof module2 === "object" && module2.exports ? module2.exports = Case2 : this.Case = Case2);
    }).call(exports);
  }
});

// .svelte-kit/output/server/chunks/SavedQuery-7048865a.js
var savedQueriesStore, SavedQuery;
var init_SavedQuery_7048865a = __esm({
  ".svelte-kit/output/server/chunks/SavedQuery-7048865a.js"() {
    init_supabaseClient_772c11ee();
    init_index_d153bcdc();
    savedQueriesStore = writable2([]);
    SavedQuery = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { query } = $$props;
      let { handleShare } = $$props;
      const generateFilters = (filters) => Object.values(filters).reduce((prev, curr) => `${prev ? prev : ""}${prev && curr ? ", " : ""}${curr.type}: ${curr.value}`, "");
      if ($$props.query === void 0 && $$bindings.query && query !== void 0)
        $$bindings.query(query);
      if ($$props.handleShare === void 0 && $$bindings.handleShare && handleShare !== void 0)
        $$bindings.handleShare(handleShare);
      return `<div class="${"mb-2"}"><h1 class="${"font-medium text-lg text-gray-300 whitespace-nowrap overflow-hidden text-ellipsis"}">${escape(query.name)}</h1></div>
<div><span class="${"text-gray-300"}">Query Term: </span>
	<span class="${"font-medium text-gray-300 whitespace-nowrap overflow-hidden text-ellipsis"}">${escape(query.search_term)}</span></div>
<div><span class="${"text-gray-300"}">Search Provider: </span>
	<span class="${"font-medium text-gray-300 whitespace-nowrap overflow-hidden text-ellipsis"}">${escape(query.provider.name)}</span></div>
<div><span class="${"text-gray-300"}">Filters: </span>
	<span class="${"font-medium text-gray-300 whitespace-nowrap overflow-hidden text-ellipsis"}">${escape(generateFilters(query.filters))}</span></div>
<div class="${"flex gap-1 align-middle items-center justify-end mt-2"}"><label${add_attribute("for", `share-modal-btn-${query.id}`, 0)} class="${"btn btn-sm btn-ghost glass modal-button text-gray-300"}">Share</label>
	<button class="${"btn btn-sm glass text-gray-300"}">Apply</button>
	<button class="${"btn btn-sm glass text-gray-300"}">Delete</button></div>`;
    });
  }
});

// node_modules/graphemesplit/types.js
var require_types5 = __commonJS({
  "node_modules/graphemesplit/types.js"(exports, module2) {
    module2.exports = {
      Other: 0,
      CR: 1 << 0,
      LF: 1 << 1,
      Control: 1 << 2,
      Extend: 1 << 3,
      ZWJ: 1 << 4,
      Regional_Indicator: 1 << 5,
      Prepend: 1 << 6,
      SpacingMark: 1 << 7,
      L: 1 << 8,
      V: 1 << 9,
      T: 1 << 10,
      LV: 1 << 11,
      LVT: 1 << 12,
      Extended_Pictographic: 1 << 13
    };
  }
});

// node_modules/graphemesplit/typeTrie.json
var require_typeTrie = __commonJS({
  "node_modules/graphemesplit/typeTrie.json"(exports, module2) {
    module2.exports = { data: "ABAOAAAAAACwiAAAAYkHdvjtnH+IFkUYxx/v3vPe7uw8UkjsD43ChKICDQsT3iIJy4gSiZAjkn5JUFlaiFmjccT9ESkpGBGVIlQgWSkY/QDBoMgrQv0jRJDAfkCXhUmgRX23d4ebnndmd3Z3ZnfVeeDDzM7MPs8zv57Zd2+5hd1Ed4ClYAisBuuUsqLpMHgJjIBNFu1fBW8l1O8AO8Ee8Cn4HIyCg+CI0u4Y+AmMgVPgDOhuEHWBPjAZXAy2gjfA9kb73hlx+i7SK8AHYDf4BOwHB8AoOAyOguPgB/ArOKlcnwHdPe32/Uin9LTvvwTph0gv62nbubKnXT+nZ1z/DcjfFF8vQno7uEaxH923BGVXN9v5Zcgvj/VFPIT8Y/H1k0jXxPn1SEfARjBdab8V+TfB22CXUh5xd3OcZTH3g6di1LZJbLNs55q96M9n4J9Gm6hsfzQvcT8fbfy//TyUf8vG4Lses/5jcd2PSE/IcQan4/o/UXYadE0kaoJBMG1ivNbidNbETr1XoWyuplwyHFN0fFai/8/EY7BIKY/68EpCvwP+mc/m/2vNGnBhp1eZ51bCmgsEAoFAIBAIBAKBQKAO3Irfrg3lfc4qi/cXd+Kee5TfvAd6ieY0ie5D2cNx+eNInwZLmu33gWuRn4/8C3H9CNJNYEt8/TrS35HuSPktvRP1z0LPOvAceB4IsB5saIa6UBfqQl2oc123AjwBVjWrP7MCgcC5y/ue/56yqXv87+qcIU2Z+ny8tuHHpyxsvrDNITDXgqkDRJcPdJY/wMo24/oQmDqZaPHkdplAuhv8ApqDRDeCVj/OAvD9BUSX9qF8Qpt7lTxnZ7+5TmVtrGMM7XchP3sS0SNgGzg4yU5HIBAIBM5NfsO5QDgfjuM54STOw7/Az/F3QtfhfF4Qn9F/gxMouxm/WU7F9afBQuUM7+rtPF+jb0b6ese/I7sI+emadhEzUT5bqbsW+esNbSMWoG6hWo/8gOLPUqUu+v5rKEHX8oS6iEXQexd7XlmBe1aCNWAp6kSsYyjHc82Liv2Xkd/C/HkN1w/Geren+KryToa2PtlQg2c9zijGZnGJ9kaibzZh84jmmfx4TeYpK9H3usMKqxnDCWxsdLY/3ygy9h+l/LYbYHtuXw2/rfsSPo0a/Jrn6PvPrzL2+7CmfV88lkc9j+F7cRzYU4N48DF8uA3n/T7Fly9q4Jdvoth0uLf9LORC11hvO/0D6RnQfRa99+2Hr1NS/M26VvfEe2jaWTAOvG8zzgKf8zCrYL++qUEfbumeQAjTVnQp+QmW99gQpDoJ4+9uHZe5/l3OW/M8x6WUZaduUvUc5p13NTXlz3VpGbCVrGNe5zOnjvGlrDWY1IdWShuuQ9fWh6h+VSV1Wit1lvNhHFz1zeUYtCg5ntvOSStDW5cITRnF5RJ+rcasJHExztwu910tl6LzLYsvuvvzilB0mvSaxt/V+SY0EMurfkjbrTjfInf+FJGkNdzSlOukZaDo3snqs7RZpqj2Gx7sS52D5O79k+93W2W/T3NhQxe3VeF16pwn4eI8qev7Sl1s0PnPy5PalSV57Pp6XuDxrypR9wBR8nOCzm/eXuYp5d4s/lV1XvL+lG2b+2AaQ1nPr23Hrc7z0WT5qvZL0v7QtdX5zdu6HMei+gV1ri8et4XSVpCfdeB7fRWNRy79UP0RCT4Jyre/88bbKsQUawUrV69dxjd+nlXxbCKos79pz1BpOqucz0gEdZ5hMk+aa7Wdy/7xZ5Yqhc+nyHivrkyQ/reM7tziuFojfM7zxtq0505XYutvHrtVnzNl2ONrTGdPkLv9ZjNHOoShnCh5nLLYKOKfK4qK7bjx/gqyj9lFJc2Wz/HIqyMSYaGnqM8+xp6vB1/6feg22UmLFUno1rurvelz7yT1UVfORW3L7+d6fMcAXdzxIVK3TNNioZpSyj2242izpky6y5S0fpr6q5ZXJT7O1qrmQRVB+rkQ1Dk3vvYttyGoc+51/mUVkYLtXvTx7MCvbUnzW2czyR8pql4XUlbcN9l1pSfPfOl0JV2bylyKoM4959sHQfr9Vpbk2V8u4ry0ndcvH5I1xggP9qVem/PHZL+qeGLrc945tLnHtG/LEtdjr4urxMpM92X1RZDd+pLtsorUydeCaiuvbtdSpQ9l2M4SU01nvI1e35L3uS5Jlw8pe1ykCKo2JtrGK9O9ujOlimcD6Y9LEWQ+7019d2VDLVPrTCLrsvjsQ1TfJVJM12pZmm5b4Xptx6HM9SpFkP2c6drJa5/iSr+pD7r+CNLvATVfpST1RYog/fwKTdsyxLVNQfnWrkyziGltJK2hLLptzjHXIsh+/HytmyQfpPA5VNtzXWWLzbiVsc9sbWSJ7UWE69KNh6v9kya2c6TzMa0fwpD37TtvQ6wuiw9CA9cny33Mj2pLte9Kp6996HO/83HPQ5r+ov5mvU9Qte/fIrGJP7axPO/9eXX6kjLPKZNd17iyZdOHLP31JSbfXY6hC59c+ZZ136TZ9SFlj6cvmVkSrkSQn3NG5KBqEVSeH6Ji/vvnhFWjSlfFNDwzyMgqLvvKxXffbeASBWo+Zj4p2x6TfwE=" };
  }
});

// node_modules/graphemesplit/extPict.json
var require_extPict = __commonJS({
  "node_modules/graphemesplit/extPict.json"(exports, module2) {
    module2.exports = { data: "AAACAAAAAACAOAAAAbYBSf7t2S1IBEEYBuDVDZ7FYrQMNsFiu3hgEYOI0SCXRIUrB8JhEZtgs5gEg1GMFk02m82oGI02m+9xezCOczv/uwv3fvAwc/PzfXOzcdqzWdaBDdiGPdiHdjE+DS3RNDuCfsn8idQ/g3OH3BdwKf0e96/gumTfYcncLdzBPTzAo+RZ+f0Cr/AG7/AJX4738x1wtz9FO5PX/50n6UXMNdfg/0lERERERERERERERETpdedHBvDRql4nq0cXtW9af98qdRby0Vvp8K4W0V+C5Xw0t4J2bfjeBp3cnEu1brnnCTYNa7eKdz91XP7WO9Lb4GqRb7cY6xbtAdqeVOsY/QGcevw/tb6OT85YhvfKYEx9CMuxKsKnrs+eJtVInVvHJ0eVYVvTZk2siFVLOCjb61PTZX3MdVWEyP7fjzpmMxdzTyq2Ebue6x61nXRGnzndWpf1an7dXmGYE4Y1ptqqKsK1nu26Ju0ty+maV2Rpvk+qnDZjKUIobUiesdAQE/jmCTmHmsskpFZsVYbtmXRcaoSGUPomunW2derQhDPFjtT1Q/eb8vnm990fq35oHVt11bU9m89c7DNI8Qs=" };
  }
});

// node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "node_modules/tiny-inflate/index.js"(exports, module2) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base2, delta, first) {
      var i2, sum;
      for (i2 = 0; i2 < delta; ++i2)
        bits[i2] = 0;
      for (i2 = 0; i2 < 30 - delta; ++i2)
        bits[i2 + delta] = i2 / delta | 0;
      for (sum = first, i2 = 0; i2 < 30; ++i2) {
        base2[i2] = sum;
        sum += 1 << bits[i2];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i2;
      for (i2 = 0; i2 < 7; ++i2)
        lt.table[i2] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i2 = 0; i2 < 24; ++i2)
        lt.trans[i2] = 256 + i2;
      for (i2 = 0; i2 < 144; ++i2)
        lt.trans[24 + i2] = i2;
      for (i2 = 0; i2 < 8; ++i2)
        lt.trans[24 + 144 + i2] = 280 + i2;
      for (i2 = 0; i2 < 112; ++i2)
        lt.trans[24 + 144 + 8 + i2] = 144 + i2;
      for (i2 = 0; i2 < 5; ++i2)
        dt.table[i2] = 0;
      dt.table[5] = 32;
      for (i2 = 0; i2 < 32; ++i2)
        dt.trans[i2] = i2;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t2, lengths2, off, num) {
      var i2, sum;
      for (i2 = 0; i2 < 16; ++i2)
        t2.table[i2] = 0;
      for (i2 = 0; i2 < num; ++i2)
        t2.table[lengths2[off + i2]]++;
      t2.table[0] = 0;
      for (sum = 0, i2 = 0; i2 < 16; ++i2) {
        offs[i2] = sum;
        sum += t2.table[i2];
      }
      for (i2 = 0; i2 < num; ++i2) {
        if (lengths2[off + i2])
          t2.trans[offs[lengths2[off + i2]]++] = i2;
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base2) {
      if (!num)
        return base2;
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base2;
    }
    function tinf_decode_symbol(d, t2) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t2.table[len];
        cur -= t2.table[len];
      } while (cur >= 0);
      d.tag = tag;
      d.bitcount -= len;
      return t2.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i2, num, length;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i2 = 0; i2 < 19; ++i2)
        lengths[i2] = 0;
      for (i2 = 0; i2 < hclen; ++i2) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i2]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length = tinf_read_bits(d, 2, 3); length; --length) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length = tinf_read_bits(d, 3, 3); length; --length) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length = tinf_read_bits(d, 7, 11); length; --length) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length, dist, offs2;
          var i2;
          sym -= 257;
          length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
          for (i2 = offs2; i2 < offs2 + length; ++i2) {
            d.dest[d.destLen++] = d.dest[i2];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length, invlength;
      var i2;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length = d.source[d.sourceIndex + 1];
      length = 256 * length + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d.sourceIndex += 4;
      for (i2 = length; i2; --i2)
        d.dest[d.destLen++] = d.source[d.sourceIndex++];
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function")
          return d.dest.slice(0, d.destLen);
        else
          return d.dest.subarray(0, d.destLen);
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module2.exports = tinf_uncompress;
  }
});

// node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "node_modules/unicode-trie/swap.js"(exports, module2) {
    var isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap = (b, n, m2) => {
      let i2 = b[n];
      b[n] = b[m2];
      b[m2] = i2;
    };
    var swap32 = (array) => {
      const len = array.length;
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(array, i2, i2 + 3);
        swap(array, i2 + 1, i2 + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian) {
        swap32(array);
      }
    };
    module2.exports = {
      swap32LE
    };
  }
});

// node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "node_modules/unicode-trie/index.js"(exports, module2) {
    var inflate = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data) {
        const isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
        if (isBuffer || data instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer) {
            this.highStart = data.readUInt32LE(0);
            this.errorValue = data.readUInt32LE(4);
            uncompressedLength = data.readUInt32LE(8);
            data = data.slice(12);
          } else {
            const view = new DataView(data.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data = data.subarray(12);
          }
          data = inflate(data, new Uint8Array(uncompressedLength));
          data = inflate(data, new Uint8Array(uncompressedLength));
          swap32LE(data);
          this.data = new Uint32Array(data.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
        }
      }
      get(codePoint) {
        let index;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        if (codePoint <= 65535) {
          index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        if (codePoint < this.highStart) {
          index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module2.exports = UnicodeTrie;
  }
});

// node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "node_modules/js-base64/base64.js"(exports, module2) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : function() {
        var _Base64 = global2.Base64;
        var gBase64 = factory2();
        gBase64.noConflict = function() {
          global2.Base64 = _Base64;
          return gBase64;
        };
        if (global2.Meteor) {
          Base64 = gBase64;
        }
        global2.Base64 = gBase64;
      }();
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports, function() {
      "use strict";
      var version = "3.7.2";
      var VERSION = version;
      var _hasatob = typeof atob === "function";
      var _hasbtoa = typeof btoa === "function";
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a) {
        var tab = {};
        a.forEach(function(c, i2) {
          return tab[c] = i2;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it, fn) {
        if (fn === void 0) {
          fn = function(x2) {
            return x2;
          };
        }
        return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
      };
      var _mkUriSafe = function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      };
      var _tidyB64 = function(s3) {
        return s3.replace(/[^A-Za-z0-9\+\/]/g, "");
      };
      var btoaPolyfill = function(bin) {
        var u32, c0, c1, c2, asc = "";
        var pad = bin.length % 3;
        for (var i2 = 0; i2 < bin.length; ) {
          if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      var _btoa = _hasbtoa ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i2 = 0, l = u8a.length; i2 < l; i2 += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      };
      var cb_utob = function(c) {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = function(u) {
        return u.replace(re_utob, cb_utob);
      };
      var _encode = _hasBuffer ? function(s3) {
        return Buffer.from(s3, "utf8").toString("base64");
      } : _TE ? function(s3) {
        return _fromUint8Array(_TE.encode(s3));
      } : function(s3) {
        return _btoa(utob(s3));
      };
      var encode2 = function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      };
      var encodeURI2 = function(src) {
        return encode2(src, true);
      };
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      var btou = function(b) {
        return b.replace(re_btou, cb_btou);
      };
      var atobPolyfill = function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, bin = "", r1, r2;
        for (var i2 = 0; i2 < asc.length; ) {
          u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
      };
      var _atob = _hasatob ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a) {
        return _U8Afrom(Buffer.from(a, "base64"));
      } : function(a) {
        return _U8Afrom(_atob(a), function(c) {
          return c.charCodeAt(0);
        });
      };
      var toUint8Array = function(a) {
        return _toUint8Array(_unURI(a));
      };
      var _decode = _hasBuffer ? function(a) {
        return Buffer.from(a, "base64").toString("utf8");
      } : _TD ? function(a) {
        return _TD.decode(_toUint8Array(a));
      } : function(a) {
        return btou(_atob(a));
      };
      var _unURI = function(a) {
        return _tidyB64(a.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      };
      var decode = function(src) {
        return _decode(_unURI(src));
      };
      var isValid = function(src) {
        if (typeof src !== "string")
          return false;
        var s3 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s3) || !/[^\s0-9a-zA-Z\-_]/.test(s3);
      };
      var _noEnum = function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      var extendString = function() {
        var _add = function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        };
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode2(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode2(this, true);
        });
        _add("toBase64URL", function() {
          return encode2(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      var extendUint8Array = function() {
        var _add = function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        };
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      var extendBuiltins = function() {
        extendString();
        extendUint8Array();
      };
      var gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode2,
        encode: encode2,
        encodeURI: encodeURI2,
        encodeURL: encodeURI2,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// node_modules/graphemesplit/index.js
var require_graphemesplit = __commonJS({
  "node_modules/graphemesplit/index.js"(exports, module2) {
    var types2 = require_types5();
    var typeTrieData = require_typeTrie().data;
    var extPictData = require_extPict().data;
    var UnicodeTrie = require_unicode_trie();
    var Base642 = require_base64().Base64;
    var typeTrie = new UnicodeTrie(Base642.toUint8Array(typeTrieData));
    var extPict = new UnicodeTrie(Base642.toUint8Array(extPictData));
    function is(type, bit) {
      return (type & bit) !== 0;
    }
    var GB11State = {
      Initial: 0,
      ExtendOrZWJ: 1,
      NotBoundary: 2
    };
    function nextGraphemeClusterSize(ts, start) {
      const L = ts.length;
      let ri = 0;
      let gb11State = GB11State.Initial;
      for (let i2 = start; i2 + 1 < L; i2++) {
        const curr = ts[i2 + 0];
        const next = ts[i2 + 1];
        if (!is(curr, types2.Regional_Indicator)) {
          ri = 0;
        }
        switch (gb11State) {
          case GB11State.NotBoundary:
          case GB11State.Initial:
            if (is(curr, types2.Extended_Pictographic)) {
              gb11State = GB11State.ExtendOrZWJ;
            } else {
              gb11State = GB11State.Initial;
            }
            break;
          case GB11State.ExtendOrZWJ:
            if (is(curr, types2.Extend)) {
              gb11State = GB11State.ExtendOrZWJ;
            } else if (is(curr, types2.ZWJ) && is(next, types2.Extended_Pictographic)) {
              gb11State = GB11State.NotBoundary;
            } else {
              gb11State = GB11State.Initial;
            }
            break;
        }
        if (is(curr, types2.CR) && is(next, types2.LF)) {
          continue;
        }
        if (is(curr, types2.Control | types2.CR | types2.LF)) {
          return i2 + 1 - start;
        }
        if (is(next, types2.Control | types2.CR | types2.LF)) {
          return i2 + 1 - start;
        }
        if (is(curr, types2.L) && is(next, types2.L | types2.V | types2.LV | types2.LVT)) {
          continue;
        }
        if (is(curr, types2.LV | types2.V) && is(next, types2.V | types2.T)) {
          continue;
        }
        if (is(curr, types2.LVT | types2.T) && is(next, types2.T)) {
          continue;
        }
        if (is(next, types2.Extend | types2.ZWJ)) {
          continue;
        }
        if (is(next, types2.SpacingMark)) {
          continue;
        }
        if (is(curr, types2.Prepend)) {
          continue;
        }
        if (gb11State === GB11State.NotBoundary) {
          continue;
        }
        if (is(curr, types2.Regional_Indicator) && is(next, types2.Regional_Indicator) && ri % 2 === 0) {
          ri++;
          continue;
        }
        return i2 + 1 - start;
      }
      return L - start;
    }
    module2.exports = function split2(str) {
      const graphemeClusters = [];
      const map = [0];
      const ts = [];
      for (let i2 = 0; i2 < str.length; ) {
        const code = str.codePointAt(i2);
        ts.push(typeTrie.get(code) | extPict.get(code));
        i2 += code > 65535 ? 2 : 1;
        map.push(i2);
      }
      for (let offset = 0; offset < ts.length; ) {
        const size = nextGraphemeClusterSize(ts, offset);
        const start = map[offset];
        const end = map[offset + size];
        graphemeClusters.push(str.slice(start, end));
        offset += size;
      }
      return graphemeClusters;
    };
  }
});

// node_modules/fast-fuzzy/lib/fuzzy.mjs
var import_graphemesplit, sortKind, defaultOptions;
var init_fuzzy = __esm({
  "node_modules/fast-fuzzy/lib/fuzzy.mjs"() {
    import_graphemesplit = __toESM(require_graphemesplit(), 1);
    sortKind = {
      insertOrder: "insertOrder",
      bestMatch: "bestMatch"
    };
    defaultOptions = {
      keySelector: (s3) => s3,
      threshold: 0.6,
      ignoreCase: true,
      ignoreSymbols: true,
      normalizeWhitespace: true,
      returnMatchData: false,
      useDamerau: true,
      useSellers: true,
      sortBy: sortKind.bestMatch
    };
  }
});

// .svelte-kit/output/server/chunks/SavedQueriesList-587d9dd6.js
var css4, SavedQueriesList;
var init_SavedQueriesList_587d9dd6 = __esm({
  ".svelte-kit/output/server/chunks/SavedQueriesList-587d9dd6.js"() {
    init_index_d153bcdc();
    init_SavedQuery_7048865a();
    init_supabaseClient_772c11ee();
    init_fuzzy();
    css4 = {
      code: ".queries.svelte-1tp8ad4::-webkit-scrollbar{width:15px}.queries.svelte-1tp8ad4::-webkit-scrollbar-track{background-color:#374151;border-radius:100px}.queries.svelte-1tp8ad4::-webkit-scrollbar-thumb{border-radius:80px;border:5px solid transparent;background-clip:content-box;background-color:#8070d4}",
      map: null
    };
    SavedQueriesList = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $savedQueriesStore, $$unsubscribe_savedQueriesStore;
      $$unsubscribe_savedQueriesStore = subscribe(savedQueriesStore, (value) => $savedQueriesStore = value);
      let savedQueries = [];
      let filteredQueries = [];
      let searchTerm = "";
      const handleShare = (id) => {
        const queryToShare = savedQueries.find((query) => query.id === id);
        queryToShareStore.set(queryToShare);
      };
      $$result.css.add(css4);
      savedQueries = $savedQueriesStore.sort((a, b) => Number(new Date(b.created_at)) - Number(new Date(a.created_at)));
      {
        {
          {
            filteredQueries = [...savedQueries];
          }
        }
      }
      $$unsubscribe_savedQueriesStore();
      return `<div class="${"queries px-4 overflow-y-scroll relative bg-gray-700 hidden md:block svelte-1tp8ad4"}"><div class="${"flex flex-col pt-2 pb-4 bg-gray-700 sticky top-0 z-20"}"><h3 class="${"text-xl mb-4 text-gray-300 whitespace-nowrap"}">Saved Queries</h3>
		<input class="${"input input-sm input-bordered w-full bg-gray-600"}" placeholder="${"Search"}"${add_attribute("value", searchTerm, 0)}></div>
	<ul class="${"flex flex-col gap-4 list-none pb-4 mb-4 z-10"}">${filteredQueries.length ? each(filteredQueries, (query) => {
        return `<li class="${"card glass hover:bg-violet-800 bg-violet-900 shadow-md py-2 px-4 relative"}">${validate_component(SavedQuery, "SavedQuery").$$render($$result, { query, handleShare }, {}, {})}
			</li>`;
      }) : `<span>No saved queries</span>`}</ul>
</div>`;
    });
  }
});

// .svelte-kit/output/server/entries/pages/index.svelte.js
var index_svelte_exports = {};
__export(index_svelte_exports, {
  default: () => Routes
});
async function updateSavedQueries(options) {
  const query = (options == null ? void 0 : options.query) || get_store_value(queryStore);
  if (!get_store_value(authStore).isLoggedIn) {
    return;
  }
  const { data: currentSavedQueries } = await supabase.from(TableNames.savedQueries).select(`
		search_term, filters, provider, name, user_id
	`);
  const newSavedQueries = [...currentSavedQueries || []];
  const queryWithoutIdAndDate = __objRest(query, []);
  let exists = false;
  if (currentSavedQueries == null ? void 0 : currentSavedQueries.length) {
    const _a4 = currentSavedQueries[currentSavedQueries.length - 1], { id, createdAt } = _a4, currentQueryWithoutIdAndDate = __objRest(_a4, ["id", "createdAt"]);
    if (JSON.stringify(queryWithoutIdAndDate) === JSON.stringify(__spreadValues({}, currentQueryWithoutIdAndDate))) {
      exists = true;
    }
  }
  if (!exists)
    saveNewQuery(newSavedQueries, query);
}
var import_case, import_splitio3, TableNames, filtersThatDontRequireSearchTerm, queryParamFilters, postFixFilters, getPostfix, formatQuery, saveNewQuery, generateQueryUrl, css$32, Announcement, ValueSelector, css$22, Base, Exact$1, Exclude$1, searchAreas, contentOptions, fileTypes, googleCountries, googleDomains, googlePageLanguages, publishLanguages, pastOptions, rightsOptions, FileType$1, Related$1, Safe$1, Site$1, Synonyms, ExcludeSite, NumRange, Bing, DuckDuckGo, Area, Content, Country, Exact, Exclude, FileType, Link, Locale, Past, Personal, PublishLanguage, Related, Rights, Safe, Site, Google, Yahoo, Filters, css$12, QueryURLPreview, SearchBarBase, SearchBarWithoutQueryAutosave, SearchBarWithQueryAutosave, ComponentSelector, SearchBar, SearchProvider, css5, Routes;
var init_index_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/index.svelte.js"() {
    init_index_d153bcdc();
    init_supabaseClient_772c11ee();
    import_case = __toESM(require_Case(), 1);
    init_SavedQuery_7048865a();
    init_SavedQueriesList_587d9dd6();
    init_SearchProviderSelect_577da9fc();
    import_splitio3 = __toESM(require_lib4(), 1);
    init_fuzzy();
    TableNames = /* @__PURE__ */ ((TableNames2) => {
      TableNames2["settings"] = "settings";
      TableNames2["savedQueries"] = "saved_queries";
      TableNames2["searchProviders"] = "search_providers";
      TableNames2["profile"] = "profile";
      return TableNames2;
    })(TableNames || {});
    filtersThatDontRequireSearchTerm = [
      "Exact",
      "Link",
      "Related",
      "Synonyms",
      "Text",
      "Title",
      "URL"
    ];
    queryParamFilters = [
      "adWords",
      "area",
      "contentType",
      "country",
      "dateAfter",
      "dateBefore",
      "exact",
      "exclude",
      "fileType",
      "link",
      "locale",
      "past",
      "personal",
      "publishLanguage",
      "related",
      "rights",
      "safe",
      "site",
      "sortBy"
    ];
    postFixFilters = ["excludeSite", "numRange"];
    getPostfix = (query) => Object.entries(query.filters).filter((filter) => postFixFilters.includes(filter[0])).map((filter) => filter[1].formatted.trim()).join("+");
    formatQuery = (options) => {
      const query = options.query || get_store_value(queryStore);
      const {
        provider: { name: searchProviderName }
      } = query;
      if (searchProviderName === "Google") {
        const prefix = Object.entries(query.filters).filter((filter) => !queryParamFilters.includes(filter[0]) && !postFixFilters.includes(filter[0])).reduce((prev, curr) => `${prev}${curr[1].formatted}`, "");
        const queryParams = Object.entries(query.filters).filter((filter) => queryParamFilters.includes(filter[0]) && !postFixFilters.includes(filter[0])).map((filter) => filter[1].formatted.trim()).join("&");
        const postfix = getPostfix(query);
        const formattedQuery = `${prefix}${query.search_term}${postfix.trim() && `+${postfix} `}${queryParams.trim() ? `&${queryParams}` : ""}`;
        return formattedQuery;
      } else if (searchProviderName === "Bing") {
        const prefix = Object.entries(query.filters).filter((filter) => !["save"].includes(filter[0]) && !postFixFilters.includes(filter[0])).reduce((prev, curr) => `${prev}${curr[1].formatted}`, "");
        const queryParams = Object.entries(query.filters).filter((filter) => ["save"].includes(filter[0]) && !postFixFilters.includes(filter[0])).map((filter) => filter[1].formatted.trim()).join("&");
        const postfix = getPostfix(query);
        const formattedQuery = `${prefix}${query.search_term}${postfix.trim() && `+${postfix} `}${queryParams.trim() ? `&${queryParams}` : ""}`;
        return formattedQuery;
      } else {
        const prefix = Object.entries(query.filters).filter((filter) => !postFixFilters.includes(filter[0])).reduce((prev, curr) => `${prev}${curr[1].formatted}`, "");
        const postfix = getPostfix(query);
        const formattedQuery = `${prefix}${query.search_term}${postfix.trim() && `+${postfix}`} `;
        return formattedQuery;
      }
    };
    saveNewQuery = async (currentSavedQueries, query) => {
      const user = supabase.auth.user();
      const newQuery = __spreadProps(__spreadValues({}, query), {
        name: query.name || `Untitled Query - ${new Date().toUTCString()}`,
        user_id: user == null ? void 0 : user.id
      });
      const { data } = await supabase.from(TableNames.savedQueries).insert([
        __spreadProps(__spreadValues({}, newQuery), { filters: JSON.stringify(query.filters), provider: query.provider.name })
      ]).select("filters, created_at, id, name, provider(id, name, url), search_term");
      savedQueriesStore.set([
        ...currentSavedQueries,
        ...(data == null ? void 0 : data.map((d) => __spreadProps(__spreadValues({}, d), { filters: JSON.parse(d.filters) }))) || []
      ]);
    };
    generateQueryUrl = (options = { saveQuery: false, skipSearchTermCheck: false }) => {
      const query = options.query || get_store_value(queryStore);
      if (!options.skipSearchTermCheck && !query.search_term && !filtersThatDontRequireSearchTerm.includes(options.type)) {
        return "";
      }
      if (options.saveQuery)
        updateSavedQueries();
      const formattedQuery = formatQuery({ query });
      if (typeof query.provider.url === "string") {
        return `${query.provider.url}${encodeURIComponent(formattedQuery).replace(/%2B/g, "+")}`;
      } else {
        const url = [];
        for (const providerUrl of query.provider.url) {
          url.push(`${providerUrl}${encodeURIComponent(formattedQuery).replace(/%2B/g, "+")}`);
        }
        return url;
      }
    };
    css$32 = {
      code: ".query-url.svelte-8jsznr::-webkit-scrollbar{width:5px}.query-url.svelte-8jsznr::-webkit-scrollbar-track{background-color:#374151;border-radius:100px;width:10px}.query-url.svelte-8jsznr::-webkit-scrollbar-thumb{border-radius:80px;border:5px solid transparent;background-clip:content-box;background-color:#8070d4}",
      map: null
    };
    Announcement = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css$32);
      return `<div class="${[
        "query-url text-sm my-4 py-2 px-4 bg-purple-600 bg-opacity-40 rounded-lg overflow-x-auto relative flex justify-between w-full svelte-8jsznr",
        ""
      ].join(" ").trim()}"><span>${slots.default ? slots.default({}) : ``}</span>
	<button class="${"btn btn-xs btn-ghost btn-circle"}">\u2715</button>
</div>`;
    });
    ValueSelector = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $featureFlagsStore, $$unsubscribe_featureFlagsStore;
      $$unsubscribe_featureFlagsStore = subscribe(featureFlagsStore, (value2) => $featureFlagsStore = value2);
      let { featureFlag = null } = $$props;
      let { onValue } = $$props;
      let { offValue } = $$props;
      let { condition = null } = $$props;
      let value = offValue;
      let unsubscribe;
      onDestroy(() => unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe());
      if ($$props.featureFlag === void 0 && $$bindings.featureFlag && featureFlag !== void 0)
        $$bindings.featureFlag(featureFlag);
      if ($$props.onValue === void 0 && $$bindings.onValue && onValue !== void 0)
        $$bindings.onValue(onValue);
      if ($$props.offValue === void 0 && $$bindings.offValue && offValue !== void 0)
        $$bindings.offValue(offValue);
      if ($$props.condition === void 0 && $$bindings.condition && condition !== void 0)
        $$bindings.condition(condition);
      {
        {
          if (featureFlag !== null && condition !== null) {
            value = $featureFlagsStore[featureFlag] === "on" && condition ? onValue : offValue;
          } else if (featureFlag !== null && condition === null) {
            value = $featureFlagsStore[featureFlag] === "on" ? onValue : offValue;
          } else if (featureFlag === null && condition !== null) {
            value = condition ? onValue : offValue;
          }
        }
      }
      {
        {
          unsubscribe = featureFlagsStore.subscribe((newValue) => {
            value = newValue[featureFlag] === "on" && condition ? onValue : offValue;
          });
        }
      }
      $$unsubscribe_featureFlagsStore();
      return `${slots.default ? slots.default({ feature: value }) : ``}`;
    });
    css$22 = {
      code: ".container.svelte-13ureke{display:grid;gap:1rem;margin:0.5rem 0}.input-label.svelte-13ureke{display:flex;align-items:center;gap:0.5rem}",
      map: null
    };
    Base = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      var _a4, _b;
      let $queryStore, $$unsubscribe_queryStore;
      $$unsubscribe_queryStore = subscribe(queryStore, (value) => $queryStore = value);
      let { type } = $$props;
      let { enabled = false } = $$props;
      let { label = "" } = $$props;
      let { textInputPlaceholder = "" } = $$props;
      let { options = null } = $$props;
      let { handleSelectChange = null } = $$props;
      let { handleCheckboxChange = null } = $$props;
      let { hasInput = false } = $$props;
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      if ($$props.enabled === void 0 && $$bindings.enabled && enabled !== void 0)
        $$bindings.enabled(enabled);
      if ($$props.label === void 0 && $$bindings.label && label !== void 0)
        $$bindings.label(label);
      if ($$props.textInputPlaceholder === void 0 && $$bindings.textInputPlaceholder && textInputPlaceholder !== void 0)
        $$bindings.textInputPlaceholder(textInputPlaceholder);
      if ($$props.options === void 0 && $$bindings.options && options !== void 0)
        $$bindings.options(options);
      if ($$props.handleSelectChange === void 0 && $$bindings.handleSelectChange && handleSelectChange !== void 0)
        $$bindings.handleSelectChange(handleSelectChange);
      if ($$props.handleCheckboxChange === void 0 && $$bindings.handleCheckboxChange && handleCheckboxChange !== void 0)
        $$bindings.handleCheckboxChange(handleCheckboxChange);
      if ($$props.hasInput === void 0 && $$bindings.hasInput && hasInput !== void 0)
        $$bindings.hasInput(hasInput);
      $$result.css.add(css$22);
      $$unsubscribe_queryStore();
      return `<div class="${"container svelte-13ureke"}"><label class="${"input-label text-gray-300 svelte-13ureke"}"><input type="${"checkbox"}" class="${"toggle toggle-primary"}"${add_attribute("name", `${type}-checkbox`, 0)}${add_attribute("id", `${type}-checkbox`, 0)} ${Boolean($queryStore.filters[import_case.default.camel(type)]) ? "checked" : ""}>
		${escape(label || type)}</label>

	${(enabled || Boolean($queryStore.filters[import_case.default.camel(type)])) && options ? `<select class="${"select select-bordered"}" type="${"text"}"${add_attribute("name", `${type}-input`, 0)}${add_attribute("id", `${type}-input`, 0)}${add_attribute("value", ((_a4 = $queryStore.filters[import_case.default.camel(type)]) == null ? void 0 : _a4.value) || options[0].value, 0)}>${each(options, (option) => {
        return `<option class="${"rounded-md text-lg p-4 border-2 dark:bg-gray-600 border-gray-400 dark:border-gray-400"}"${add_attribute("value", option.value, 0)}>${escape(option.label)}</option>`;
      })}</select>` : ``}

	${(enabled || Boolean($queryStore.filters[import_case.default.camel(type)])) && hasInput ? `<input class="${"input input-bordered"}" type="${"text"}"${add_attribute("name", `${type}-input`, 0)} id="${""}"${add_attribute("placeholder", textInputPlaceholder || type, 0)}${add_attribute("value", ((_b = $queryStore.filters[import_case.default.camel(type)]) == null ? void 0 : _b.value) || "", 0)}>` : ``}
</div>`;
    });
    Exact$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Exact",
        hasInput: true,
        label: "... that have this exact word or phrase",
        textInputPlaceholder: "Word/Phrase (example: we live in a society)"
      }, {}, {})}`;
    });
    Exclude$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Exclude",
        hasInput: true,
        label: "... without any of these words",
        textInputPlaceholder: "Words to exclude (example: detect plagiarism)"
      }, {}, {})}`;
    });
    searchAreas = [
      { label: "... page title", value: "title" },
      { label: "... page body", value: "body" },
      { label: "... page URL", value: "url" },
      { label: "... page links", value: "links" }
    ];
    contentOptions = [
      { value: "bks", label: "search for books" },
      { value: "isch", label: "search by image" },
      { value: "nws", label: "news search" },
      { value: "pts", label: "Google patents" },
      { value: "shop", label: "search by shops" },
      { value: "vid", label: "video search" }
    ];
    fileTypes = [
      { label: "Adobe Acrobat PDF (.pdf)", value: "pdf" },
      { label: "Adobe Postscript (.ps)", value: "ps" },
      { label: "Autodesk DWF (.dwf)", value: "dwf" },
      { label: "Google Earth KML (.kml)", value: "kml" },
      { label: "Google Earth KMZ (.kmz)", value: "kmz" },
      { label: "Microsoft Excel (.xls)", value: "xls" },
      { label: "Microsoft PowerPoint (.ppt)", value: "ppt" },
      { label: "Microsoft Word (.doc)", value: "doc" },
      { label: "Rich Text Format (.rtf)", value: "rtf" },
      { label: "Shockwave Flash (.swf)", value: "swf" }
    ];
    googleCountries = [
      { value: "af", label: "Afghanistan" },
      { value: "al", label: "Albania" },
      { value: "dz", label: "Algeria" },
      { value: "as", label: "American Samoa" },
      { value: "ad", label: "Andorra" },
      { value: "ao", label: "Angola" },
      { value: "ai", label: "Anguilla" },
      { value: "aq", label: "Antarctica" },
      { value: "ag", label: "Antigua and Barbuda" },
      { value: "ar", label: "Argentina" },
      { value: "am", label: "Armenia" },
      { value: "aw", label: "Aruba" },
      { value: "ac", label: "Ascension Island" },
      { value: "au", label: "Australia" },
      { value: "at", label: "Austria" },
      { value: "az", label: "Azerbaijan" },
      { value: "bs", label: "Bahamas" },
      { value: "bh", label: "Bahrain" },
      { value: "bd", label: "Bangladesh" },
      { value: "bb", label: "Barbados" },
      { value: "by", label: "Belarus" },
      { value: "be", label: "Belgium" },
      { value: "bz", label: "Belize" },
      { value: "bj", label: "Benin" },
      { value: "bm", label: "Bermuda" },
      { value: "bt", label: "Bhutan" },
      { value: "bo", label: "Bolivia" },
      { value: "bq", label: "Bonaire" },
      { value: "ba", label: "Bosnia and Herzegovina" },
      { value: "bw", label: "Botswana" },
      { value: "bv", label: "Bouvet Island" },
      { value: "br", label: "Brazil" },
      { value: "bn", label: "Brunei Darussalam" },
      { value: "bg", label: "Bulgaria" },
      { value: "bf", label: "Burkina Faso" },
      { value: "bi", label: "Burundi" },
      { value: "kh", label: "Cambodia" },
      { value: "cm", label: "Cameroon" },
      { value: "ca", label: "Canada" },
      { value: "cv", label: "Cape Verde" },
      { value: "cat", label: "Catalonia" },
      { value: "ky", label: "Cayman Islands" },
      { value: "cf", label: "Central African Republic" },
      { value: "td", label: "Chad" },
      { value: "cl", label: "Chile" },
      { value: "cn", label: "China" },
      { value: "cx", label: "Christmas Island" },
      { value: "cc", label: "Cocos (Keeling) Islands" },
      { value: "co", label: "Colombia" },
      { value: "km", label: "Comoros" },
      { value: "cg", label: "Congo" },
      { value: "ck", label: "Cook Islands" },
      { value: "cr", label: "Costa Rica" },
      { value: "ci", label: "Cote D'ivoire" },
      { value: "hr", label: "Croatia" },
      { value: "cu", label: "Cuba" },
      { value: "cw", label: "Cura\xE7ao" },
      { value: "cy", label: "Cyprus" },
      { value: "cz", label: "Czech Republic" },
      { value: "cd", label: "Democratic Rep Congo" },
      { value: "dk", label: "Denmark" },
      { value: "dj", label: "Djibouti" },
      { value: "dm", label: "Dominica" },
      { value: "do", label: "Dominican Republic" },
      { value: "ec", label: "Ecuador" },
      { value: "eg", label: "Egypt" },
      { value: "sv", label: "El Salvador" },
      { value: "gq", label: "Equatorial Guinea" },
      { value: "er", label: "Eritrea" },
      { value: "ee", label: "Estonia" },
      { value: "et", label: "Ethiopia" },
      { value: "fk", label: "Falkland Islands (Malvinas)" },
      { value: "fo", label: "Faroe Islands" },
      { value: "fj", label: "Fiji" },
      { value: "fi", label: "Finland" },
      { value: "fr", label: "France" },
      { value: "gf", label: "French Guiana" },
      { value: "pf", label: "French Polynesia" },
      { value: "tf", label: "French Southern Territories" },
      { value: "ga", label: "Gabon" },
      { value: "gm", label: "Gambia" },
      { value: "ge", label: "Georgia" },
      { value: "de", label: "Germany" },
      { value: "gh", label: "Ghana" },
      { value: "gi", label: "Gibraltar" },
      { value: "gr", label: "Greece" },
      { value: "gl", label: "Greenland" },
      { value: "gd", label: "Grenada" },
      { value: "gp", label: "Guadeloupe" },
      { value: "gu", label: "Guam" },
      { value: "gt", label: "Guatemala" },
      { value: "gg", label: "Guernsey" },
      { value: "gn", label: "Guinea" },
      { value: "gw", label: "Guinea-Bissau" },
      { value: "gy", label: "Guyana" },
      { value: "ht", label: "Haiti" },
      { value: "hm", label: "Heard Island and Mcdonald Islands" },
      { value: "va", label: "Holy See (Vatican City State)" },
      { value: "hn", label: "Honduras" },
      { value: "hk", label: "Hong Kong" },
      { value: "hu", label: "Hungary" },
      { value: "is", label: "Iceland" },
      { value: "in", label: "India" },
      { value: "io", label: "Indian Ocean Territory" },
      { value: "id", label: "Indonesia" },
      { value: "ir", label: "Iran, Islamic Republic of" },
      { value: "iq", label: "Iraq" },
      { value: "ie", label: "Ireland" },
      { value: "im", label: "Isle of Man" },
      { value: "il", label: "Israel" },
      { value: "it", label: "Italy" },
      { value: "jm", label: "Jamaica" },
      { value: "jp", label: "Japan" },
      { value: "je", label: "Jersey" },
      { value: "jo", label: "Jordan" },
      { value: "kz", label: "Kazakhstan" },
      { value: "ke", label: "Kenya" },
      { value: "ki", label: "Kiribati" },
      { value: "kr", label: "Korea" },
      { value: "xk", label: "Kosovo" },
      { value: "kw", label: "Kuwait" },
      { value: "kg", label: "Kyrgyzstan" },
      { value: "la", label: "Lao" },
      { value: "lv", label: "Latvia" },
      { value: "lb", label: "Lebanon" },
      { value: "ls", label: "Lesotho" },
      { value: "lr", label: "Liberia" },
      { value: "ly", label: "Libyan Arab Jamahiriya" },
      { value: "li", label: "Liechtenstein" },
      { value: "lt", label: "Lithuania" },
      { value: "lu", label: "Luxembourg" },
      { value: "mo", label: "Macao" },
      { value: "mk", label: "Macedonia, the Former Yugosalv Republic of" },
      { value: "mg", label: "Madagascar" },
      { value: "mw", label: "Malawi" },
      { value: "my", label: "Malaysia" },
      { value: "mv", label: "Maldives" },
      { value: "ml", label: "Mali" },
      { value: "mt", label: "Malta" },
      { value: "mh", label: "Marshall Islands" },
      { value: "mq", label: "Martinique" },
      { value: "mr", label: "Mauritania" },
      { value: "mu", label: "Mauritius" },
      { value: "yt", label: "Mayotte" },
      { value: "mx", label: "Mexico" },
      { value: "fm", label: "Micronesia, Federated States of" },
      { value: "md", label: "Moldova, Republic of" },
      { value: "mc", label: "Monaco" },
      { value: "mn", label: "Mongolia" },
      { value: "ms", label: "Montserrat" },
      { value: "ma", label: "Morocco" },
      { value: "mz", label: "Mozambique" },
      { value: "mm", label: "Myanmar" },
      { value: "na", label: "Namibia" },
      { value: "nr", label: "Nauru" },
      { value: "np", label: "Nepal" },
      { value: "nl", label: "Netherlands" },
      { value: "an", label: "Netherlands Antilles" },
      { value: "nc", label: "New Caledonia" },
      { value: "nz", label: "New Zealand" },
      { value: "ni", label: "Nicaragua" },
      { value: "ne", label: "Niger" },
      { value: "ng", label: "Nigeria" },
      { value: "nu", label: "Niue" },
      { value: "nf", label: "Norfolk Island" },
      { value: "mp", label: "Northern Mariana Islands" },
      { value: "no", label: "Norway" },
      { value: "om", label: "Oman" },
      { value: "pk", label: "Pakistan" },
      { value: "pw", label: "Palau" },
      { value: "ps", label: "Palestinian Territory, Occupied" },
      { value: "pa", label: "Panama" },
      { value: "pg", label: "Papua New Guinea" },
      { value: "py", label: "Paraguay" },
      { value: "pe", label: "Peru" },
      { value: "ph", label: "Philippines" },
      { value: "pn", label: "Pitcairn" },
      { value: "pl", label: "Poland" },
      { value: "pt", label: "Portugal" },
      { value: "pr", label: "Puerto Rico" },
      { value: "qa", label: "Qatar" },
      { value: "re", label: "Reunion" },
      { value: "ro", label: "Romania" },
      { value: "ru", label: "Russian Federation" },
      { value: "rw", label: "Rwanda" },
      { value: "sh", label: "Saint Helena" },
      { value: "kn", label: "Saint Kitts and Nevis" },
      { value: "lc", label: "Saint Lucia" },
      { value: "mf", label: "Saint Martin" },
      { value: "pm", label: "Saint Pierre and Miquelon" },
      { value: "vc", label: "Saint Vincent" },
      { value: "ws", label: "Samoa" },
      { value: "sm", label: "San Marino" },
      { value: "st", label: "Sao Tome and Principe" },
      { value: "sa", label: "Saudi Arabia" },
      { value: "sn", label: "Senegal" },
      { value: "rs", label: "Serbia and Montenegro" },
      { value: "sc", label: "Seychelles" },
      { value: "sl", label: "Sierra Leone" },
      { value: "sg", label: "Singapore" },
      { value: "sx", label: "Sint Maarten" },
      { value: "sk", label: "Slovakia" },
      { value: "si", label: "Slovenia" },
      { value: "sb", label: "Solomon Islands" },
      { value: "so", label: "Somalia" },
      { value: "za", label: "South Africa" },
      { value: "gs", label: "South Georgia and the South Sandwich Islands" },
      { value: "es", label: "Spain" },
      { value: "lk", label: "Sri Lanka" },
      { value: "sd", label: "Sudan" },
      { value: "sr", label: "Suriname" },
      { value: "sj", label: "Svalbard and Jan Mayen" },
      { value: "sz", label: "Swaziland" },
      { value: "se", label: "Sweden" },
      { value: "ch", label: "Switzerland" },
      { value: "sy", label: "Syrian Arab Republic" },
      { value: "tw", label: "Taiwan, Province of China" },
      { value: "tj", label: "Tajikistan" },
      { value: "tz", label: "Tanzania, United Republic of" },
      { value: "th", label: "Thailand" },
      { value: "tl", label: "Timor-Leste" },
      { value: "tg", label: "Togo" },
      { value: "tk", label: "Tokelau" },
      { value: "to", label: "Tonga" },
      { value: "tt", label: "Trinidad and Tobago" },
      { value: "tn", label: "Tunisia" },
      { value: "tr", label: "Turkey" },
      { value: "tm", label: "Turkmenistan" },
      { value: "tc", label: "Turks and Caicos Islands" },
      { value: "tv", label: "Tuvalu" },
      { value: "ug", label: "Uganda" },
      { value: "ua", label: "Ukraine" },
      { value: "ae", label: "United Arab Emirates" },
      { value: "uk", label: "United Kingdom" },
      { value: "gb", label: "United Kingdom" },
      { value: "us", label: "United States" },
      { value: "um", label: "United States Minor Outlying Islands" },
      { value: "uy", label: "Uruguay" },
      { value: "uz", label: "Uzbekistan" },
      { value: "vu", label: "Vanuatu" },
      { value: "ve", label: "Venezuela" },
      { value: "vn", label: "Viet Nam" },
      { value: "vg", label: "Virgin Islands, British" },
      { value: "vi", label: "Virgin Islands, U.S." },
      { value: "wf", label: "Wallis and Futuna" },
      { value: "eh", label: "Western Sahara" },
      { value: "ye", label: "Yemen" },
      { value: "zm", label: "Zambia" },
      { value: "zw", label: "Zimbabwe" }
    ];
    googleDomains = [
      { domain: "google.com.af", countryCode: "af", languageCode: "ps", name: "Afghanistan" },
      { domain: "google.al", countryCode: "al", languageCode: "sq", name: "Albania" },
      { domain: "google.dz", countryCode: "dz", languageCode: "ar", name: "Algeria" },
      { domain: "google.as", countryCode: "as", languageCode: "en", name: "American Samoa" },
      { domain: "google.ad", countryCode: "ad", languageCode: "ca", name: "Andorra" },
      { domain: "google.co.ao", countryCode: "ao", languageCode: "pt", name: "Angola" },
      { domain: "google.com.ai", countryCode: "ai", languageCode: "en", name: "Anguilla" },
      { domain: "google.com.ag", countryCode: "ag", languageCode: "en", name: "Antigua and Barbuda" },
      { domain: "google.com.ar", countryCode: "ar", languageCode: "es", name: "Argentina" },
      { domain: "google.am", countryCode: "am", languageCode: "hy", name: "Armenia" },
      { domain: "google.ac", countryCode: "ac", languageCode: "en", name: "Ascension Island" },
      { domain: "google.com.au", countryCode: "au", languageCode: "en", name: "Australia" },
      { domain: "google.at", countryCode: "at", languageCode: "de", name: "Austria" },
      { domain: "google.az", countryCode: "az", languageCode: "az", name: "Azerbaijan" },
      { domain: "google.bs", countryCode: "bs", languageCode: "en", name: "Bahamas" },
      { domain: "google.com.bh", countryCode: "bh", languageCode: "ar", name: "Bahrain" },
      { domain: "google.com.bd", countryCode: "bd", languageCode: "bn", name: "Bangladesh" },
      { domain: "google.by", countryCode: "by", languageCode: "be", name: "Belarus" },
      { domain: "google.be", countryCode: "be", languageCode: "nl", name: "Belgium" },
      { domain: "google.com.bz", countryCode: "bz", languageCode: "en", name: "Belize" },
      { domain: "google.bj", countryCode: "bj", languageCode: "fr", name: "Benin" },
      { domain: "google.bt", countryCode: "bt", languageCode: "dz", name: "Bhutan" },
      { domain: "google.com.bo", countryCode: "bo", languageCode: "es", name: "Bolivia" },
      { domain: "google.ba", countryCode: "ba", languageCode: "bs", name: "Bosnia and Herzegovina" },
      { domain: "google.co.bw", countryCode: "bw", languageCode: "en", name: "Botswana" },
      { domain: "google.com.br", countryCode: "br", languageCode: "pt", name: "Brazil" },
      { domain: "google.vg", countryCode: "vg", languageCode: "en", name: "British Virgin Islands" },
      { domain: "google.com.bn", countryCode: "bn", languageCode: "ms", name: "Brunei" },
      { domain: "google.bg", countryCode: "bg", languageCode: "bg", name: "Bulgaria" },
      { domain: "google.bf", countryCode: "bf", languageCode: "fr", name: "Burkina Faso" },
      { domain: "google.bi", countryCode: "bi", languageCode: "fr", name: "Burundi" },
      { domain: "google.com.kh", countryCode: "kh", languageCode: "km", name: "Cambodia" },
      { domain: "google.cm", countryCode: "cm", languageCode: "en", name: "Cameroon" },
      { domain: "google.ca", countryCode: "ca", languageCode: "en", name: "Canada" },
      { domain: "google.cv", countryCode: "cv", languageCode: "pt", name: "Cape Verde" },
      { domain: "google.cat", countryCode: "cat", languageCode: "es", name: "Catalonia" },
      { domain: "google.cf", countryCode: "cf", languageCode: "fr", name: "Central African Republic" },
      { domain: "google.td", countryCode: "td", languageCode: "ar", name: "Chad" },
      { domain: "google.cl", countryCode: "cl", languageCode: "es", name: "Chile" },
      { domain: "google.cn", countryCode: "cn", languageCode: "zh", name: "China" },
      { domain: "google.cx", countryCode: "cx", languageCode: "en", name: "Christmas Island" },
      { domain: "google.cc", countryCode: "cc", languageCode: "en", name: "Cocos (Keeling) Islands" },
      { domain: "google.com.co", countryCode: "co", languageCode: "es", name: "Colombia" },
      { domain: "google.co.ck", countryCode: "ck", languageCode: "en", name: "Cook Islands" },
      { domain: "google.co.cr", countryCode: "cr", languageCode: "es", name: "Costa Rica" },
      { domain: "google.hr", countryCode: "hr", languageCode: "hr", name: "Croatia" },
      { domain: "google.com.cu", countryCode: "cu", languageCode: "es", name: "Cuba" },
      { domain: "google.com.cy", countryCode: "cy", languageCode: "el", name: "Cyprus" },
      { domain: "google.cz", countryCode: "cz", languageCode: "cs", name: "Czech Republic" },
      { domain: "google.cd", countryCode: "cg", languageCode: "fr", name: "Democratic Rep of Congo" },
      { domain: "google.dk", countryCode: "dk", languageCode: "da", name: "Denmark" },
      { domain: "google.dj", countryCode: "dj", languageCode: "ar", name: "Djibouti" },
      { domain: "google.dm", countryCode: "dm", languageCode: "en", name: "Dominica" },
      { domain: "google.com.do", countryCode: "do", languageCode: "es", name: "Dominican Republic" },
      { domain: "google.com.ec", countryCode: "ec", languageCode: "es", name: "Ecuador" },
      { domain: "google.com.eg", countryCode: "eg", languageCode: "ar", name: "Egypt" },
      { domain: "google.com.sv", countryCode: "sv", languageCode: "es", name: "El Salvador" },
      { domain: "google.ee", countryCode: "ee", languageCode: "et", name: "Estonia" },
      { domain: "google.com.et", countryCode: "et", languageCode: "am", name: "Ethiopia" },
      { domain: "google.com.fj", countryCode: "fj", languageCode: "en", name: "Fiji" },
      { domain: "google.fi", countryCode: "fi", languageCode: "fi", name: "Finland" },
      { domain: "google.fr", countryCode: "fr", languageCode: "fr", name: "France" },
      { domain: "google.gf", countryCode: "gf", languageCode: "fr", name: "French Guiana" },
      { domain: "google.ga", countryCode: "ga", languageCode: "fr", name: "Gabon" },
      { domain: "google.gm", countryCode: "gm", languageCode: "en", name: "Gambia" },
      { domain: "google.ge", countryCode: "ge", languageCode: "ka", name: "Georgia" },
      { domain: "google.de", countryCode: "de", languageCode: "de", name: "Germany" },
      { domain: "google.com.gh", countryCode: "gh", languageCode: "en", name: "Ghana" },
      { domain: "google.com.gi", countryCode: "gi", languageCode: "en", name: "Gibraltar" },
      { domain: "google.gr", countryCode: "gr", languageCode: "el", name: "Greece" },
      { domain: "google.gl", countryCode: "gl", languageCode: "kl", name: "Greenland" },
      { domain: "google.gp", countryCode: "gp", languageCode: "fr", name: "Guadeloupe" },
      { domain: "google.com.gt", countryCode: "gt", languageCode: "es", name: "Guatemala" },
      { domain: "google.gy", countryCode: "gy", languageCode: "en", name: "Guyana" },
      { domain: "google.ht", countryCode: "ht", languageCode: "fr", name: "Haiti" },
      { domain: "google.hn", countryCode: "hn", languageCode: "es", name: "Honduras" },
      { domain: "google.com.hk", countryCode: "hk", languageCode: "en", name: "Hong Kong" },
      { domain: "google.hu", countryCode: "hu", languageCode: "hu", name: "Hungary" },
      { domain: "google.is", countryCode: "is", languageCode: "is", name: "Iceland" },
      { domain: "google.co.in", countryCode: "in", languageCode: "hi", name: "India" },
      { domain: "google.io", countryCode: "io", languageCode: "en", name: "Indian Ocean Territory" },
      { domain: "google.co.id", countryCode: "id", languageCode: "id", name: "Indonesia" },
      { domain: "google.iq", countryCode: "iq", languageCode: "ar", name: "Iraq" },
      { domain: "google.ie", countryCode: "ie", languageCode: "en", name: "Ireland" },
      { domain: "google.co.il", countryCode: "il", languageCode: "he", name: "Israel" },
      { domain: "google.it", countryCode: "it", languageCode: "it", name: "Italy" },
      { domain: "google.ci", countryCode: "ci", languageCode: "fr", name: "Ivory Coast" },
      { domain: "google.com.jm", countryCode: "jm", languageCode: "en", name: "Jamaica" },
      { domain: "google.co.jp", countryCode: "jp", languageCode: "ja", name: "Japan" },
      { domain: "google.jo", countryCode: "jo", languageCode: "ar", name: "Jordan" },
      { domain: "google.kz", countryCode: "kz", languageCode: "kk", name: "Kazakhstan" },
      { domain: "google.co.ke", countryCode: "ke", languageCode: "en", name: "Kenya" },
      { domain: "google.ki", countryCode: "ki", languageCode: "en", name: "Kiribati" },
      { domain: "google.com.kw", countryCode: "kw", languageCode: "ar", name: "Kuwait" },
      { domain: "google.kg", countryCode: "kg", languageCode: "ky", name: "Kyrgyzstan" },
      { domain: "google.la", countryCode: "la", languageCode: "lo", name: "Laos" },
      { domain: "google.lv", countryCode: "lv", languageCode: "lv", name: "Latvia" },
      { domain: "google.com.lb", countryCode: "lb", languageCode: "ar", name: "Lebanon" },
      { domain: "google.co.ls", countryCode: "ls", languageCode: "en", name: "Lesotho" },
      { domain: "google.com.ly", countryCode: "ly", languageCode: "ar", name: "Libya" },
      { domain: "google.li", countryCode: "li", languageCode: "de", name: "Liechtenstein" },
      { domain: "google.lt", countryCode: "lt", languageCode: "lt", name: "Lithuania" },
      { domain: "google.lu", countryCode: "lu", languageCode: "fr", name: "Luxembourg" },
      { domain: "google.mk", countryCode: "mk", languageCode: "mk", name: "Macedonia" },
      { domain: "google.mg", countryCode: "mg", languageCode: "fr", name: "Madagascar" },
      { domain: "google.mw", countryCode: "mw", languageCode: "en", name: "Malawi" },
      { domain: "google.com.my", countryCode: "my", languageCode: "ms", name: "Malaysia" },
      { domain: "google.mv", countryCode: "mv", languageCode: "dv", name: "Maldives" },
      { domain: "google.ml", countryCode: "ml", languageCode: "fr", name: "Mali" },
      { domain: "google.com.mt", countryCode: "mt", languageCode: "mt", name: "Malta" },
      { domain: "google.mu", countryCode: "mu", languageCode: "en", name: "Mauritius" },
      { domain: "google.com.mx", countryCode: "mx", languageCode: "es", name: "Mexico" },
      { domain: "google.fm", countryCode: "fm", languageCode: "en", name: "Micronesia" },
      { domain: "google.md", countryCode: "md", languageCode: "ro", name: "Moldova" },
      { domain: "google.mn", countryCode: "mn", languageCode: "mn", name: "Mongolia" },
      { domain: "google.ms", countryCode: "ms", languageCode: "en", name: "Montserrat" },
      { domain: "google.co.ma", countryCode: "ma", languageCode: "ar", name: "Morocco" },
      { domain: "google.co.mz", countryCode: "mz", languageCode: "pt", name: "Mozambique" },
      { domain: "google.com.mm", countryCode: "mm", languageCode: "my", name: "Myanmar" },
      { domain: "google.com.na", countryCode: "na", languageCode: "en", name: "Namibia" },
      { domain: "google.nr", countryCode: "nr", languageCode: "en", name: "Nauru" },
      { domain: "google.com.np", countryCode: "np", languageCode: "ne", name: "Nepal" },
      { domain: "google.nl", countryCode: "nl", languageCode: "nl", name: "Netherlands" },
      { domain: "google.co.nz", countryCode: "nz", languageCode: "en", name: "New Zealand" },
      { domain: "google.com.ni", countryCode: "ni", languageCode: "es", name: "Nicaragua" },
      { domain: "google.ne", countryCode: "ne", languageCode: "fr", name: "Niger" },
      { domain: "google.com.ng", countryCode: "ng", languageCode: "en", name: "Nigeria" },
      { domain: "google.nu", countryCode: "nu", languageCode: "en", name: "Niue" },
      { domain: "google.no", countryCode: "no", languageCode: "no", name: "Norway" },
      { domain: "google.com.om", countryCode: "om", languageCode: "ar", name: "Oman" },
      { domain: "google.com.pk", countryCode: "pk", languageCode: "en", name: "Pakistan" },
      { domain: "google.ps", countryCode: "ps", languageCode: "ar", name: "Palestine" },
      { domain: "google.com.pa", countryCode: "pa", languageCode: "es", name: "Panama" },
      { domain: "google.com.pg", countryCode: "pg", languageCode: "en", name: "Papua New Guinea" },
      { domain: "google.com.py", countryCode: "py", languageCode: "es", name: "Paraguay" },
      { domain: "google.com.pe", countryCode: "pe", languageCode: "es", name: "Peru" },
      { domain: "google.com.ph", countryCode: "ph", languageCode: "tl", name: "Philippines" },
      { domain: "google.pl", countryCode: "pl", languageCode: "pl", name: "Poland" },
      { domain: "google.pt", countryCode: "pt", languageCode: "pt", name: "Portugal" },
      { domain: "google.com.pr", countryCode: "pr", languageCode: "es", name: "Puerto Rico" },
      { domain: "google.com.qa", countryCode: "qa", languageCode: "ar", name: "Qatar" },
      { domain: "google.ro", countryCode: "ro", languageCode: "ro", name: "Romania" },
      { domain: "google.ru", countryCode: "ru", languageCode: "ru", name: "Russia" },
      { domain: "google.rw", countryCode: "rw", languageCode: "rw", name: "Rwanda" },
      { domain: "google.sh", countryCode: "sh", languageCode: "en", name: "Saint Helena" },
      { domain: "google.com.vc", countryCode: "vc", languageCode: "en", name: "Saint Vincent" },
      { domain: "google.ws", countryCode: "ws", languageCode: "sm", name: "Samoa" },
      { domain: "google.sm", countryCode: "sm", languageCode: "it", name: "San Marino" },
      { domain: "google.com.sa", countryCode: "sa", languageCode: "ar", name: "Saudi Arabia" },
      { domain: "google.sn", countryCode: "sn", languageCode: "fr", name: "Senegal" },
      { domain: "google.rs", countryCode: "rs", languageCode: "sr", name: "Serbia" },
      { domain: "google.sc", countryCode: "sc", languageCode: "fr", name: "Seychelles" },
      { domain: "google.com.sl", countryCode: "sl", languageCode: "en", name: "Sierra Leone" },
      { domain: "google.com.sg", countryCode: "sg", languageCode: "en", name: "Singapore" },
      { domain: "google.sk", countryCode: "sk", languageCode: "sk", name: "Slovakia" },
      { domain: "google.si", countryCode: "si", languageCode: "sl", name: "Slovenia" },
      { domain: "google.com.sb", countryCode: "sb", languageCode: "en", name: "Solomon Islands" },
      { domain: "google.so", countryCode: "so", languageCode: "so", name: "Somalia" },
      { domain: "google.co.za", countryCode: "za", languageCode: "af", name: "South Africa" },
      { domain: "google.co.kr", countryCode: "kp", languageCode: "ko", name: "South Korea" },
      { domain: "google.es", countryCode: "es", languageCode: "es", name: "Spain" },
      { domain: "google.lk", countryCode: "lk", languageCode: "si", name: "Sri Lanka" },
      { domain: "google.sr", countryCode: "sr", languageCode: "nl", name: "Suriname" },
      { domain: "google.se", countryCode: "se", languageCode: "sv", name: "Sweden" },
      { domain: "google.ch", countryCode: "ch", languageCode: "de", name: "Switzerland" },
      { domain: "google.com.tw", countryCode: "tw", languageCode: "zh", name: "Taiwan" },
      { domain: "google.com.tj", countryCode: "tj", languageCode: "tg", name: "Tajikistan" },
      { domain: "google.co.tz", countryCode: "tz", languageCode: "sw", name: "Tanzania" },
      { domain: "google.co.th", countryCode: "th", languageCode: "th", name: "Thailand" },
      { domain: "google.tl", countryCode: "tl", languageCode: "pt", name: "Timor-Leste" },
      { domain: "google.tg", countryCode: "tg", languageCode: "fr", name: "Togo" },
      { domain: "google.tk", countryCode: "tk", languageCode: "en", name: "Tokelau" },
      { domain: "google.to", countryCode: "to", languageCode: "en", name: "Tonga" },
      { domain: "google.tt", countryCode: "tt", languageCode: "en", name: "Trinidad and Tobago" },
      { domain: "google.tn", countryCode: "tn", languageCode: "ar", name: "Tunisia" },
      { domain: "google.com.tr", countryCode: "tr", languageCode: "tr", name: "Turkey" },
      { domain: "google.tm", countryCode: "tm", languageCode: "tk", name: "Turkmenistan" },
      { domain: "google.co.ug", countryCode: "ug", languageCode: "en", name: "Uganda" },
      { domain: "google.com.ua", countryCode: "ua", languageCode: "uk", name: "Ukraine" },
      { domain: "google.ae", countryCode: "ae", languageCode: "ar", name: "United Arab Emirates" },
      { domain: "google.co.uk", countryCode: "uk", languageCode: "en", name: "United Kingdom" },
      { domain: "google.com", countryCode: "us", languageCode: "en", name: "United States" },
      { domain: "google.com.uy", countryCode: "uy", languageCode: "es", name: "Uruguay" },
      { domain: "google.co.vi", countryCode: "vi", languageCode: "en", name: "US Virgin Islands" },
      { domain: "google.co.uz", countryCode: "uz", languageCode: "uz", name: "Uzbekistan" },
      { domain: "google.vu", countryCode: "vu", languageCode: "bi", name: "Vanuatu" },
      { domain: "google.co.ve", countryCode: "ve", languageCode: "es", name: "Venezuela" },
      { domain: "google.com.vn", countryCode: "vn", languageCode: "vi", name: "Vietnam" },
      { domain: "google.co.zm", countryCode: "zm", languageCode: "en", name: "Zambia" },
      { domain: "google.co.zw", countryCode: "zw", languageCode: "en", name: "Zimbabwe" }
    ];
    googlePageLanguages = [
      { value: "af", label: "Afrikaans" },
      { value: "ak", label: "Akan" },
      { value: "sq", label: "Albanian" },
      { value: "am", label: "Amharic" },
      { value: "ar", label: "Arabic" },
      { value: "hy", label: "Armenian" },
      { value: "az", label: "Azerbaijani" },
      { value: "eu", label: "Basque" },
      { value: "be", label: "Belarusian" },
      { value: "bem", label: "Bemba" },
      { value: "bn", label: "Bengali" },
      { value: "bh", label: "Bihari" },
      { value: "bs", label: "Bosnian" },
      { value: "br", label: "Breton" },
      { value: "bg", label: "Bulgarian" },
      { value: "km", label: "Cambodian" },
      { value: "ca", label: "Catalan" },
      { value: "chr", label: "Cherokee" },
      { value: "ny", label: "Chichewa" },
      { value: "zh-cn", label: "Chinese (Simplified)" },
      { value: "zh-tw", label: "Chinese (Traditional)" },
      { value: "co", label: "Corsican" },
      { value: "hr", label: "Croatian" },
      { value: "cs", label: "Czech" },
      { value: "da", label: "Danish" },
      { value: "nl", label: "Dutch" },
      { value: "en", label: "English" },
      { value: "eo", label: "Esperanto" },
      { value: "et", label: "Estonian" },
      { value: "ee", label: "Ewe" },
      { value: "fo", label: "Faroese" },
      { value: "tl", label: "Filipino" },
      { value: "fi", label: "Finnish" },
      { value: "fr", label: "French" },
      { value: "fy", label: "Frisian" },
      { value: "gaa", label: "Ga" },
      { value: "gl", label: "Galician" },
      { value: "ka", label: "Georgian" },
      { value: "de", label: "German" },
      { value: "el", label: "Greek" },
      { value: "gn", label: "Guarani" },
      { value: "gu", label: "Gujarati" },
      { value: "ht", label: "Haitian Creole" },
      { value: "ha", label: "Hausa" },
      { value: "haw", label: "Hawaiian" },
      { value: "he", label: "Hebrew" },
      { value: "iw", label: "Hebrew" },
      { value: "hi", label: "Hindi" },
      { value: "hu", label: "Hungarian" },
      { value: "is", label: "Icelandic" },
      { value: "ig", label: "Igbo" },
      { value: "id", label: "Indonesian" },
      { value: "ia", label: "Interlingua" },
      { value: "ga", label: "Irish" },
      { value: "it", label: "Italian" },
      { value: "ja", label: "Japanese" },
      { value: "jw", label: "Javanese" },
      { value: "kn", label: "Kannada" },
      { value: "kk", label: "Kazakh" },
      { value: "rw", label: "Kinyarwanda" },
      { value: "rn", label: "Kirundi" },
      { value: "kg", label: "Kongo" },
      { value: "ko", label: "Korean" },
      { value: "kri", label: "Krio (Sierra Leone)" },
      { value: "ku", label: "Kurdish" },
      { value: "ckb", label: "Kurdish (Soran\xEE)" },
      { value: "ky", label: "Kyrgyz" },
      { value: "lo", label: "Laothian" },
      { value: "la", label: "Latin" },
      { value: "lv", label: "Latvian" },
      { value: "ln", label: "Lingala" },
      { value: "lt", label: "Lithuanian" },
      { value: "loz", label: "Lozi" },
      { value: "lg", label: "Luganda" },
      { value: "ach", label: "Luo" },
      { value: "mk", label: "Macedonian" },
      { value: "mg", label: "Malagasy" },
      { value: "ms", label: "Malay" },
      { value: "ml", label: "Malayalam" },
      { value: "mt", label: "Maltese" },
      { value: "mi", label: "Maori" },
      { value: "mr", label: "Marathi" },
      { value: "mfe", label: "Mauritian Creole" },
      { value: "mo", label: "Moldavian" },
      { value: "mn", label: "Mongolian" },
      { value: "sr-ME", label: "Montenegrin" },
      { value: "ne", label: "Nepali" },
      { value: "pcm", label: "Nigerian Pidgin" },
      { value: "nso", label: "Northern Sotho" },
      { value: "no", label: "Norwegian" },
      { value: "nn", label: "Norwegian (Nynorsk)" },
      { value: "oc", label: "Occitan" },
      { value: "or", label: "Oriya" },
      { value: "om", label: "Oromo" },
      { value: "ps", label: "Pashto" },
      { value: "fa", label: "Persian" },
      { value: "pl", label: "Polish" },
      { value: "pt", label: "Portuguese" },
      { value: "pt-br", label: "Portuguese (Brazil)" },
      { value: "pt-pt", label: "Portuguese (Portugal)" },
      { value: "pa", label: "Punjabi" },
      { value: "qu", label: "Quechua" },
      { value: "ro", label: "Romanian" },
      { value: "rm", label: "Romansh" },
      { value: "nyn", label: "Runyakitara" },
      { value: "ru", label: "Russian" },
      { value: "gd", label: "Scots Gaelic" },
      { value: "sr", label: "Serbian" },
      { value: "sh", label: "Serbo-Croatian" },
      { value: "st", label: "Sesotho" },
      { value: "tn", label: "Setswana" },
      { value: "crs", label: "Seychellois Creole" },
      { value: "sn", label: "Shona" },
      { value: "sd", label: "Sindhi" },
      { value: "si", label: "Sinhalese" },
      { value: "sk", label: "Slovak" },
      { value: "sl", label: "Slovenian" },
      { value: "so", label: "Somali" },
      { value: "es", label: "Spanish" },
      { value: "es-419", label: "Spanish (Latin American)" },
      { value: "su", label: "Sundanese" },
      { value: "sw", label: "Swahili" },
      { value: "sv", label: "Swedish" },
      { value: "tg", label: "Tajik" },
      { value: "ta", label: "Tamil" },
      { value: "tt", label: "Tatar" },
      { value: "te", label: "Telugu" },
      { value: "th", label: "Thai" },
      { value: "ti", label: "Tigrinya" },
      { value: "to", label: "Tonga" },
      { value: "lua", label: "Tshiluba" },
      { value: "tum", label: "Tumbuka" },
      { value: "tr", label: "Turkish" },
      { value: "tk", label: "Turkmen" },
      { value: "tw", label: "Twi" },
      { value: "ug", label: "Uighur" },
      { value: "uk", label: "Ukrainian" },
      { value: "ur", label: "Urdu" },
      { value: "uz", label: "Uzbek" },
      { value: "vi", label: "Vietnamese" },
      { value: "cy", label: "Welsh" },
      { value: "wo", label: "Wolof" },
      { value: "xh", label: "Xhosa" },
      { value: "yi", label: "Yiddish" },
      { value: "yo", label: "Yoruba" },
      { value: "zu", label: "Zulu" }
    ];
    publishLanguages = [
      { value: "lang_ar", label: "Arabic" },
      { value: "lang_hy", label: "Armenian" },
      { value: "lang_be", label: "Belarusian" },
      { value: "lang_bg", label: "Bulgarian" },
      { value: "lang_ca", label: "Catalan" },
      { value: "lang_zh-cn", label: "Chinese Simplified" },
      { value: "lang_zh-tw", label: "Chinese Traditional" },
      { value: "lang_hr", label: "Croatian" },
      { value: "lang_cs", label: "Czech" },
      { value: "lang_da", label: "Danish" },
      { value: "lang_nl", label: "Dutch" },
      { value: "lang_en", label: "English" },
      { value: "lang_eo", label: "Esperanto" },
      { value: "lang_et", label: "Estonian" },
      { value: "lang_tl", label: "Filipino" },
      { value: "lang_fi", label: "Finnish" },
      { value: "lang_fr", label: "French" },
      { value: "lang_de", label: "German" },
      { value: "lang_el", label: "Greek" },
      { value: "lang_iw", label: "Hebrew" },
      { value: "lang_hu", label: "Hungarian" },
      { value: "lang_is", label: "Icelandic" },
      { value: "lang_id", label: "Indonesian" },
      { value: "lang_it", label: "Italian" },
      { value: "lang_ja", label: "Japanese" },
      { value: "lang_ko", label: "Korean" },
      { value: "lang_lv", label: "Latvian" },
      { value: "lang_lt", label: "Lithuanian" },
      { value: "lang_no", label: "Norwegian" },
      { value: "lang_fa", label: "Persian" },
      { value: "lang_pl", label: "Polish" },
      { value: "lang_pt", label: "Portuguese" },
      { value: "lang_ro", label: "Romanian" },
      { value: "lang_ru", label: "Russian" },
      { value: "lang_sr", label: "Serbian" },
      { value: "lang_sk", label: "Slovak" },
      { value: "lang_sl", label: "Slovenian" },
      { value: "lang_es", label: "Spanish" },
      { value: "lang_sv", label: "Swedish" },
      { value: "lang_th", label: "Thai" },
      { value: "lang_tr", label: "Turkish" },
      { value: "lang_uk", label: "Ukrainian" },
      { value: "lang_vi", label: "Vietnamese" }
    ];
    pastOptions = [
      {
        label: "... the past 24 hours",
        value: "d"
      },
      {
        label: "... the last hour",
        value: "h"
      },
      {
        label: "... the past 7 days",
        value: "w"
      },
      {
        label: "... the past month",
        value: "m"
      },
      {
        label: "... the past 6 months",
        value: "m6"
      },
      {
        label: "... the past year",
        value: "y"
      },
      {
        label: "... anytime for all time",
        value: "all"
      }
    ];
    rightsOptions = [
      {
        value: "(cc_publicdomain|cc_attribute|cc_sharealike|cc_noncommercial|cc_nonderived)",
        label: "free to use or share"
      },
      {
        value: "(cc_publicdomain|cc_attribute|cc_sharealike|cc_nonderived).-(cc_noncommercial)",
        label: "free to use or share, including commercially"
      },
      {
        value: "(cc_publicdomain|cc_attribute|cc_sharealike|cc_noncommercial).-(cc_nonderived)",
        label: "free to use, share, or modify"
      },
      {
        value: "(cc_publicdomain|cc_attribute|cc_sharealike).-(cc_noncommercial|cc_nonderived)",
        label: "free to use, share, or modify commercially"
      }
    ];
    FileType$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.fileType = {
            type: "File Type",
            value,
            formatted: `filetype:${value.trim()} `
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "File Type",
        label: "... of this file type",
        textInputPlaceholder: "File type",
        options: fileTypes
      }, {}, {})}`;
    });
    Related$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Related",
        hasInput: true,
        label: "... that are similar to this webpage",
        textInputPlaceholder: "URL (example: www.cnn.com)"
      }, {}, {})}`;
    });
    Safe$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.safe = {
            type: "Safe",
            value,
            formatted: `safe=${value.trim()} `
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleCheckboxChange: handleChange,
        type: "Safe",
        label: "Use safe search"
      }, {}, {})}`;
    });
    Site$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Site",
        hasInput: true,
        label: "... from this website or domain",
        textInputPlaceholder: "Website (examples: cnn.com, .com, .org)"
      }, {}, {})}`;
    });
    Synonyms = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Synonyms",
        hasInput: true,
        label: "... with these words and their synonyms",
        textInputPlaceholder: "Words to include (example: amazed sailor)"
      }, {}, {})}`;
    });
    ExcludeSite = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "ExcludeSite",
        hasInput: true,
        label: "... excluding results from any of these websites",
        textInputPlaceholder: "Websites to exclude (example: cnn.com bbc.com)"
      }, {}, {})}`;
    });
    NumRange = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "NumRange",
        hasInput: true,
        label: "... with results that fall within this numbers range",
        textInputPlaceholder: "numbers range (example: $100 $200)"
      }, {}, {})}`;
    });
    Bing = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h2 class="${"text-gray-300"}">Only return pages...</h2>
${validate_component(Synonyms, "SynonymsFilter").$$render($$result, {}, {}, {})}
${validate_component(Exact$1, "Exact").$$render($$result, {}, {}, {})}
${validate_component(Exclude$1, "ExcludeFilter").$$render($$result, {}, {}, {})}
${validate_component(Site$1, "SiteFilter").$$render($$result, {}, {}, {})}
${validate_component(ExcludeSite, "ExcludeSite").$$render($$result, {}, {}, {})}
${validate_component(NumRange, "NumRange").$$render($$result, {}, {}, {})}
${validate_component(FileType$1, "FileTypeFilter").$$render($$result, {}, {}, {})}

${validate_component(Related$1, "RelatedFilter").$$render($$result, {}, {}, {})}
<h2 class="${"text-gray-300 mt-4"}">Additional Settings</h2>
${validate_component(Safe$1, "Safe").$$render($$result, {}, {}, {})}`;
    });
    DuckDuckGo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h2 class="${"text-gray-300"}">Only return pages...</h2>
${validate_component(Synonyms, "SynonymsFilter").$$render($$result, {}, {}, {})}
${validate_component(Exact$1, "Exact").$$render($$result, {}, {}, {})}
${validate_component(Exclude$1, "ExcludeFilter").$$render($$result, {}, {}, {})}
${validate_component(Site$1, "SiteFilter").$$render($$result, {}, {}, {})}
${validate_component(ExcludeSite, "ExcludeSite").$$render($$result, {}, {}, {})}
${validate_component(NumRange, "NumRange").$$render($$result, {}, {}, {})}
${validate_component(FileType$1, "FileTypeFilter").$$render($$result, {}, {}, {})}

${validate_component(Related$1, "RelatedFilter").$$render($$result, {}, {}, {})}`;
    });
    Area = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.area = {
            type: "Area",
            value,
            formatted: `as_occt=${encodeURIComponent(value)}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Area",
        label: "... with the search term in the ...",
        textInputPlaceholder: "Search Area",
        options: searchAreas
      }, {}, {})}`;
    });
    Content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.contentType = {
            type: "Content Type",
            value,
            formatted: `tbm=${encodeURIComponent(value)} `
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Content Type",
        label: "... of this content type",
        textInputPlaceholder: "Select content type",
        options: contentOptions
      }, {}, {})}`;
    });
    Country = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.country = {
            type: "Country",
            value,
            formatted: `cr=${encodeURIComponent(`country${value.toUpperCase()}`)}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Country",
        label: "Only return results in this country",
        textInputPlaceholder: "Results Country",
        options: googleCountries
      }, {}, {})}`;
    });
    Exact = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Exact",
        hasInput: true,
        label: "... that have this exact word or phrase",
        textInputPlaceholder: "Word/Phrase (example: we live in a society)"
      }, {}, {})}`;
    });
    Exclude = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Exclude",
        hasInput: true,
        label: "... without any of these words",
        textInputPlaceholder: "Words to exclude (example: detect plagiarism)"
      }, {}, {})}`;
    });
    FileType = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.fileType = {
            type: "File Type",
            value,
            formatted: `as_filetype=${encodeURIComponent(value)} `
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "File Type",
        label: "... of this file type",
        textInputPlaceholder: "File type (example: pdf)",
        options: fileTypes
      }, {}, {})}`;
    });
    Link = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Link",
        hasInput: true,
        label: "... that point to this URL",
        textInputPlaceholder: "URL (example: www.cnn.com)"
      }, {}, {})}`;
    });
    Locale = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          var _a4;
          const newQuery = __spreadValues({}, currentQuery);
          const domain = googleDomains.find((domain2) => domain2.countryCode === value) || googleDomains.find((domain2) => domain2.countryCode === "us");
          const language = ((_a4 = googlePageLanguages.find((language2) => language2.value === (domain === null || domain === void 0 ? void 0 : domain.languageCode))) === null || _a4 === void 0 ? void 0 : _a4.value) || "en";
          newQuery.filters.locale = {
            type: "Locale",
            value,
            formatted: `gl=${encodeURIComponent(value)}&hl=${encodeURIComponent(language)}&google_domain=${encodeURIComponent((domain === null || domain === void 0 ? void 0 : domain.domain) || "")}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Locale",
        label: "Use this locale",
        textInputPlaceholder: "Locale",
        options: googleCountries
      }, {}, {})}`;
    });
    Past = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.past = {
            type: "Past",
            value,
            formatted: `as_qdr=${encodeURIComponent(value)}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Past",
        label: "... that were published in ...",
        options: pastOptions
      }, {}, {})}`;
    });
    Personal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.personal = {
            type: "Personal",
            value,
            formatted: `complete=0&pws=${Number(value)}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleCheckboxChange: handleChange,
        type: "Personal",
        label: "Turn off personalised results"
      }, {}, {})}`;
    });
    PublishLanguage = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.publishLanguage = {
            type: "Publish Language",
            value,
            formatted: `lr=${encodeURIComponent(value)} `
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Publish Language",
        label: "... published in this language",
        textInputPlaceholder: "Publish Language",
        options: publishLanguages
      }, {}, {})}`;
    });
    Related = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Related",
        hasInput: true,
        label: "... that are similar to this webpage",
        textInputPlaceholder: "URL (example: www.cnn.com)"
      }, {}, {})}`;
    });
    Rights = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.rights = {
            type: "Rights",
            value,
            formatted: `as_rights=${encodeURIComponent(value)}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleSelectChange: handleChange,
        type: "Rights",
        label: "... that have the following rights",
        options: rightsOptions
      }, {}, {})}`;
    });
    Safe = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      const handleChange = (e2) => {
        const value = e2.target.value;
        queryStore.update((currentQuery) => {
          const newQuery = __spreadValues({}, currentQuery);
          newQuery.filters.safe = {
            type: "Safe",
            value,
            formatted: `safe=${encodeURIComponent(value.trim())}`
          };
          return newQuery;
        });
      };
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        handleCheckboxChange: handleChange,
        type: "Safe",
        label: "Use safe search"
      }, {}, {})}`;
    });
    Site = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Base, "FilterBase").$$render($$result, {
        type: "Site",
        hasInput: true,
        label: "... from this website or domain",
        textInputPlaceholder: "Website (examples: cnn.com, .com, .org)"
      }, {}, {})}`;
    });
    Google = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h2 class="${"text-gray-300"}">Only return pages...</h2>
${validate_component(Synonyms, "SynonymsFilter").$$render($$result, {}, {}, {})}
${validate_component(Exact, "Exact").$$render($$result, {}, {}, {})}
${validate_component(Exclude, "ExcludeFilter").$$render($$result, {}, {}, {})}
${validate_component(Past, "Past").$$render($$result, {}, {}, {})}
${validate_component(Rights, "Rights").$$render($$result, {}, {}, {})}
${validate_component(PublishLanguage, "PublishLanguage").$$render($$result, {}, {}, {})}
${validate_component(Content, "Content").$$render($$result, {}, {}, {})}
${validate_component(Site, "SiteFilter").$$render($$result, {}, {}, {})}
${validate_component(ExcludeSite, "ExcludeSite").$$render($$result, {}, {}, {})}


${validate_component(Area, "Area").$$render($$result, {}, {}, {})}
${validate_component(NumRange, "NumRange").$$render($$result, {}, {}, {})}
${validate_component(FileType, "FileTypeFilter").$$render($$result, {}, {}, {})}
${validate_component(Link, "LinkFilter").$$render($$result, {}, {}, {})}
${validate_component(Related, "RelatedFilter").$$render($$result, {}, {}, {})}
<h2 class="${"text-gray-300 mt-4"}">Additional Settings</h2>
${validate_component(Safe, "Safe").$$render($$result, {}, {}, {})}
${validate_component(Personal, "Personal").$$render($$result, {}, {}, {})}


${validate_component(Locale, "Locale").$$render($$result, {}, {}, {})}
${validate_component(Country, "Country").$$render($$result, {}, {}, {})}`;
    });
    Yahoo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<h2 class="${"text-gray-300"}">Only return pages...</h2>
${validate_component(Synonyms, "SynonymsFilter").$$render($$result, {}, {}, {})}
${validate_component(Exact$1, "Exact").$$render($$result, {}, {}, {})}
${validate_component(Exclude$1, "ExcludeFilter").$$render($$result, {}, {}, {})}
${validate_component(Site$1, "SiteFilter").$$render($$result, {}, {}, {})}
${validate_component(ExcludeSite, "ExcludeSite").$$render($$result, {}, {}, {})}
${validate_component(NumRange, "NumRange").$$render($$result, {}, {}, {})}
${validate_component(FileType$1, "FileTypeFilter").$$render($$result, {}, {}, {})}

${validate_component(Related$1, "RelatedFilter").$$render($$result, {}, {}, {})}`;
    });
    Filters = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $queryStore, $$unsubscribe_queryStore;
      $$unsubscribe_queryStore = subscribe(queryStore, (value) => $queryStore = value);
      $$unsubscribe_queryStore();
      return `<div class="${"collapse my-2 w-full border rounded-box border-base-300 collapse-arrow"}"><input type="${"checkbox"}">
	<div class="${"collapse-title text-gray-300"}">Add Filters</div>
	<div class="${"collapse-content"}"><div class="${"filters"}">${$queryStore.provider.name === "Google" ? `${validate_component(Google, "Google").$$render($$result, {}, {}, {})}` : `${$queryStore.provider.name === "Bing" ? `${validate_component(Bing, "Bing").$$render($$result, {}, {}, {})}` : `${$queryStore.provider.name === "Yahoo" ? `${validate_component(Yahoo, "Yahoo").$$render($$result, {}, {}, {})}` : `${$queryStore.provider.name === "DuckDuckGo" ? `${validate_component(DuckDuckGo, "DuckDuckGo").$$render($$result, {}, {}, {})}` : ``}`}`}`}</div></div></div>`;
    });
    css$12 = {
      code: ".query-url.svelte-8jsznr::-webkit-scrollbar{width:5px}.query-url.svelte-8jsznr::-webkit-scrollbar-track{background-color:#374151;border-radius:100px;width:10px}.query-url.svelte-8jsznr::-webkit-scrollbar-thumb{border-radius:80px;border:5px solid transparent;background-clip:content-box;background-color:#8070d4}",
      map: null
    };
    QueryURLPreview = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let queryUrl = "";
      queryStore.subscribe(() => {
        queryUrl = encodeURI(generateQueryUrl({ skipSearchTermCheck: true }));
      });
      $$result.css.add(css$12);
      return `<div class="${"query-url text-xs whitespace-nowrap my-4 py-2 px-4 bordered bg-purple-600 bg-opacity-40 rounded-lg overflow-x-auto svelte-8jsznr"}">${escape(queryUrl)}
</div>`;
    });
    SearchBarBase = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $queryStore, $$unsubscribe_queryStore;
      $$unsubscribe_queryStore = subscribe(queryStore, (value) => $queryStore = value);
      let searchInput;
      let { executeQuery } = $$props;
      let { saveQuery = false } = $$props;
      if ($$props.executeQuery === void 0 && $$bindings.executeQuery && executeQuery !== void 0)
        $$bindings.executeQuery(executeQuery);
      if ($$props.saveQuery === void 0 && $$bindings.saveQuery && saveQuery !== void 0)
        $$bindings.saveQuery(saveQuery);
      $$unsubscribe_queryStore();
      return `<div class="${"relative w-full"}"><input class="${"input input-bordered input-primary w-full bg-gray-600"}" placeholder="${"Search"}" type="${"text"}"${add_attribute("value", $queryStore.search_term, 0)}${add_attribute("this", searchInput, 0)}>

	${$queryStore.search_term ? `<button class="${"absolute top-2 right-2 btn-sm btn-ghost btn btn-circle"}">\u2715</button>` : ``}</div>

<button class="${"btn btn-primary"}">Search</button>`;
    });
    SearchBarWithoutQueryAutosave = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$unsubscribe_savedQueriesStore;
      let $queryStore, $$unsubscribe_queryStore;
      let $authStore, $$unsubscribe_authStore;
      $$unsubscribe_savedQueriesStore = subscribe(savedQueriesStore, (value) => value);
      $$unsubscribe_queryStore = subscribe(queryStore, (value) => $queryStore = value);
      $$unsubscribe_authStore = subscribe(authStore, (value) => $authStore = value);
      let { executeQuery } = $$props;
      let queryName = "";
      let input = null;
      if ($$props.executeQuery === void 0 && $$bindings.executeQuery && executeQuery !== void 0)
        $$bindings.executeQuery(executeQuery);
      $$unsubscribe_savedQueriesStore();
      $$unsubscribe_queryStore();
      $$unsubscribe_authStore();
      return `${validate_component(SearchBarBase, "SearchBarBase").$$render($$result, { executeQuery }, {}, {})}
${$queryStore.search_term && $authStore.isLoggedIn ? `<label${add_attribute("for", `name-query-modal-btn-${$queryStore.id}`, 0)} class="${"btn btn-outlint"}">Save</label>
	<input type="${"checkbox"}"${add_attribute("id", `name-query-modal-btn-${$queryStore.id}`, 0)} class="${"modal-toggle"}">
	<div class="${"modal"}"><div class="${"modal-box"}"><h1 class="${"text-xl font-bold mb-4"}">Save Query</h1>
			<div class="${"w-full flex gap-2"}"><input placeholder="${"Query Name"}" type="${"text"}" class="${"input input-bordered w-full"}"${add_attribute("this", input, 0)}${add_attribute("value", queryName, 0)}></div>

			<div class="${"modal-action"}"><button${add_attribute("for", `name-query-modal-btn-${$queryStore.id}`, 0)} class="${"btn btn-primary"}">Save</button>
				<label${add_attribute("for", `name-query-modal-btn-${$queryStore.id}`, 0)} class="${"btn"}">Close</label></div></div></div>` : ``}`;
    });
    SearchBarWithQueryAutosave = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { executeQuery } = $$props;
      if ($$props.executeQuery === void 0 && $$bindings.executeQuery && executeQuery !== void 0)
        $$bindings.executeQuery(executeQuery);
      return `${validate_component(SearchBarBase, "SearchBarBase").$$render($$result, { executeQuery, saveQuery: true }, {}, {})}`;
    });
    ComponentSelector = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $featureFlagsStore, $$unsubscribe_featureFlagsStore;
      $$unsubscribe_featureFlagsStore = subscribe(featureFlagsStore, (value) => $featureFlagsStore = value);
      let { featureFlag = null } = $$props;
      let { onFeature } = $$props;
      let { offFeature } = $$props;
      let { condition = null } = $$props;
      let { props = {} } = $$props;
      let selector = "off";
      let features = { on: onFeature, off: offFeature };
      const handleChange = (ff, cond) => {
        if (ff !== null && cond !== null) {
          selector = $featureFlagsStore[ff] === "on" && cond ? "on" : "off";
        } else if (ff !== null && cond === null) {
          selector = $featureFlagsStore[ff] === "on" ? "on" : "off";
        } else if (ff === null && cond !== null) {
          selector = cond ? "on" : "off";
        }
      };
      let unsubscribe;
      onDestroy(() => unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe());
      if ($$props.featureFlag === void 0 && $$bindings.featureFlag && featureFlag !== void 0)
        $$bindings.featureFlag(featureFlag);
      if ($$props.onFeature === void 0 && $$bindings.onFeature && onFeature !== void 0)
        $$bindings.onFeature(onFeature);
      if ($$props.offFeature === void 0 && $$bindings.offFeature && offFeature !== void 0)
        $$bindings.offFeature(offFeature);
      if ($$props.condition === void 0 && $$bindings.condition && condition !== void 0)
        $$bindings.condition(condition);
      if ($$props.props === void 0 && $$bindings.props && props !== void 0)
        $$bindings.props(props);
      {
        {
          unsubscribe = featureFlagsStore.subscribe((newValue) => {
            selector = newValue[featureFlag] === "on" && condition ? "on" : "off";
          });
        }
      }
      {
        {
          handleChange(featureFlag, condition);
          console.log(selector ? "" : "");
        }
      }
      $$unsubscribe_featureFlagsStore();
      return `${validate_component(features[selector] || missing_component, "svelte:component").$$render($$result, Object.assign(props), {}, {})}`;
    });
    SearchBar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $settingsStore, $$unsubscribe_settingsStore;
      $$unsubscribe_settingsStore = subscribe(settingsStore, (value) => $settingsStore = value);
      let { executeQuery } = $$props;
      if ($$props.executeQuery === void 0 && $$bindings.executeQuery && executeQuery !== void 0)
        $$bindings.executeQuery(executeQuery);
      $$unsubscribe_settingsStore();
      return `${validate_component(ComponentSelector, "ComponentSelector").$$render($$result, {
        condition: !$settingsStore.autosave_queries,
        onFeature: SearchBarWithoutQueryAutosave,
        offFeature: SearchBarWithQueryAutosave,
        props: { executeQuery }
      }, {}, {})}`;
    });
    SearchProvider = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      var _a4;
      let $searchProvidersStore, $$unsubscribe_searchProvidersStore;
      let $queryStore, $$unsubscribe_queryStore;
      $$unsubscribe_searchProvidersStore = subscribe(searchProvidersStore, (value) => $searchProvidersStore = value);
      $$unsubscribe_queryStore = subscribe(queryStore, (value) => $queryStore = value);
      $$unsubscribe_searchProvidersStore();
      $$unsubscribe_queryStore();
      return `${validate_component(SearchProviderSelect, "SearchProviderSelect").$$render($$result, {
        value: (_a4 = $queryStore.provider) == null ? void 0 : _a4.id,
        searchProviders: $searchProvidersStore
      }, {}, {})}`;
    });
    css5 = {
      code: ".main-area.svelte-1cpvz8l::-webkit-scrollbar{width:15px}.main-area.svelte-1cpvz8l::-webkit-scrollbar-track{background-color:#374151;border-radius:100px}.main-area.svelte-1cpvz8l::-webkit-scrollbar-thumb{border-radius:80px;border:5px solid transparent;background-clip:content-box;background-color:#8070d4}",
      map: null
    };
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $settingsStore, $$unsubscribe_settingsStore;
      let $authStore, $$unsubscribe_authStore;
      $$unsubscribe_settingsStore = subscribe(settingsStore, (value) => $settingsStore = value);
      $$unsubscribe_authStore = subscribe(authStore, (value) => $authStore = value);
      let url = "";
      const executeQueryWithIFrame = (queryUrl) => {
        url = queryUrl + "&igu=1";
      };
      const executeQueryWithNewTab = (queryUrl) => {
        if (typeof queryUrl === "string") {
          window.open(queryUrl);
        } else {
          for (let [key2, url2] of queryUrl.entries()) {
            if (key2 === 0) {
              window.open(url2, `_blank_first_${key2.toString()}`);
            } else {
              setTimeout(function() {
                window.open(url2, `_blank_${key2.toString()}`);
              }, 1500 * key2);
            }
          }
        }
      };
      $$result.css.add(css5);
      $$unsubscribe_settingsStore();
      $$unsubscribe_authStore();
      return `<div class="${"main-area p-8 pt-6 relative h-full overflow-y-scroll grid grid-cols-[1fr] md:grid-cols-[minmax(600px,1fr)_minmax(290px,400px)] gap-8 svelte-1cpvz8l"}">
	<div class="${"max-w-6xl h-full"}"><main class="${"dark:text-gray-50"}"><div class="${"flex flex-col gap-2 md:flex-row"}">${validate_component(SearchProvider, "SearchProvider").$$render($$result, {}, {}, {})}
				${validate_component(ValueSelector, "ValueSelector").$$render($$result, {
        featureFlag: "Results_In_IFrame",
        onValue: executeQueryWithIFrame,
        offValue: executeQueryWithNewTab
      }, {}, {
        default: ({ feature: executeQuery }) => {
          return `${validate_component(SearchBar, "SearchBar").$$render($$result, { executeQuery }, {}, {})}`;
        }
      })}</div>

			${$settingsStore.query_preview ? `${validate_component(QueryURLPreview, "QueryUrlPreview").$$render($$result, {}, {}, {})}` : ``}

			${!$authStore.isLoggedIn ? `${validate_component(Announcement, "Announcement").$$render($$result, {}, {}, {
        default: () => {
          return `<label for="${"auth-modal"}" class="${"underline cursor-pointer font-bold inline"}">Sign up</label>
					to save your queries and other cool features!
				`;
        }
      })}` : ``}

			${url ? `<iframe title="${"Results"}"${add_attribute("src", url, 0)} class="${"w-full h-full"}" frameborder="${"0"}"></iframe>` : `${validate_component(Filters, "Filters").$$render($$result, {}, {}, {})}
				`}</main></div>

	${$authStore.isLoggedIn ? `${validate_component(SavedQueriesList, "SavedQueriesList").$$render($$result, {}, {}, {})}` : ``}
</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  css: () => css6,
  entry: () => entry3,
  js: () => js3,
  module: () => index_svelte_exports
});
var entry3, js3, css6;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_index_svelte();
    entry3 = "pages/index.svelte-302aec2e.js";
    js3 = ["pages/index.svelte-302aec2e.js", "chunks/vendor-739188d0.js", "chunks/supabaseClient-f98d745b.js", "chunks/generateQueryUrl-359b1f52.js", "chunks/SavedQueriesList-f8d6be83.js", "chunks/SavedQuery-7c294e90.js", "chunks/singletons-d1fb5791.js"];
    css6 = ["assets/pages/index.svelte-bd8536ff.css", "assets/SavedQueriesList-cb9d0b05.css"];
  }
});

// .svelte-kit/output/server/entries/pages/saved-queries.svelte.js
var saved_queries_svelte_exports = {};
__export(saved_queries_svelte_exports, {
  default: () => Saved_queries
});
var import_splitio4, css7, Saved_queries;
var init_saved_queries_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/saved-queries.svelte.js"() {
    init_index_d153bcdc();
    init_Protected_4906baaa();
    init_SavedQuery_7048865a();
    init_supabaseClient_772c11ee();
    init_fuzzy();
    import_splitio4 = __toESM(require_lib4(), 1);
    css7 = {
      code: ".saved-queries-list.svelte-cyvla3::-webkit-scrollbar{width:15px}.saved-queries-list.svelte-cyvla3::-webkit-scrollbar-track{background-color:#555555;border-radius:100px}.saved-queries-list.svelte-cyvla3::-webkit-scrollbar-thumb{border-radius:80px;border:5px solid transparent;background-clip:content-box;background-color:#6174c3}",
      map: null
    };
    Saved_queries = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $savedQueriesStore, $$unsubscribe_savedQueriesStore;
      $$unsubscribe_savedQueriesStore = subscribe(savedQueriesStore, (value) => $savedQueriesStore = value);
      let savedQueries = [];
      let filteredQueries = [];
      let searchTerm = "";
      const handleShare = (id) => {
        const queryToShare = savedQueries.find((query) => query.id === id);
        queryToShareStore.set(queryToShare);
      };
      $$result.css.add(css7);
      savedQueries = $savedQueriesStore.sort((a, b) => Number(new Date(b.created_at)) - Number(new Date(a.created_at)));
      {
        {
          {
            filteredQueries = [...savedQueries];
          }
        }
      }
      $$unsubscribe_savedQueriesStore();
      return `${validate_component(Protected, "Protected").$$render($$result, {}, {}, {
        default: () => {
          return `<div class="${"p-8 pt-0 mt-6 relative h-full overflow-y-auto auto-rows-min grid grid-cols-[1fr] md:grid-cols-[minmax(600px,1fr)] grid-rows-[fit-content,1fr] gap-4 saved-queries-list svelte-cyvla3"}"><div class="${"flex flex-col px-4 pb-4 bg-gray-700 sticky top-0 z-20"}"><h3 class="${"text-2xl mb-4 text-gray-300 grid-rows-1 whitespace-nowrap"}">Saved Queries</h3>
			<input class="${"input input-bordered w-full bg-gray-600"}" placeholder="${"Search"}"${add_attribute("value", searchTerm, 0)}></div>
		<div class="${"px-4 grid gap-4 auto-rows-max grid-cols-[repeat(auto-fill,minmax(300px,1fr))]"}">${filteredQueries.length ? each(filteredQueries, (query) => {
            return `<div class="${"card glass hover:bg-violet-800 bg-violet-900 shadow-md py-2 px-4 relative"}">${validate_component(SavedQuery, "SavedQuery").$$render($$result, { query, handleShare }, {}, {})}
				</div>`;
          }) : `<span>No saved queries</span>`}</div></div>`;
        }
      })}`;
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  css: () => css8,
  entry: () => entry4,
  js: () => js4,
  module: () => saved_queries_svelte_exports
});
var entry4, js4, css8;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_saved_queries_svelte();
    entry4 = "pages/saved-queries.svelte-20e79f48.js";
    js4 = ["pages/saved-queries.svelte-20e79f48.js", "chunks/vendor-739188d0.js", "chunks/Protected-cbec64e8.js", "chunks/supabaseClient-f98d745b.js", "chunks/SavedQuery-7c294e90.js", "chunks/singletons-d1fb5791.js"];
    css8 = ["assets/pages/saved-queries.svelte-170e4e5f.css"];
  }
});

// .svelte-kit/output/server/chunks/recipes-50224ff8.js
var recipes;
var init_recipes_50224ff8 = __esm({
  ".svelte-kit/output/server/chunks/recipes-50224ff8.js"() {
    recipes = [
      {
        id: "1",
        searchProvider: "Google",
        hoverBgColor: "hover:bg-blue-800",
        inputs: [
          {
            name: "siteUrl",
            type: "url",
            placeholder: "www.example.com",
            shouldHandleSearch: false
          },
          {
            name: "queryTerm",
            type: "text",
            placeholder: "Query",
            shouldHandleSearch: true
          }
        ],
        queryTemplate: `site:{{siteUrl}} {{queryTerm}}`,
        name: "Search your own site"
      },
      {
        id: "2",
        name: "Search on Twitter",
        hoverBgColor: "hover:bg-[#49b1f1]",
        bgColor: "bg-[#1DA1F2]",
        textColor: "text-gray-900",
        searchProvider: "Google",
        queryTemplate: `site:twitter.com {{queryTerm}}`,
        inputs: [
          {
            name: "queryTerm",
            type: "text",
            placeholder: "Query",
            shouldHandleSearch: true,
            helperText: "Example: @jack #startsmall join"
          }
        ]
      },
      {
        id: "3",
        hoverBgColor: "hover:bg-[#11b666]",
        bgColor: "bg-[#0F9D58]",
        textColor: "text-gray-900",
        queryTemplate: `site:docs.google.com/spreadsheets intitle:"{{queryTerm}}"`,
        searchProvider: "Google",
        name: "Search public Google Sheets",
        inputs: [
          {
            name: "queryTerm",
            type: "text",
            placeholder: "Query",
            shouldHandleSearch: true,
            helperText: "Example: Startup tools or Angel or Salaries"
          }
        ]
      }
    ];
  }
});

// .svelte-kit/output/server/entries/pages/recipes.svelte.js
var recipes_svelte_exports = {};
__export(recipes_svelte_exports, {
  default: () => Recipes_1
});
var import_splitio5, Recipe, css9, Recipes, Recipes_1;
var init_recipes_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/recipes.svelte.js"() {
    init_index_d153bcdc();
    init_recipes_50224ff8();
    init_supabaseClient_772c11ee();
    init_SavedQueriesList_587d9dd6();
    import_splitio5 = __toESM(require_lib4(), 1);
    init_SavedQuery_7048865a();
    init_fuzzy();
    Recipe = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { bgColor = "bg-blue-900" } = $$props;
      let { hoverBgColor = "bg-blue-800" } = $$props;
      let { textColor = "text-gray-300" } = $$props;
      let { inputs } = $$props;
      let { name } = $$props;
      let { queryTemplate } = $$props;
      let { searchProvider } = $$props;
      let state = [];
      let values = [];
      if ($$props.bgColor === void 0 && $$bindings.bgColor && bgColor !== void 0)
        $$bindings.bgColor(bgColor);
      if ($$props.hoverBgColor === void 0 && $$bindings.hoverBgColor && hoverBgColor !== void 0)
        $$bindings.hoverBgColor(hoverBgColor);
      if ($$props.textColor === void 0 && $$bindings.textColor && textColor !== void 0)
        $$bindings.textColor(textColor);
      if ($$props.inputs === void 0 && $$bindings.inputs && inputs !== void 0)
        $$bindings.inputs(inputs);
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.queryTemplate === void 0 && $$bindings.queryTemplate && queryTemplate !== void 0)
        $$bindings.queryTemplate(queryTemplate);
      if ($$props.searchProvider === void 0 && $$bindings.searchProvider && searchProvider !== void 0)
        $$bindings.searchProvider(searchProvider);
      return `<div${add_attribute("class", `flex flex-col justify-between card glass ${hoverBgColor} ${bgColor} shadow-md py-2 px-4 relative`, 0)}><div class="${"mb-2"}"><h1${add_attribute("class", `font-medium text-lg ${textColor}`, 0)}>${escape(name)}</h1>
		<div class="${"p-2"}"><div class="${"relative w-full flex gap-2 flex-col"}">${each(state, (input, i2) => {
        return `<div class="${"relative"}"><input${add_attribute("placeholder", input.placeholder, 0)}${add_attribute("type", input.type || "text", 0)} class="${"input input-sm input-bordered w-full pr-8"}"${add_attribute("value", values[i2] || "", 0)}${add_attribute("this", input.ref, 0)}>
						${input.value ? `<button class="${"absolute top-1 right-2 btn-xs btn-ghost btn btn-circle"}">\u2715</button>` : ``}
						${input.helperText ? `<span class="${"text-xs text-gray-900"}">${escape(input.helperText)}</span>` : ``}
					</div>`;
      })}</div></div></div>
	<div><div class="${"flex gap-1 align-middle items-center justify-end mt-2"}"><button${add_attribute("class", `btn btn-sm glass ${textColor}`, 0)}>Search</button></div></div></div>`;
    });
    css9 = {
      code: ".recipes-list.svelte-16op8g4::-webkit-scrollbar{width:15px}.recipes-list.svelte-16op8g4::-webkit-scrollbar-track{background-color:#555555;border-radius:100px}.recipes-list.svelte-16op8g4::-webkit-scrollbar-thumb{border-radius:80px;border:5px solid transparent;background-clip:content-box;background-color:#6174c3}",
      map: null
    };
    Recipes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css9);
      return `<div class="${"px-4 h-full grid gap-2 auto-rows-max grid-cols-[repeat(auto-fill,minmax(200px,1fr))] overflow-auto recipes-list svelte-16op8g4"}">${each(recipes, (recipe) => {
        return `${validate_component(Recipe, "Recipe").$$render($$result, {
          searchProvider: recipe.searchProvider,
          hoverBgColor: recipe.hoverBgColor,
          bgColor: recipe.bgColor,
          textColor: recipe.textColor,
          inputs: recipe.inputs,
          queryTemplate: recipe.queryTemplate,
          name: recipe.name
        }, {}, {})}`;
      })}
</div>`;
    });
    Recipes_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $authStore, $$unsubscribe_authStore;
      $$unsubscribe_authStore = subscribe(authStore, (value) => $authStore = value);
      $$unsubscribe_authStore();
      return `<div class="${"p-8 pt-6 relative h-full overflow-y-auto grid grid-cols-[1fr] md:grid-cols-[minmax(600px,1fr)_minmax(290px,400px)] gap-4"}">${validate_component(Recipes, "Recipes").$$render($$result, {}, {}, {})}

	${$authStore.isLoggedIn ? `${validate_component(SavedQueriesList, "SavedQueriesList").$$render($$result, {}, {}, {})}` : ``}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  css: () => css10,
  entry: () => entry5,
  js: () => js5,
  module: () => recipes_svelte_exports
});
var entry5, js5, css10;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_recipes_svelte();
    entry5 = "pages/recipes.svelte-c8513866.js";
    js5 = ["pages/recipes.svelte-c8513866.js", "chunks/vendor-739188d0.js", "chunks/supabaseClient-f98d745b.js", "chunks/SavedQueriesList-f8d6be83.js", "chunks/SavedQuery-7c294e90.js", "chunks/singletons-d1fb5791.js"];
    css10 = ["assets/pages/recipes.svelte-698adbdb.css", "assets/SavedQueriesList-cb9d0b05.css"];
  }
});

// .svelte-kit/output/server/entries/endpoints/recipes.ts.js
var recipes_ts_exports = {};
__export(recipes_ts_exports, {
  get: () => get
});
async function get() {
  return {
    body: {
      recipes
    }
  };
}
var init_recipes_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/recipes.ts.js"() {
    init_recipes_50224ff8();
  }
});

// .svelte-kit/vercel-tmp/entry.js
var entry_exports = {};
__export(entry_exports, {
  default: () => entry_default
});

// .svelte-kit/vercel-tmp/shims.js
init_install_fetch();
installFetch();

// node_modules/@sveltejs/kit/dist/node.js
var import_stream = require("stream");
function get_raw_body(req) {
  return new Promise((fulfil, reject) => {
    const h2 = req.headers;
    if (!h2["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h2["content-length"]);
    if (isNaN(length) && h2["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}
async function getRequest(base2, req) {
  let headers = req.headers;
  if (req.httpVersionMajor === 2) {
    headers = Object.assign({}, headers);
    delete headers[":method"];
    delete headers[":path"];
    delete headers[":authority"];
    delete headers[":scheme"];
  }
  return new Request(base2 + req.url, {
    method: req.method,
    headers,
    body: await get_raw_body(req)
  });
}
async function setResponse(res, response) {
  const headers = Object.fromEntries(response.headers);
  if (response.headers.has("set-cookie")) {
    headers["set-cookie"] = response.headers.raw()["set-cookie"];
  }
  res.writeHead(response.status, headers);
  if (response.body instanceof import_stream.Readable) {
    response.body.pipe(res);
  } else {
    if (response.body) {
      res.write(await response.arrayBuffer());
    }
    res.end();
  }
}

// .svelte-kit/output/server/index.js
init_index_d153bcdc();
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _use_hashes;
var _dev;
var _script_needs_csp;
var _style_needs_csp;
var _directives;
var _script_src;
var _style_src;
function afterUpdate() {
}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  {
    stores.page.set(page2);
  }
  return `


${components[1] ? `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => {
      return `${components[2] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
        default: () => {
          return `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}`;
        }
      })}` : `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {})}`}`;
    }
  })}` : `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {})}`}

${``}`;
});
function to_headers(object) {
  const headers = new Headers();
  if (object) {
    for (const key2 in object) {
      const value = object[key2];
      if (!value)
        continue;
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          headers.append(key2, value2);
        });
      } else {
        headers.set(key2, value);
      }
    }
  }
  return headers;
}
function hash(value) {
  let hash2 = 5381;
  let i2 = value.length;
  if (typeof value === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key2 in obj) {
    clone2[key2.toLowerCase()] = obj[key2];
  }
  return clone2;
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = params[key2].replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
  }
  return params;
}
function is_pojo(body) {
  if (typeof body !== "object")
    return false;
  if (body) {
    if (body instanceof Uint8Array)
      return false;
    if (body._readableState && typeof body.pipe === "function")
      return false;
    if (typeof ReadableStream !== "undefined" && body instanceof ReadableStream)
      return false;
  }
  return true;
}
function normalize_request_method(event) {
  const method = event.request.method.toLowerCase();
  return method === "delete" ? "del" : method;
}
function error(body) {
  return new Response(body, {
    status: 500
  });
}
function is_string(s22) {
  return typeof s22 === "string" || s22 instanceof String;
}
var text_types = /* @__PURE__ */ new Set([
  "application/xml",
  "application/json",
  "application/x-www-form-urlencoded",
  "multipart/form-data"
]);
function is_text(content_type) {
  if (!content_type)
    return true;
  const type = content_type.split(";")[0].toLowerCase();
  return type.startsWith("text/") || type.endsWith("+xml") || text_types.has(type);
}
async function render_endpoint(event, mod) {
  const method = normalize_request_method(event);
  let handler = mod[method];
  if (!handler && method === "head") {
    handler = mod.get;
  }
  if (!handler) {
    return;
  }
  const response = await handler(event);
  const preface = `Invalid response from route ${event.url.pathname}`;
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  if (response.fallthrough) {
    return;
  }
  const { status = 200, body = {} } = response;
  const headers = response.headers instanceof Headers ? new Headers(response.headers) : to_headers(response.headers);
  const type = headers.get("content-type");
  if (!is_text(type) && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if (is_pojo(body) && (!type || type.startsWith("application/json"))) {
    headers.set("content-type", "application/json; charset=utf-8");
    normalized_body = JSON.stringify(body);
  } else {
    normalized_body = body;
  }
  if ((typeof normalized_body === "string" || normalized_body instanceof Uint8Array) && !headers.has("etag")) {
    const cache_control = headers.get("cache-control");
    if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
      headers.set("etag", `"${hash(normalized_body)}"`);
    }
  }
  return new Response(method !== "head" ? normalized_body : void 0, {
    status,
    headers
  });
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key2) {
            return walk(thing[key2]);
          });
      }
    }
  }
  walk(value);
  var names = /* @__PURE__ */ new Map();
  Array.from(counts).filter(function(entry6) {
    return entry6[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry6, i2) {
    names.set(entry6[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i2) {
          return i2 in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key2) {
          return safeKey(key2) + ":" + stringify(thing[key2]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i2) {
            statements_1.push(name + "[" + i2 + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a4) {
            var k = _a4[0], v = _a4[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key2) {
            statements_1.push("" + name + safeProp(key2) + "=" + stringify(thing[key2]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars$1[num % chars$1.length] + name;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped2[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escapeUnsafeChars(JSON.stringify(key2));
}
function safeProp(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? "." + key2 : "[" + escapeUnsafeChars(JSON.stringify(key2)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped2) {
      result += escaped2[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop3() {
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop3) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set3(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update3(fn) {
    set3(fn(value));
  }
  function subscribe4(run2, invalidate = noop3) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set3) || noop3;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set3, update: update3, subscribe: subscribe4 };
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var render_json_payload_script_dict = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var render_json_payload_script_regex = new RegExp(`[${Object.keys(render_json_payload_script_dict).join("")}]`, "g");
function render_json_payload_script(attrs, payload) {
  const safe_payload = JSON.stringify(payload).replace(render_json_payload_script_regex, (match) => render_json_payload_script_dict[match]);
  let safe_attrs = "";
  for (const [key2, value] of Object.entries(attrs)) {
    if (value === void 0)
      continue;
    safe_attrs += ` sveltekit:data-${key2}=${escape_html_attr(value)}`;
  }
  return `<script type="application/json"${safe_attrs}>${safe_payload}<\/script>`;
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(`[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`, "g");
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var s2 = JSON.stringify;
function create_prerendering_url_proxy(url) {
  return new Proxy(url, {
    get: (target, prop, receiver) => {
      if (prop === "search" || prop === "searchParams") {
        throw new Error(`Cannot access url.${prop} on a page with prerendering enabled`);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
var encoder = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array = encode(data);
  for (let i2 = 0; i2 < array.length; i2 += 16) {
    const w = array.subarray(i2, i2 + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a = bytes[i2 + 0];
    const b = bytes[i2 + 1];
    const c = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c;
    bytes[i2 + 2] = b;
    bytes[i2 + 3] = a;
  }
}
function encode(str) {
  const encoded = encoder.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l; i2 += 3) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += chars[bytes[i2] & 63];
  }
  if (i2 === l + 1) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var csp_ready;
var generate_nonce;
var generate_hash;
if (typeof crypto !== "undefined") {
  const array = new Uint8Array(16);
  generate_nonce = () => {
    crypto.getRandomValues(array);
    return base64(array);
  };
  generate_hash = sha256;
} else {
  const name = "crypto";
  csp_ready = import(name).then((crypto2) => {
    generate_nonce = () => {
      return crypto2.randomBytes(16).toString("base64");
    };
    generate_hash = (input) => {
      return crypto2.createHash("sha256").update(input, "utf-8").digest().toString("base64");
    };
  });
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var Csp = class {
  constructor({ mode, directives }, { dev, prerender, needs_nonce }) {
    __privateAdd2(this, _use_hashes, void 0);
    __privateAdd2(this, _dev, void 0);
    __privateAdd2(this, _script_needs_csp, void 0);
    __privateAdd2(this, _style_needs_csp, void 0);
    __privateAdd2(this, _directives, void 0);
    __privateAdd2(this, _script_src, void 0);
    __privateAdd2(this, _style_src, void 0);
    __privateSet2(this, _use_hashes, mode === "hash" || mode === "auto" && prerender);
    __privateSet2(this, _directives, dev ? __spreadValues({}, directives) : directives);
    __privateSet2(this, _dev, dev);
    const d = __privateGet2(this, _directives);
    if (dev) {
      const effective_style_src2 = d["style-src"] || d["default-src"];
      if (effective_style_src2 && !effective_style_src2.includes("unsafe-inline")) {
        d["style-src"] = [...effective_style_src2, "unsafe-inline"];
      }
    }
    __privateSet2(this, _script_src, []);
    __privateSet2(this, _style_src, []);
    const effective_script_src = d["script-src"] || d["default-src"];
    const effective_style_src = d["style-src"] || d["default-src"];
    __privateSet2(this, _script_needs_csp, !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0);
    __privateSet2(this, _style_needs_csp, !dev && !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0);
    this.script_needs_nonce = __privateGet2(this, _script_needs_csp) && !__privateGet2(this, _use_hashes);
    this.style_needs_nonce = __privateGet2(this, _style_needs_csp) && !__privateGet2(this, _use_hashes);
    if (this.script_needs_nonce || this.style_needs_nonce || needs_nonce) {
      this.nonce = generate_nonce();
    }
  }
  add_script(content) {
    if (__privateGet2(this, _script_needs_csp)) {
      if (__privateGet2(this, _use_hashes)) {
        __privateGet2(this, _script_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet2(this, _script_src).length === 0) {
        __privateGet2(this, _script_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  add_style(content) {
    if (__privateGet2(this, _style_needs_csp)) {
      if (__privateGet2(this, _use_hashes)) {
        __privateGet2(this, _style_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet2(this, _style_src).length === 0) {
        __privateGet2(this, _style_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  get_header(is_meta = false) {
    const header = [];
    const directives = __spreadValues({}, __privateGet2(this, _directives));
    if (__privateGet2(this, _style_src).length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...__privateGet2(this, _style_src)
      ];
    }
    if (__privateGet2(this, _script_src).length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...__privateGet2(this, _script_src)
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = directives[key2];
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
  get_meta() {
    const content = escape_html_attr(this.get_header(true));
    return `<meta http-equiv="content-security-policy" content=${content}>`;
  }
};
_use_hashes = /* @__PURE__ */ new WeakMap();
_dev = /* @__PURE__ */ new WeakMap();
_script_needs_csp = /* @__PURE__ */ new WeakMap();
_style_needs_csp = /* @__PURE__ */ new WeakMap();
_directives = /* @__PURE__ */ new WeakMap();
_script_src = /* @__PURE__ */ new WeakMap();
_style_src = /* @__PURE__ */ new WeakMap();
var updated = __spreadProps(__spreadValues({}, readable(false)), {
  check: () => false
});
async function render_response({
  branch,
  options,
  state,
  $session,
  page_config,
  status,
  error: error2,
  url,
  params,
  resolve_opts,
  stuff
}) {
  if (state.prerender) {
    if (options.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options.template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %svelte.nonce%");
    }
  }
  const stylesheets = new Set(options.manifest._.entry.css);
  const modulepreloads = new Set(options.manifest._.entry.js);
  const styles = /* @__PURE__ */ new Map();
  const serialized_data = [];
  let shadow_props;
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options.get_stack(error2);
  }
  if (resolve_opts.ssr) {
    branch.forEach(({ node, props: props2, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url2) => stylesheets.add(url2));
      if (node.js)
        node.js.forEach((url2) => modulepreloads.add(url2));
      if (node.styles)
        Object.entries(node.styles).forEach(([k, v]) => styles.set(k, v));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (props2)
        shadow_props = props2;
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session,
        updated
      },
      page: {
        url: state.prerender ? create_prerendering_url_proxy(url) : url,
        params,
        status,
        error: error2,
        stuff
      },
      components: branch.map(({ node }) => node.module.default)
    };
    const print_error = (property, replacement) => {
      Object.defineProperty(props.page, property, {
        get: () => {
          throw new Error(`$page.${property} has been replaced by $page.url.${replacement}`);
        }
      });
    };
    print_error("origin", "origin");
    print_error("path", "pathname");
    print_error("query", "searchParams");
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let { head, html: body } = rendered;
  const inlined_style = Array.from(styles.values()).join("\n");
  await csp_ready;
  const csp = new Csp(options.csp, {
    dev: options.dev,
    prerender: !!state.prerender,
    needs_nonce: options.template_contains_nonce
  });
  const target = hash(body);
  const init_app = `
		import { start } from ${s2(options.prefix + options.manifest._.entry.file)};
		start({
			target: document.querySelector('[data-hydrate="${target}"]').parentNode,
			paths: ${s2(options.paths)},
			session: ${try_serialize($session, (error3) => {
    throw new Error(`Failed to serialize session data: ${error3.message}`);
  })},
			route: ${!!page_config.router},
			spa: ${!resolve_opts.ssr},
			trailing_slash: ${s2(options.trailing_slash)},
			hydrate: ${resolve_opts.ssr && page_config.hydrate ? `{
				status: ${status},
				error: ${serialize_error(error2)},
				nodes: [
					${(branch || []).map(({ node }) => `import(${s2(options.prefix + node.entry)})`).join(",\n						")}
				],
				params: ${devalue(params)}
			}` : "null"}
		});
	`;
  const init_service_worker = `
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('${options.service_worker}');
		}
	`;
  if (options.amp) {
    const styles2 = `${inlined_style}
${rendered.css.code}`;
    head += `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>

		<style amp-custom>${styles2}</style>`;
    if (options.service_worker) {
      head += '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>';
      body += `<amp-install-serviceworker src="${options.service_worker}" layout="nodisplay"></amp-install-serviceworker>`;
    }
  } else {
    if (inlined_style) {
      const attributes = [];
      if (options.dev)
        attributes.push(" data-svelte");
      if (csp.style_needs_nonce)
        attributes.push(` nonce="${csp.nonce}"`);
      csp.add_style(inlined_style);
      head += `
	<style${attributes.join("")}>${inlined_style}</style>`;
    }
    head += Array.from(stylesheets).map((dep) => {
      const attributes = [
        'rel="stylesheet"',
        `href="${options.prefix + dep}"`
      ];
      if (csp.style_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      if (styles.has(dep)) {
        attributes.push("disabled", 'media="(max-width: 0)"');
      }
      return `
	<link ${attributes.join(" ")}>`;
    }).join("");
    if (page_config.router || page_config.hydrate) {
      head += Array.from(modulepreloads).map((dep) => `
	<link rel="modulepreload" href="${options.prefix + dep}">`).join("");
      const attributes = ['type="module"', `data-hydrate="${target}"`];
      csp.add_script(init_app);
      if (csp.script_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      body += `
		<script ${attributes.join(" ")}>${init_app}<\/script>`;
      body += serialized_data.map(({ url: url2, body: body2, response }) => render_json_payload_script({ type: "data", url: url2, body: typeof body2 === "string" ? hash(body2) : void 0 }, response)).join("\n	");
      if (shadow_props) {
        body += render_json_payload_script({ type: "props" }, shadow_props);
      }
    }
    if (options.service_worker) {
      csp.add_script(init_service_worker);
      head += `
				<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_service_worker}<\/script>`;
    }
  }
  if (state.prerender && !options.amp) {
    const http_equiv = [];
    const csp_headers = csp.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (maxage) {
      http_equiv.push(`<meta http-equiv="cache-control" content="max-age=${maxage}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  }
  const segments = url.pathname.slice(options.paths.base.length).split("/").slice(2);
  const assets2 = options.paths.assets || (segments.length > 0 ? segments.map(() => "..").join("/") : ".");
  const html = await resolve_opts.transformPage({
    html: options.template({ head, body, assets: assets2, nonce: csp.nonce })
  });
  const headers = new Headers({
    "content-type": "text/html",
    etag: `"${hash(html)}"`
  });
  if (maxage) {
    headers.set("cache-control", `${is_private ? "private" : "public"}, max-age=${maxage}`);
  }
  if (!options.floc) {
    headers.set("permissions-policy", "interest-cohort=()");
  }
  if (!state.prerender) {
    const csp_header = csp.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
  }
  return new Response(html, {
    status,
    headers
  });
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize(__spreadProps(__spreadValues({}, error2), { name, message, stack }));
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var absolute = /^([a-z]+:)?\/?\//;
var scheme = /^[a-z]+:/;
function resolve(base2, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && /\/[^./]+$/.test(path)) {
    return path + "/";
  }
  return path;
}
async function load_node({
  event,
  options,
  state,
  route,
  url,
  params,
  node,
  $session,
  stuff,
  is_error,
  is_leaf,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const shadow = is_leaf ? await load_shadow_data(route, event, options, !!state.prerender) : {};
  if (shadow.fallthrough)
    return;
  if (shadow.cookies) {
    set_cookie_headers.push(...shadow.cookies);
  }
  if (shadow.error) {
    loaded = {
      status: shadow.status,
      error: shadow.error
    };
  } else if (shadow.redirect) {
    loaded = {
      status: shadow.status,
      redirect: shadow.redirect
    };
  } else if (module2.load) {
    const load_input = {
      url: state.prerender ? create_prerendering_url_proxy(url) : url,
      params,
      props: shadow.body || {},
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let requested;
        if (typeof resource === "string") {
          requested = resource;
        } else {
          requested = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        opts.headers = new Headers(opts.headers);
        for (const [key2, value] of event.request.headers) {
          if (key2 !== "authorization" && key2 !== "cookie" && key2 !== "host" && key2 !== "if-none-match" && !opts.headers.has(key2)) {
            opts.headers.set(key2, value);
          }
        }
        const resolved = resolve(event.url.pathname, requested.split("?")[0]);
        let response;
        let dependency;
        const prefix = options.paths.assets || options.paths.base;
        const filename = decodeURIComponent(resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = options.manifest.assets.has(filename);
        const is_asset_html = options.manifest.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (options.read) {
            const type = is_asset ? options.manifest._.mime[filename.slice(filename.lastIndexOf("."))] : "text/html";
            response = new Response(options.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else {
            response = await fetch(`${url.origin}/${file}`, opts);
          }
        } else if (is_root_relative(resolved)) {
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie = event.request.headers.get("cookie");
            const authorization = event.request.headers.get("authorization");
            if (cookie) {
              opts.headers.set("cookie", cookie);
            }
            if (authorization && !opts.headers.has("authorization")) {
              opts.headers.set("authorization", authorization);
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          response = await respond(new Request(new URL(requested, event.url).href, opts), options, {
            fetched: requested,
            initiator: route
          });
          if (state.prerender) {
            dependency = { response, body: null };
            state.prerender.dependencies.set(resolved, dependency);
          }
        } else {
          if (resolved.startsWith("//")) {
            requested = event.url.protocol + requested;
          }
          if (`.${new URL(requested).hostname}`.endsWith(`.${event.url.hostname}`) && opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie = event.request.headers.get("cookie");
            if (cookie)
              opts.headers.set("cookie", cookie);
          }
          const external_request = new Request(requested, opts);
          response = await options.hooks.externalFetch.call(null, external_request);
        }
        const proxy = new Proxy(response, {
          get(response2, key2, _receiver) {
            async function text() {
              const body = await response2.text();
              const headers = {};
              for (const [key3, value] of response2.headers) {
                if (key3 === "set-cookie") {
                  set_cookie_headers = set_cookie_headers.concat(value);
                } else if (key3 !== "etag") {
                  headers[key3] = value;
                }
              }
              if (!opts.body || typeof opts.body === "string") {
                const status_number = Number(response2.status);
                if (isNaN(status_number)) {
                  throw new Error(`response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`);
                }
                fetched.push({
                  url: requested,
                  body: opts.body,
                  response: {
                    status: status_number,
                    statusText: response2.statusText,
                    headers,
                    body
                  }
                });
              }
              if (dependency) {
                dependency.body = body;
              }
              return body;
            }
            if (key2 === "arrayBuffer") {
              return async () => {
                const buffer = await response2.arrayBuffer();
                if (dependency) {
                  dependency.body = new Uint8Array(buffer);
                }
                return buffer;
              };
            }
            if (key2 === "text") {
              return text;
            }
            if (key2 === "json") {
              return async () => {
                return JSON.parse(await text());
              };
            }
            return Reflect.get(response2, key2, response2);
          }
        });
        return proxy;
      },
      stuff: __spreadValues({}, stuff)
    };
    if (options.dev) {
      Object.defineProperty(load_input, "page", {
        get: () => {
          throw new Error("`page` in `load` functions has been replaced by `url` and `params`");
        }
      });
    }
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
    if (!loaded) {
      throw new Error(`load function must return a value${options.dev ? ` (${node.entry})` : ""}`);
    }
  } else if (shadow.body) {
    loaded = {
      props: shadow.body
    };
  } else {
    loaded = {};
  }
  if (loaded.fallthrough && !is_error) {
    return;
  }
  if (shadow.body && state.prerender) {
    const pathname = `${event.url.pathname.replace(/\/$/, "")}/__data.json`;
    const dependency = {
      response: new Response(void 0),
      body: JSON.stringify(shadow.body)
    };
    state.prerender.dependencies.set(pathname, dependency);
  }
  return {
    node,
    props: shadow.body,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function load_shadow_data(route, event, options, prerender) {
  if (!route.shadow)
    return {};
  try {
    const mod = await route.shadow();
    if (prerender && (mod.post || mod.put || mod.del || mod.patch)) {
      throw new Error("Cannot prerender pages that have endpoints with mutative methods");
    }
    const method = normalize_request_method(event);
    const is_get = method === "head" || method === "get";
    const handler = method === "head" ? mod.head || mod.get : mod[method];
    if (!handler && !is_get) {
      return {
        status: 405,
        error: new Error(`${method} method not allowed`)
      };
    }
    const data = {
      status: 200,
      cookies: [],
      body: {}
    };
    if (!is_get) {
      const result = await handler(event);
      if (result.fallthrough)
        return result;
      const { status, headers, body } = validate_shadow_output(result);
      data.status = status;
      add_cookies(data.cookies, headers);
      if (status >= 300 && status < 400) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = body;
    }
    const get2 = method === "head" && mod.head || mod.get;
    if (get2) {
      const result = await get2(event);
      if (result.fallthrough)
        return result;
      const { status, headers, body } = validate_shadow_output(result);
      add_cookies(data.cookies, headers);
      data.status = status;
      if (status >= 400) {
        data.error = new Error("Failed to load data");
        return data;
      }
      if (status >= 300) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = __spreadValues(__spreadValues({}, body), data.body);
    }
    return data;
  } catch (e2) {
    const error2 = coalesce_to_error(e2);
    options.handle_error(error2, event);
    return {
      status: 500,
      error: error2
    };
  }
}
function add_cookies(target, headers) {
  const cookies = headers["set-cookie"];
  if (cookies) {
    if (Array.isArray(cookies)) {
      target.push(...cookies);
    } else {
      target.push(cookies);
    }
  }
}
function validate_shadow_output(result) {
  const { status = 200, body = {} } = result;
  let headers = result.headers || {};
  if (headers instanceof Headers) {
    if (headers.has("set-cookie")) {
      throw new Error("Endpoint request handler cannot use Headers interface with Set-Cookie headers");
    }
  } else {
    headers = lowercase_keys(headers);
  }
  if (!is_pojo(body)) {
    throw new Error("Body returned from endpoint request handler must be a plain object");
  }
  return { status, headers, body };
}
async function respond_with_error({
  event,
  options,
  state,
  $session,
  status,
  error: error2,
  resolve_opts
}) {
  try {
    const default_layout = await options.manifest._.nodes[0]();
    const default_error = await options.manifest._.nodes[1]();
    const params = {};
    const layout_loaded = await load_node({
      event,
      options,
      state,
      route: null,
      url: event.url,
      params,
      node: default_layout,
      $session,
      stuff: {},
      is_error: false,
      is_leaf: false
    });
    const error_loaded = await load_node({
      event,
      options,
      state,
      route: null,
      url: event.url,
      params,
      node: default_error,
      $session,
      stuff: layout_loaded ? layout_loaded.stuff : {},
      is_error: true,
      is_leaf: false,
      status,
      error: error2
    });
    return await render_response({
      options,
      state,
      $session,
      page_config: {
        hydrate: options.hydrate,
        router: options.router
      },
      stuff: error_loaded.stuff,
      status,
      error: error2,
      branch: [layout_loaded, error_loaded],
      url: event.url,
      params,
      resolve_opts
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return new Response(error3.stack, {
      status: 500
    });
  }
}
async function respond$1(opts) {
  const { event, options, state, $session, route, resolve_opts } = opts;
  let nodes;
  if (!resolve_opts.ssr) {
    return await render_response(__spreadProps(__spreadValues({}, opts), {
      branch: [],
      page_config: {
        hydrate: true,
        router: true
      },
      status: 200,
      url: event.url,
      stuff: {}
    }));
  }
  try {
    nodes = await Promise.all(route.a.map((n) => options.manifest._.nodes[n] && options.manifest._.nodes[n]()));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return await respond_with_error({
      event,
      options,
      state,
      $session,
      status: 500,
      error: error3,
      resolve_opts
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return new Response(void 0, {
      status: 204
    });
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  let stuff = {};
  ssr:
    if (resolve_opts.ssr) {
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
              url: event.url,
              node,
              stuff,
              is_error: false,
              is_leaf: i2 === nodes.length - 1
            }));
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies(new Response(void 0, {
                status: loaded.loaded.status,
                headers: {
                  location: loaded.loaded.redirect
                }
              }), set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e2 = coalesce_to_error(err);
            options.handle_error(e2, event);
            status = 500;
            error2 = e2;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const error_node = await options.manifest._.nodes[route.b[i2]]();
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
                    url: event.url,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    is_error: true,
                    is_leaf: false,
                    status,
                    error: error2
                  }));
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  stuff = __spreadValues(__spreadValues({}, node_loaded.stuff), error_loaded.stuff);
                  break ssr;
                } catch (err) {
                  const e2 = coalesce_to_error(err);
                  options.handle_error(e2, event);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              event,
              options,
              state,
              $session,
              status,
              error: error2,
              resolve_opts
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = __spreadValues(__spreadValues({}, stuff), loaded.loaded.stuff);
        }
      }
    }
  try {
    return with_cookies(await render_response(__spreadProps(__spreadValues({}, opts), {
      stuff,
      url: event.url,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    })), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return with_cookies(await respond_with_error(__spreadProps(__spreadValues({}, opts), {
      status: 500,
      error: error3
    })), set_cookie_headers);
  }
}
function get_page_config(leaf, options) {
  if ("ssr" in leaf) {
    throw new Error("`export const ssr` has been removed \u2014 use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle");
  }
  return {
    router: "router" in leaf ? !!leaf.router : options.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    set_cookie_headers.forEach((value) => {
      response.headers.append("set-cookie", value);
    });
  }
  return response;
}
async function render_page(event, route, options, state, resolve_opts) {
  if (state.initiator === route) {
    return new Response(`Not found: ${event.url.pathname}`, {
      status: 404
    });
  }
  if (route.shadow) {
    const type = negotiate(event.request.headers.get("accept") || "text/html", [
      "text/html",
      "application/json"
    ]);
    if (type === "application/json") {
      return render_endpoint(event, await route.shadow());
    }
  }
  const $session = await options.hooks.getSession(event);
  const response = await respond$1({
    event,
    options,
    state,
    $session,
    resolve_opts,
    route,
    params: event.params
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return new Response(`Bad request in load function: failed to fetch ${state.fetched}`, {
      status: 500
    });
  }
}
function negotiate(accept, types2) {
  const parts = accept.split(",").map((str, i2) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      return { type, subtype, q: +q, i: i2 };
    }
    throw new Error(`Invalid Accept header: ${accept}`);
  }).sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types2) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex((part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*"));
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
var DATA_SUFFIX = "/__data.json";
var default_transform = ({ html }) => html;
async function respond(request, options, state = {}) {
  var _a4;
  const url = new URL(request.url);
  const normalized = normalize_path(url.pathname, options.trailing_slash);
  if (normalized !== url.pathname) {
    return new Response(void 0, {
      status: 301,
      headers: {
        location: normalized + (url.search === "?" ? "" : url.search)
      }
    });
  }
  const { parameter, allowed } = options.method_override;
  const method_override = (_a4 = url.searchParams.get(parameter)) == null ? void 0 : _a4.toUpperCase();
  if (method_override) {
    if (request.method === "POST") {
      if (allowed.includes(method_override)) {
        request = new Proxy(request, {
          get: (target, property, _receiver) => {
            if (property === "method")
              return method_override;
            return Reflect.get(target, property, target);
          }
        });
      } else {
        const verb = allowed.length === 0 ? "enabled" : "allowed";
        const body = `${parameter}=${method_override} is not ${verb}. See https://kit.svelte.dev/docs/configuration#methodoverride`;
        return new Response(body, {
          status: 400
        });
      }
    } else {
      throw new Error(`${parameter}=${method_override} is only allowed with POST requests`);
    }
  }
  const event = {
    request,
    url,
    params: {},
    locals: {},
    platform: state.platform
  };
  const removed = (property, replacement, suffix = "") => ({
    get: () => {
      throw new Error(`event.${property} has been replaced by event.${replacement}` + suffix);
    }
  });
  const details = ". See https://github.com/sveltejs/kit/pull/3384 for details";
  const body_getter = {
    get: () => {
      throw new Error("To access the request body use the text/json/arrayBuffer/formData methods, e.g. `body = await request.json()`" + details);
    }
  };
  Object.defineProperties(event, {
    method: removed("method", "request.method", details),
    headers: removed("headers", "request.headers", details),
    origin: removed("origin", "url.origin"),
    path: removed("path", "url.pathname"),
    query: removed("query", "url.searchParams"),
    body: body_getter,
    rawBody: body_getter
  });
  let resolve_opts = {
    ssr: true,
    transformPage: default_transform
  };
  try {
    const response = await options.hooks.handle({
      event,
      resolve: async (event2, opts) => {
        if (opts) {
          resolve_opts = {
            ssr: opts.ssr !== false,
            transformPage: opts.transformPage || default_transform
          };
        }
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            url: event2.url,
            params: event2.params,
            options,
            state,
            $session: await options.hooks.getSession(event2),
            page_config: { router: true, hydrate: true },
            stuff: {},
            status: 200,
            branch: [],
            resolve_opts: __spreadProps(__spreadValues({}, resolve_opts), {
              ssr: false
            })
          });
        }
        let decoded = decodeURI(event2.url.pathname);
        if (options.paths.base) {
          if (!decoded.startsWith(options.paths.base)) {
            return new Response(void 0, { status: 404 });
          }
          decoded = decoded.slice(options.paths.base.length) || "/";
        }
        const is_data_request = decoded.endsWith(DATA_SUFFIX);
        if (is_data_request) {
          decoded = decoded.slice(0, -DATA_SUFFIX.length) || "/";
          const normalized2 = normalize_path(url.pathname.slice(0, -DATA_SUFFIX.length), options.trailing_slash);
          event2.url = new URL(event2.url.origin + normalized2 + event2.url.search);
        }
        for (const route of options.manifest._.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          event2.params = route.params ? decode_params(route.params(match)) : {};
          let response2;
          if (is_data_request && route.type === "page" && route.shadow) {
            response2 = await render_endpoint(event2, await route.shadow());
            if (request.headers.get("x-sveltekit-load") === "true") {
              if (response2) {
                if (response2.status >= 300 && response2.status < 400) {
                  const location = response2.headers.get("location");
                  if (location) {
                    const headers = new Headers(response2.headers);
                    headers.set("x-sveltekit-location", location);
                    response2 = new Response(void 0, {
                      status: 204,
                      headers
                    });
                  }
                }
              } else {
                response2 = new Response("{}", {
                  headers: {
                    "content-type": "application/json"
                  }
                });
              }
            }
          } else {
            response2 = route.type === "endpoint" ? await render_endpoint(event2, await route.load()) : await render_page(event2, route, options, state, resolve_opts);
          }
          if (response2) {
            if (response2.status === 200 && response2.headers.has("etag")) {
              let if_none_match_value = request.headers.get("if-none-match");
              if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                if_none_match_value = if_none_match_value.substring(2);
              }
              const etag = response2.headers.get("etag");
              if (if_none_match_value === etag) {
                const headers = new Headers({ etag });
                for (const key2 of [
                  "cache-control",
                  "content-location",
                  "date",
                  "expires",
                  "vary"
                ]) {
                  const value = response2.headers.get(key2);
                  if (value)
                    headers.set(key2, value);
                }
                return new Response(void 0, {
                  status: 304,
                  headers
                });
              }
            }
            return response2;
          }
        }
        if (!state.initiator) {
          const $session = await options.hooks.getSession(event2);
          return await respond_with_error({
            event: event2,
            options,
            state,
            $session,
            status: 404,
            error: new Error(`Not found: ${event2.url.pathname}`),
            resolve_opts
          });
        }
        return await fetch(request);
      },
      get request() {
        throw new Error("request in handle has been replaced with event" + details);
      }
    });
    if (response && !(response instanceof Response)) {
      throw new Error("handle must return a Response object" + details);
    }
    return response;
  } catch (e2) {
    const error2 = coalesce_to_error(e2);
    options.handle_error(error2, event);
    try {
      const $session = await options.hooks.getSession(event);
      return await respond_with_error({
        event,
        options,
        state,
        $session,
        status: 500,
        error: error2,
        resolve_opts
      });
    } catch (e22) {
      const error3 = coalesce_to_error(e22);
      return new Response(options.dev ? error3.stack : error3.message, {
        status: 500
      });
    }
  }
}
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
var user_hooks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var template = ({ head, body, assets: assets2, nonce }) => `<!DOCTYPE html>
<html lang="en" data-theme="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="theme-color" content="#317EFB" />
		<link rel="manifest" crossorigin="use-credentials" href="site.webmanifest" />
		<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
		<link
			rel="search"
			type="application/opensearchdescription+xml"
			title="Pro-Search"
			href="https://www.pro-search.io/opensearch.xml"
		/>
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script
			crossorigin="anonymous"
			async
			src="https://www.googletagmanager.com/gtag/js?id=G-S20NGL4S0C"
		><\/script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag() {
				dataLayer.push(arguments);
			}
			gtag('js', new Date());

			gtag('config', 'G-S20NGL4S0C');
		<\/script>

		` + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var read = null;
set_paths({ "base": "", "assets": "" });
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
  handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
  externalFetch: hooks.externalFetch || fetch
});
var Server = class {
  constructor(manifest2) {
    const hooks = get_hooks(user_hooks);
    this.options = {
      amp: false,
      csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
      dev: false,
      floc: false,
      get_stack: (error2) => String(error2),
      handle_error: (error2, event) => {
        hooks.handleError({
          error: error2,
          event,
          get request() {
            throw new Error("request in handleError has been replaced with event. See https://github.com/sveltejs/kit/pull/3384 for details");
          }
        });
        error2.stack = this.options.get_stack(error2);
      },
      hooks,
      hydrate: true,
      manifest: manifest2,
      method_override: { "parameter": "_method", "allowed": [] },
      paths: { base, assets },
      prefix: assets + "/_app/",
      prerender: true,
      read,
      root: Root,
      service_worker: base + "/service-worker.js",
      router: true,
      template,
      template_contains_nonce: false,
      trailing_slash: "never"
    };
  }
  respond(request, options = {}) {
    if (!(request instanceof Request)) {
      throw new Error("The first argument to app.render must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details");
    }
    return respond(request, this.options, options);
  }
};

// .svelte-kit/vercel-tmp/manifest.js
var manifest = {
  appDir: "_app",
  assets: /* @__PURE__ */ new Set(["OG.png", "OG.svg", "apple-touch-icon.png", "favicon.png", "logo_512.png", "opensearch.xml", "robots.txt", "site.webmanifest", "service-worker.js"]),
  _: {
    mime: { ".png": "image/png", ".svg": "image/svg+xml", ".xml": "application/xml", ".txt": "text/plain", ".webmanifest": "application/manifest+json" },
    entry: { "file": "start-90b254da.js", "js": ["start-90b254da.js", "chunks/vendor-739188d0.js", "chunks/singletons-d1fb5791.js"], "css": [] },
    nodes: [
      () => Promise.resolve().then(() => (init__(), __exports)),
      () => Promise.resolve().then(() => (init__2(), __exports2)),
      () => Promise.resolve().then(() => (init__3(), __exports3)),
      () => Promise.resolve().then(() => (init__4(), __exports4)),
      () => Promise.resolve().then(() => (init__5(), __exports5))
    ],
    routes: [
      {
        type: "page",
        pattern: /^\/$/,
        params: null,
        path: "/",
        shadow: null,
        a: [0, 2],
        b: [1]
      },
      {
        type: "page",
        pattern: /^\/saved-queries\/?$/,
        params: null,
        path: "/saved-queries",
        shadow: null,
        a: [0, 3],
        b: [1]
      },
      {
        type: "page",
        pattern: /^\/recipes\/?$/,
        params: null,
        path: "/recipes",
        shadow: () => Promise.resolve().then(() => (init_recipes_ts(), recipes_ts_exports)),
        a: [0, 4],
        b: [1]
      }
    ]
  }
};

// .svelte-kit/vercel-tmp/entry.js
var server = new Server(manifest);
var entry_default = async (req, res) => {
  let request;
  try {
    request = await getRequest(`https://${req.headers.host}`, req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  setResponse(res, await server.respond(request));
};
module.exports = __toCommonJS(entry_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * +----------------------------------------------------------------------------------+
 * | murmurHash3.js v3.0.0 (http://github.com/karanlyons/murmurHash3.js)              |
 * | A TypeScript/JavaScript implementation of MurmurHash3's hashing algorithms.      |
 * |----------------------------------------------------------------------------------|
 * | Copyright (c) 2012-2020 Karan Lyons. Freely distributable under the MIT license. |
 * +----------------------------------------------------------------------------------+
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! Case - v1.6.2 - 2020-03-24
* Copyright (c) 2020 Nathan Bubna; Licensed MIT, GPL */
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
